import { createRequire } from "node:module";
import path, { dirname, isAbsolute, join, resolve } from "node:path";
import fs, { existsSync, lstatSync, readdirSync } from "node:fs";
import process$1, { stdin, stdout } from "node:process";
import { fileURLToPath } from "node:url";
import * as _ from "node:readline";
import Eu from "node:readline";
import { ReadStream, WriteStream } from "node:tty";
import { stripVTControlCharacters } from "node:util";
import { delimiter, dirname as dirname$1, normalize, resolve as resolve$1 } from "path";
import { cwd } from "process";
import { spawn } from "child_process";
import { PassThrough } from "stream";
import me from "readline";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (all) => {
	let target = {};
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
	return target;
};
var __copyProps = (to, from$1, except, desc) => {
	if (from$1 && typeof from$1 === "object" || typeof from$1 === "function") for (var keys = __getOwnPropNames(from$1), i$1 = 0, n$1 = keys.length, key; i$1 < n$1; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k$2) => from$1[k$2]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from$1, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/error.js
var require_error = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/error.js": ((exports) => {
	/**
	* CommanderError class
	*/
	var CommanderError$3 = class extends Error {
		/**
		* Constructs the CommanderError class
		* @param {number} exitCode suggested exit code which could be used with process.exit
		* @param {string} code an id string representing the error
		* @param {string} message human-readable description of the error
		*/
		constructor(exitCode, code, message) {
			super(message);
			Error.captureStackTrace(this, this.constructor);
			this.name = this.constructor.name;
			this.code = code;
			this.exitCode = exitCode;
			this.nestedError = void 0;
		}
	};
	/**
	* InvalidArgumentError class
	*/
	var InvalidArgumentError$4 = class extends CommanderError$3 {
		/**
		* Constructs the InvalidArgumentError class
		* @param {string} [message] explanation of why argument is invalid
		*/
		constructor(message) {
			super(1, "commander.invalidArgument", message);
			Error.captureStackTrace(this, this.constructor);
			this.name = this.constructor.name;
		}
	};
	exports.CommanderError = CommanderError$3;
	exports.InvalidArgumentError = InvalidArgumentError$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/argument.js
var require_argument = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/argument.js": ((exports) => {
	const { InvalidArgumentError: InvalidArgumentError$3 } = require_error();
	var Argument$3 = class {
		/**
		* Initialize a new command argument with the given name and description.
		* The default is that the argument is required, and you can explicitly
		* indicate this with <> around the name. Put [] around the name for an optional argument.
		*
		* @param {string} name
		* @param {string} [description]
		*/
		constructor(name, description) {
			this.description = description || "";
			this.variadic = false;
			this.parseArg = void 0;
			this.defaultValue = void 0;
			this.defaultValueDescription = void 0;
			this.argChoices = void 0;
			switch (name[0]) {
				case "<":
					this.required = true;
					this._name = name.slice(1, -1);
					break;
				case "[":
					this.required = false;
					this._name = name.slice(1, -1);
					break;
				default:
					this.required = true;
					this._name = name;
					break;
			}
			if (this._name.length > 3 && this._name.slice(-3) === "...") {
				this.variadic = true;
				this._name = this._name.slice(0, -3);
			}
		}
		/**
		* Return argument name.
		*
		* @return {string}
		*/
		name() {
			return this._name;
		}
		/**
		* @package
		*/
		_concatValue(value, previous) {
			if (previous === this.defaultValue || !Array.isArray(previous)) return [value];
			return previous.concat(value);
		}
		/**
		* Set the default value, and optionally supply the description to be displayed in the help.
		*
		* @param {*} value
		* @param {string} [description]
		* @return {Argument}
		*/
		default(value, description) {
			this.defaultValue = value;
			this.defaultValueDescription = description;
			return this;
		}
		/**
		* Set the custom handler for processing CLI command arguments into argument values.
		*
		* @param {Function} [fn]
		* @return {Argument}
		*/
		argParser(fn) {
			this.parseArg = fn;
			return this;
		}
		/**
		* Only allow argument value to be one of choices.
		*
		* @param {string[]} values
		* @return {Argument}
		*/
		choices(values) {
			this.argChoices = values.slice();
			this.parseArg = (arg, previous) => {
				if (!this.argChoices.includes(arg)) throw new InvalidArgumentError$3(`Allowed choices are ${this.argChoices.join(", ")}.`);
				if (this.variadic) return this._concatValue(arg, previous);
				return arg;
			};
			return this;
		}
		/**
		* Make argument required.
		*
		* @returns {Argument}
		*/
		argRequired() {
			this.required = true;
			return this;
		}
		/**
		* Make argument optional.
		*
		* @returns {Argument}
		*/
		argOptional() {
			this.required = false;
			return this;
		}
	};
	/**
	* Takes an argument and returns its human readable equivalent for help usage.
	*
	* @param {Argument} arg
	* @return {string}
	* @private
	*/
	function humanReadableArgName$2(arg) {
		const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
		return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
	}
	exports.Argument = Argument$3;
	exports.humanReadableArgName = humanReadableArgName$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/help.js
var require_help = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/help.js": ((exports) => {
	const { humanReadableArgName: humanReadableArgName$1 } = require_argument();
	/**
	* TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
	* https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
	* @typedef { import("./argument.js").Argument } Argument
	* @typedef { import("./command.js").Command } Command
	* @typedef { import("./option.js").Option } Option
	*/
	var Help$3 = class {
		constructor() {
			this.helpWidth = void 0;
			this.minWidthToWrap = 40;
			this.sortSubcommands = false;
			this.sortOptions = false;
			this.showGlobalOptions = false;
		}
		/**
		* prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
		* and just before calling `formatHelp()`.
		*
		* Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
		*
		* @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
		*/
		prepareContext(contextOptions) {
			this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
		}
		/**
		* Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
		*
		* @param {Command} cmd
		* @returns {Command[]}
		*/
		visibleCommands(cmd) {
			const visibleCommands = cmd.commands.filter((cmd$1) => !cmd$1._hidden);
			const helpCommand = cmd._getHelpCommand();
			if (helpCommand && !helpCommand._hidden) visibleCommands.push(helpCommand);
			if (this.sortSubcommands) visibleCommands.sort((a, b$1) => {
				return a.name().localeCompare(b$1.name());
			});
			return visibleCommands;
		}
		/**
		* Compare options for sort.
		*
		* @param {Option} a
		* @param {Option} b
		* @returns {number}
		*/
		compareOptions(a, b$1) {
			const getSortKey = (option) => {
				return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
			};
			return getSortKey(a).localeCompare(getSortKey(b$1));
		}
		/**
		* Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
		*
		* @param {Command} cmd
		* @returns {Option[]}
		*/
		visibleOptions(cmd) {
			const visibleOptions = cmd.options.filter((option) => !option.hidden);
			const helpOption = cmd._getHelpOption();
			if (helpOption && !helpOption.hidden) {
				const removeShort = helpOption.short && cmd._findOption(helpOption.short);
				const removeLong = helpOption.long && cmd._findOption(helpOption.long);
				if (!removeShort && !removeLong) visibleOptions.push(helpOption);
				else if (helpOption.long && !removeLong) visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
				else if (helpOption.short && !removeShort) visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
			}
			if (this.sortOptions) visibleOptions.sort(this.compareOptions);
			return visibleOptions;
		}
		/**
		* Get an array of the visible global options. (Not including help.)
		*
		* @param {Command} cmd
		* @returns {Option[]}
		*/
		visibleGlobalOptions(cmd) {
			if (!this.showGlobalOptions) return [];
			const globalOptions = [];
			for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
				const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
				globalOptions.push(...visibleOptions);
			}
			if (this.sortOptions) globalOptions.sort(this.compareOptions);
			return globalOptions;
		}
		/**
		* Get an array of the arguments if any have a description.
		*
		* @param {Command} cmd
		* @returns {Argument[]}
		*/
		visibleArguments(cmd) {
			if (cmd._argsDescription) cmd.registeredArguments.forEach((argument) => {
				argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
			});
			if (cmd.registeredArguments.find((argument) => argument.description)) return cmd.registeredArguments;
			return [];
		}
		/**
		* Get the command term to show in the list of subcommands.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		subcommandTerm(cmd) {
			const args = cmd.registeredArguments.map((arg) => humanReadableArgName$1(arg)).join(" ");
			return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
		}
		/**
		* Get the option term to show in the list of options.
		*
		* @param {Option} option
		* @returns {string}
		*/
		optionTerm(option) {
			return option.flags;
		}
		/**
		* Get the argument term to show in the list of arguments.
		*
		* @param {Argument} argument
		* @returns {string}
		*/
		argumentTerm(argument) {
			return argument.name();
		}
		/**
		* Get the longest command term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestSubcommandTermLength(cmd, helper) {
			return helper.visibleCommands(cmd).reduce((max, command) => {
				return Math.max(max, this.displayWidth(helper.styleSubcommandTerm(helper.subcommandTerm(command))));
			}, 0);
		}
		/**
		* Get the longest option term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestOptionTermLength(cmd, helper) {
			return helper.visibleOptions(cmd).reduce((max, option) => {
				return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
			}, 0);
		}
		/**
		* Get the longest global option term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestGlobalOptionTermLength(cmd, helper) {
			return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
				return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
			}, 0);
		}
		/**
		* Get the longest argument term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestArgumentTermLength(cmd, helper) {
			return helper.visibleArguments(cmd).reduce((max, argument) => {
				return Math.max(max, this.displayWidth(helper.styleArgumentTerm(helper.argumentTerm(argument))));
			}, 0);
		}
		/**
		* Get the command usage to be displayed at the top of the built-in help.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		commandUsage(cmd) {
			let cmdName = cmd._name;
			if (cmd._aliases[0]) cmdName = cmdName + "|" + cmd._aliases[0];
			let ancestorCmdNames = "";
			for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
			return ancestorCmdNames + cmdName + " " + cmd.usage();
		}
		/**
		* Get the description for the command.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		commandDescription(cmd) {
			return cmd.description();
		}
		/**
		* Get the subcommand summary to show in the list of subcommands.
		* (Fallback to description for backwards compatibility.)
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		subcommandDescription(cmd) {
			return cmd.summary() || cmd.description();
		}
		/**
		* Get the option description to show in the list of options.
		*
		* @param {Option} option
		* @return {string}
		*/
		optionDescription(option) {
			const extraInfo = [];
			if (option.argChoices) extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
			if (option.defaultValue !== void 0) {
				if (option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean") extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
			}
			if (option.presetArg !== void 0 && option.optional) extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
			if (option.envVar !== void 0) extraInfo.push(`env: ${option.envVar}`);
			if (extraInfo.length > 0) return `${option.description} (${extraInfo.join(", ")})`;
			return option.description;
		}
		/**
		* Get the argument description to show in the list of arguments.
		*
		* @param {Argument} argument
		* @return {string}
		*/
		argumentDescription(argument) {
			const extraInfo = [];
			if (argument.argChoices) extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
			if (argument.defaultValue !== void 0) extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
			if (extraInfo.length > 0) {
				const extraDescription = `(${extraInfo.join(", ")})`;
				if (argument.description) return `${argument.description} ${extraDescription}`;
				return extraDescription;
			}
			return argument.description;
		}
		/**
		* Generate the built-in help text.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {string}
		*/
		formatHelp(cmd, helper) {
			const termWidth = helper.padWidth(cmd, helper);
			const helpWidth = helper.helpWidth ?? 80;
			function callFormatItem(term, description) {
				return helper.formatItem(term, termWidth, description, helper);
			}
			let output = [`${helper.styleTitle("Usage:")} ${helper.styleUsage(helper.commandUsage(cmd))}`, ""];
			const commandDescription = helper.commandDescription(cmd);
			if (commandDescription.length > 0) output = output.concat([helper.boxWrap(helper.styleCommandDescription(commandDescription), helpWidth), ""]);
			const argumentList = helper.visibleArguments(cmd).map((argument) => {
				return callFormatItem(helper.styleArgumentTerm(helper.argumentTerm(argument)), helper.styleArgumentDescription(helper.argumentDescription(argument)));
			});
			if (argumentList.length > 0) output = output.concat([
				helper.styleTitle("Arguments:"),
				...argumentList,
				""
			]);
			const optionList = helper.visibleOptions(cmd).map((option) => {
				return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
			});
			if (optionList.length > 0) output = output.concat([
				helper.styleTitle("Options:"),
				...optionList,
				""
			]);
			if (helper.showGlobalOptions) {
				const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
					return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
				});
				if (globalOptionList.length > 0) output = output.concat([
					helper.styleTitle("Global Options:"),
					...globalOptionList,
					""
				]);
			}
			const commandList = helper.visibleCommands(cmd).map((cmd$1) => {
				return callFormatItem(helper.styleSubcommandTerm(helper.subcommandTerm(cmd$1)), helper.styleSubcommandDescription(helper.subcommandDescription(cmd$1)));
			});
			if (commandList.length > 0) output = output.concat([
				helper.styleTitle("Commands:"),
				...commandList,
				""
			]);
			return output.join("\n");
		}
		/**
		* Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
		*
		* @param {string} str
		* @returns {number}
		*/
		displayWidth(str) {
			return stripColor$1(str).length;
		}
		/**
		* Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
		*
		* @param {string} str
		* @returns {string}
		*/
		styleTitle(str) {
			return str;
		}
		styleUsage(str) {
			return str.split(" ").map((word) => {
				if (word === "[options]") return this.styleOptionText(word);
				if (word === "[command]") return this.styleSubcommandText(word);
				if (word[0] === "[" || word[0] === "<") return this.styleArgumentText(word);
				return this.styleCommandText(word);
			}).join(" ");
		}
		styleCommandDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleOptionDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleSubcommandDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleArgumentDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleDescriptionText(str) {
			return str;
		}
		styleOptionTerm(str) {
			return this.styleOptionText(str);
		}
		styleSubcommandTerm(str) {
			return str.split(" ").map((word) => {
				if (word === "[options]") return this.styleOptionText(word);
				if (word[0] === "[" || word[0] === "<") return this.styleArgumentText(word);
				return this.styleSubcommandText(word);
			}).join(" ");
		}
		styleArgumentTerm(str) {
			return this.styleArgumentText(str);
		}
		styleOptionText(str) {
			return str;
		}
		styleArgumentText(str) {
			return str;
		}
		styleSubcommandText(str) {
			return str;
		}
		styleCommandText(str) {
			return str;
		}
		/**
		* Calculate the pad width from the maximum term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		padWidth(cmd, helper) {
			return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
		}
		/**
		* Detect manually wrapped and indented strings by checking for line break followed by whitespace.
		*
		* @param {string} str
		* @returns {boolean}
		*/
		preformatted(str) {
			return /\n[^\S\r\n]/.test(str);
		}
		/**
		* Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
		*
		* So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
		*   TTT  DDD DDDD
		*        DD DDD
		*
		* @param {string} term
		* @param {number} termWidth
		* @param {string} description
		* @param {Help} helper
		* @returns {string}
		*/
		formatItem(term, termWidth, description, helper) {
			const itemIndent = 2;
			const itemIndentStr = " ".repeat(itemIndent);
			if (!description) return itemIndentStr + term;
			const paddedTerm = term.padEnd(termWidth + term.length - helper.displayWidth(term));
			const spacerWidth = 2;
			const remainingWidth = (this.helpWidth ?? 80) - termWidth - spacerWidth - itemIndent;
			let formattedDescription;
			if (remainingWidth < this.minWidthToWrap || helper.preformatted(description)) formattedDescription = description;
			else formattedDescription = helper.boxWrap(description, remainingWidth).replace(/\n/g, "\n" + " ".repeat(termWidth + spacerWidth));
			return itemIndentStr + paddedTerm + " ".repeat(spacerWidth) + formattedDescription.replace(/\n/g, `\n${itemIndentStr}`);
		}
		/**
		* Wrap a string at whitespace, preserving existing line breaks.
		* Wrapping is skipped if the width is less than `minWidthToWrap`.
		*
		* @param {string} str
		* @param {number} width
		* @returns {string}
		*/
		boxWrap(str, width) {
			if (width < this.minWidthToWrap) return str;
			const rawLines = str.split(/\r\n|\n/);
			const chunkPattern = /[\s]*[^\s]+/g;
			const wrappedLines = [];
			rawLines.forEach((line) => {
				const chunks = line.match(chunkPattern);
				if (chunks === null) {
					wrappedLines.push("");
					return;
				}
				let sumChunks = [chunks.shift()];
				let sumWidth = this.displayWidth(sumChunks[0]);
				chunks.forEach((chunk) => {
					const visibleWidth = this.displayWidth(chunk);
					if (sumWidth + visibleWidth <= width) {
						sumChunks.push(chunk);
						sumWidth += visibleWidth;
						return;
					}
					wrappedLines.push(sumChunks.join(""));
					const nextChunk = chunk.trimStart();
					sumChunks = [nextChunk];
					sumWidth = this.displayWidth(nextChunk);
				});
				wrappedLines.push(sumChunks.join(""));
			});
			return wrappedLines.join("\n");
		}
	};
	/**
	* Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.
	*
	* @param {string} str
	* @returns {string}
	* @package
	*/
	function stripColor$1(str) {
		return str.replace(/\x1b\[\d*(;\d*)*m/g, "");
	}
	exports.Help = Help$3;
	exports.stripColor = stripColor$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/option.js
var require_option = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/option.js": ((exports) => {
	const { InvalidArgumentError: InvalidArgumentError$2 } = require_error();
	var Option$3 = class {
		/**
		* Initialize a new `Option` with the given `flags` and `description`.
		*
		* @param {string} flags
		* @param {string} [description]
		*/
		constructor(flags, description) {
			this.flags = flags;
			this.description = description || "";
			this.required = flags.includes("<");
			this.optional = flags.includes("[");
			this.variadic = /\w\.\.\.[>\]]$/.test(flags);
			this.mandatory = false;
			const optionFlags = splitOptionFlags(flags);
			this.short = optionFlags.shortFlag;
			this.long = optionFlags.longFlag;
			this.negate = false;
			if (this.long) this.negate = this.long.startsWith("--no-");
			this.defaultValue = void 0;
			this.defaultValueDescription = void 0;
			this.presetArg = void 0;
			this.envVar = void 0;
			this.parseArg = void 0;
			this.hidden = false;
			this.argChoices = void 0;
			this.conflictsWith = [];
			this.implied = void 0;
		}
		/**
		* Set the default value, and optionally supply the description to be displayed in the help.
		*
		* @param {*} value
		* @param {string} [description]
		* @return {Option}
		*/
		default(value, description) {
			this.defaultValue = value;
			this.defaultValueDescription = description;
			return this;
		}
		/**
		* Preset to use when option used without option-argument, especially optional but also boolean and negated.
		* The custom processing (parseArg) is called.
		*
		* @example
		* new Option('--color').default('GREYSCALE').preset('RGB');
		* new Option('--donate [amount]').preset('20').argParser(parseFloat);
		*
		* @param {*} arg
		* @return {Option}
		*/
		preset(arg) {
			this.presetArg = arg;
			return this;
		}
		/**
		* Add option name(s) that conflict with this option.
		* An error will be displayed if conflicting options are found during parsing.
		*
		* @example
		* new Option('--rgb').conflicts('cmyk');
		* new Option('--js').conflicts(['ts', 'jsx']);
		*
		* @param {(string | string[])} names
		* @return {Option}
		*/
		conflicts(names) {
			this.conflictsWith = this.conflictsWith.concat(names);
			return this;
		}
		/**
		* Specify implied option values for when this option is set and the implied options are not.
		*
		* The custom processing (parseArg) is not called on the implied values.
		*
		* @example
		* program
		*   .addOption(new Option('--log', 'write logging information to file'))
		*   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
		*
		* @param {object} impliedOptionValues
		* @return {Option}
		*/
		implies(impliedOptionValues) {
			let newImplied = impliedOptionValues;
			if (typeof impliedOptionValues === "string") newImplied = { [impliedOptionValues]: true };
			this.implied = Object.assign(this.implied || {}, newImplied);
			return this;
		}
		/**
		* Set environment variable to check for option value.
		*
		* An environment variable is only used if when processed the current option value is
		* undefined, or the source of the current value is 'default' or 'config' or 'env'.
		*
		* @param {string} name
		* @return {Option}
		*/
		env(name) {
			this.envVar = name;
			return this;
		}
		/**
		* Set the custom handler for processing CLI option arguments into option values.
		*
		* @param {Function} [fn]
		* @return {Option}
		*/
		argParser(fn) {
			this.parseArg = fn;
			return this;
		}
		/**
		* Whether the option is mandatory and must have a value after parsing.
		*
		* @param {boolean} [mandatory=true]
		* @return {Option}
		*/
		makeOptionMandatory(mandatory = true) {
			this.mandatory = !!mandatory;
			return this;
		}
		/**
		* Hide option in help.
		*
		* @param {boolean} [hide=true]
		* @return {Option}
		*/
		hideHelp(hide = true) {
			this.hidden = !!hide;
			return this;
		}
		/**
		* @package
		*/
		_concatValue(value, previous) {
			if (previous === this.defaultValue || !Array.isArray(previous)) return [value];
			return previous.concat(value);
		}
		/**
		* Only allow option value to be one of choices.
		*
		* @param {string[]} values
		* @return {Option}
		*/
		choices(values) {
			this.argChoices = values.slice();
			this.parseArg = (arg, previous) => {
				if (!this.argChoices.includes(arg)) throw new InvalidArgumentError$2(`Allowed choices are ${this.argChoices.join(", ")}.`);
				if (this.variadic) return this._concatValue(arg, previous);
				return arg;
			};
			return this;
		}
		/**
		* Return option name.
		*
		* @return {string}
		*/
		name() {
			if (this.long) return this.long.replace(/^--/, "");
			return this.short.replace(/^-/, "");
		}
		/**
		* Return option name, in a camelcase format that can be used
		* as an object attribute key.
		*
		* @return {string}
		*/
		attributeName() {
			if (this.negate) return camelcase(this.name().replace(/^no-/, ""));
			return camelcase(this.name());
		}
		/**
		* Check if `arg` matches the short or long flag.
		*
		* @param {string} arg
		* @return {boolean}
		* @package
		*/
		is(arg) {
			return this.short === arg || this.long === arg;
		}
		/**
		* Return whether a boolean option.
		*
		* Options are one of boolean, negated, required argument, or optional argument.
		*
		* @return {boolean}
		* @package
		*/
		isBoolean() {
			return !this.required && !this.optional && !this.negate;
		}
	};
	/**
	* This class is to make it easier to work with dual options, without changing the existing
	* implementation. We support separate dual options for separate positive and negative options,
	* like `--build` and `--no-build`, which share a single option value. This works nicely for some
	* use cases, but is tricky for others where we want separate behaviours despite
	* the single shared option value.
	*/
	var DualOptions$1 = class {
		/**
		* @param {Option[]} options
		*/
		constructor(options) {
			this.positiveOptions = /* @__PURE__ */ new Map();
			this.negativeOptions = /* @__PURE__ */ new Map();
			this.dualOptions = /* @__PURE__ */ new Set();
			options.forEach((option) => {
				if (option.negate) this.negativeOptions.set(option.attributeName(), option);
				else this.positiveOptions.set(option.attributeName(), option);
			});
			this.negativeOptions.forEach((value, key) => {
				if (this.positiveOptions.has(key)) this.dualOptions.add(key);
			});
		}
		/**
		* Did the value come from the option, and not from possible matching dual option?
		*
		* @param {*} value
		* @param {Option} option
		* @returns {boolean}
		*/
		valueFromOption(value, option) {
			const optionKey = option.attributeName();
			if (!this.dualOptions.has(optionKey)) return true;
			const preset = this.negativeOptions.get(optionKey).presetArg;
			const negativeValue = preset !== void 0 ? preset : false;
			return option.negate === (negativeValue === value);
		}
	};
	/**
	* Convert string from kebab-case to camelCase.
	*
	* @param {string} str
	* @return {string}
	* @private
	*/
	function camelcase(str) {
		return str.split("-").reduce((str$1, word) => {
			return str$1 + word[0].toUpperCase() + word.slice(1);
		});
	}
	/**
	* Split the short and long flag out of something like '-m,--mixed <value>'
	*
	* @private
	*/
	function splitOptionFlags(flags) {
		let shortFlag;
		let longFlag;
		const shortFlagExp = /^-[^-]$/;
		const longFlagExp = /^--[^-]/;
		const flagParts = flags.split(/[ |,]+/).concat("guard");
		if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
		if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();
		if (!shortFlag && shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
		if (!shortFlag && longFlagExp.test(flagParts[0])) {
			shortFlag = longFlag;
			longFlag = flagParts.shift();
		}
		if (flagParts[0].startsWith("-")) {
			const unsupportedFlag = flagParts[0];
			const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
			if (/^-[^-][^-]/.test(unsupportedFlag)) throw new Error(`${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);
			if (shortFlagExp.test(unsupportedFlag)) throw new Error(`${baseError}
- too many short flags`);
			if (longFlagExp.test(unsupportedFlag)) throw new Error(`${baseError}
- too many long flags`);
			throw new Error(`${baseError}
- unrecognised flag format`);
		}
		if (shortFlag === void 0 && longFlag === void 0) throw new Error(`option creation failed due to no flags found in '${flags}'.`);
		return {
			shortFlag,
			longFlag
		};
	}
	exports.Option = Option$3;
	exports.DualOptions = DualOptions$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/suggestSimilar.js": ((exports) => {
	const maxDistance = 3;
	function editDistance(a, b$1) {
		if (Math.abs(a.length - b$1.length) > maxDistance) return Math.max(a.length, b$1.length);
		const d$1 = [];
		for (let i$1 = 0; i$1 <= a.length; i$1++) d$1[i$1] = [i$1];
		for (let j$2 = 0; j$2 <= b$1.length; j$2++) d$1[0][j$2] = j$2;
		for (let j$2 = 1; j$2 <= b$1.length; j$2++) for (let i$1 = 1; i$1 <= a.length; i$1++) {
			let cost = 1;
			if (a[i$1 - 1] === b$1[j$2 - 1]) cost = 0;
			else cost = 1;
			d$1[i$1][j$2] = Math.min(d$1[i$1 - 1][j$2] + 1, d$1[i$1][j$2 - 1] + 1, d$1[i$1 - 1][j$2 - 1] + cost);
			if (i$1 > 1 && j$2 > 1 && a[i$1 - 1] === b$1[j$2 - 2] && a[i$1 - 2] === b$1[j$2 - 1]) d$1[i$1][j$2] = Math.min(d$1[i$1][j$2], d$1[i$1 - 2][j$2 - 2] + 1);
		}
		return d$1[a.length][b$1.length];
	}
	/**
	* Find close matches, restricted to same number of edits.
	*
	* @param {string} word
	* @param {string[]} candidates
	* @returns {string}
	*/
	function suggestSimilar$1(word, candidates) {
		if (!candidates || candidates.length === 0) return "";
		candidates = Array.from(new Set(candidates));
		const searchingOptions = word.startsWith("--");
		if (searchingOptions) {
			word = word.slice(2);
			candidates = candidates.map((candidate) => candidate.slice(2));
		}
		let similar = [];
		let bestDistance = maxDistance;
		const minSimilarity = .4;
		candidates.forEach((candidate) => {
			if (candidate.length <= 1) return;
			const distance = editDistance(word, candidate);
			const length = Math.max(word.length, candidate.length);
			if ((length - distance) / length > minSimilarity) {
				if (distance < bestDistance) {
					bestDistance = distance;
					similar = [candidate];
				} else if (distance === bestDistance) similar.push(candidate);
			}
		});
		similar.sort((a, b$1) => a.localeCompare(b$1));
		if (searchingOptions) similar = similar.map((candidate) => `--${candidate}`);
		if (similar.length > 1) return `\n(Did you mean one of ${similar.join(", ")}?)`;
		if (similar.length === 1) return `\n(Did you mean ${similar[0]}?)`;
		return "";
	}
	exports.suggestSimilar = suggestSimilar$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/command.js
var require_command = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/command.js": ((exports) => {
	const EventEmitter = __require("node:events").EventEmitter;
	const childProcess = __require("node:child_process");
	const path$1 = __require("node:path");
	const fs$1 = __require("node:fs");
	const process$2 = __require("node:process");
	const { Argument: Argument$2, humanReadableArgName } = require_argument();
	const { CommanderError: CommanderError$2 } = require_error();
	const { Help: Help$2, stripColor } = require_help();
	const { Option: Option$2, DualOptions } = require_option();
	const { suggestSimilar } = require_suggestSimilar();
	var Command$2 = class Command$2 extends EventEmitter {
		/**
		* Initialize a new `Command`.
		*
		* @param {string} [name]
		*/
		constructor(name) {
			super();
			/** @type {Command[]} */
			this.commands = [];
			/** @type {Option[]} */
			this.options = [];
			this.parent = null;
			this._allowUnknownOption = false;
			this._allowExcessArguments = false;
			/** @type {Argument[]} */
			this.registeredArguments = [];
			this._args = this.registeredArguments;
			/** @type {string[]} */
			this.args = [];
			this.rawArgs = [];
			this.processedArgs = [];
			this._scriptPath = null;
			this._name = name || "";
			this._optionValues = {};
			this._optionValueSources = {};
			this._storeOptionsAsProperties = false;
			this._actionHandler = null;
			this._executableHandler = false;
			this._executableFile = null;
			this._executableDir = null;
			this._defaultCommandName = null;
			this._exitCallback = null;
			this._aliases = [];
			this._combineFlagAndOptionalValue = true;
			this._description = "";
			this._summary = "";
			this._argsDescription = void 0;
			this._enablePositionalOptions = false;
			this._passThroughOptions = false;
			this._lifeCycleHooks = {};
			/** @type {(boolean | string)} */
			this._showHelpAfterError = false;
			this._showSuggestionAfterError = true;
			this._savedState = null;
			this._outputConfiguration = {
				writeOut: (str) => process$2.stdout.write(str),
				writeErr: (str) => process$2.stderr.write(str),
				outputError: (str, write) => write(str),
				getOutHelpWidth: () => process$2.stdout.isTTY ? process$2.stdout.columns : void 0,
				getErrHelpWidth: () => process$2.stderr.isTTY ? process$2.stderr.columns : void 0,
				getOutHasColors: () => useColor() ?? (process$2.stdout.isTTY && process$2.stdout.hasColors?.()),
				getErrHasColors: () => useColor() ?? (process$2.stderr.isTTY && process$2.stderr.hasColors?.()),
				stripColor: (str) => stripColor(str)
			};
			this._hidden = false;
			/** @type {(Option | null | undefined)} */
			this._helpOption = void 0;
			this._addImplicitHelpCommand = void 0;
			/** @type {Command} */
			this._helpCommand = void 0;
			this._helpConfiguration = {};
		}
		/**
		* Copy settings that are useful to have in common across root command and subcommands.
		*
		* (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
		*
		* @param {Command} sourceCommand
		* @return {Command} `this` command for chaining
		*/
		copyInheritedSettings(sourceCommand) {
			this._outputConfiguration = sourceCommand._outputConfiguration;
			this._helpOption = sourceCommand._helpOption;
			this._helpCommand = sourceCommand._helpCommand;
			this._helpConfiguration = sourceCommand._helpConfiguration;
			this._exitCallback = sourceCommand._exitCallback;
			this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
			this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
			this._allowExcessArguments = sourceCommand._allowExcessArguments;
			this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
			this._showHelpAfterError = sourceCommand._showHelpAfterError;
			this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
			return this;
		}
		/**
		* @returns {Command[]}
		* @private
		*/
		_getCommandAndAncestors() {
			const result = [];
			for (let command = this; command; command = command.parent) result.push(command);
			return result;
		}
		/**
		* Define a command.
		*
		* There are two styles of command: pay attention to where to put the description.
		*
		* @example
		* // Command implemented using action handler (description is supplied separately to `.command`)
		* program
		*   .command('clone <source> [destination]')
		*   .description('clone a repository into a newly created directory')
		*   .action((source, destination) => {
		*     console.log('clone command called');
		*   });
		*
		* // Command implemented using separate executable file (description is second parameter to `.command`)
		* program
		*   .command('start <service>', 'start named service')
		*   .command('stop [service]', 'stop named service, or all if no name supplied');
		*
		* @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
		* @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
		* @param {object} [execOpts] - configuration options (for executable)
		* @return {Command} returns new command for action handler, or `this` for executable command
		*/
		command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
			let desc = actionOptsOrExecDesc;
			let opts = execOpts;
			if (typeof desc === "object" && desc !== null) {
				opts = desc;
				desc = null;
			}
			opts = opts || {};
			const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
			const cmd = this.createCommand(name);
			if (desc) {
				cmd.description(desc);
				cmd._executableHandler = true;
			}
			if (opts.isDefault) this._defaultCommandName = cmd._name;
			cmd._hidden = !!(opts.noHelp || opts.hidden);
			cmd._executableFile = opts.executableFile || null;
			if (args) cmd.arguments(args);
			this._registerCommand(cmd);
			cmd.parent = this;
			cmd.copyInheritedSettings(this);
			if (desc) return this;
			return cmd;
		}
		/**
		* Factory routine to create a new unattached command.
		*
		* See .command() for creating an attached subcommand, which uses this routine to
		* create the command. You can override createCommand to customise subcommands.
		*
		* @param {string} [name]
		* @return {Command} new command
		*/
		createCommand(name) {
			return new Command$2(name);
		}
		/**
		* You can customise the help with a subclass of Help by overriding createHelp,
		* or by overriding Help properties using configureHelp().
		*
		* @return {Help}
		*/
		createHelp() {
			return Object.assign(new Help$2(), this.configureHelp());
		}
		/**
		* You can customise the help by overriding Help properties using configureHelp(),
		* or with a subclass of Help by overriding createHelp().
		*
		* @param {object} [configuration] - configuration options
		* @return {(Command | object)} `this` command for chaining, or stored configuration
		*/
		configureHelp(configuration) {
			if (configuration === void 0) return this._helpConfiguration;
			this._helpConfiguration = configuration;
			return this;
		}
		/**
		* The default output goes to stdout and stderr. You can customise this for special
		* applications. You can also customise the display of errors by overriding outputError.
		*
		* The configuration properties are all functions:
		*
		*     // change how output being written, defaults to stdout and stderr
		*     writeOut(str)
		*     writeErr(str)
		*     // change how output being written for errors, defaults to writeErr
		*     outputError(str, write) // used for displaying errors and not used for displaying help
		*     // specify width for wrapping help
		*     getOutHelpWidth()
		*     getErrHelpWidth()
		*     // color support, currently only used with Help
		*     getOutHasColors()
		*     getErrHasColors()
		*     stripColor() // used to remove ANSI escape codes if output does not have colors
		*
		* @param {object} [configuration] - configuration options
		* @return {(Command | object)} `this` command for chaining, or stored configuration
		*/
		configureOutput(configuration) {
			if (configuration === void 0) return this._outputConfiguration;
			Object.assign(this._outputConfiguration, configuration);
			return this;
		}
		/**
		* Display the help or a custom message after an error occurs.
		*
		* @param {(boolean|string)} [displayHelp]
		* @return {Command} `this` command for chaining
		*/
		showHelpAfterError(displayHelp = true) {
			if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
			this._showHelpAfterError = displayHelp;
			return this;
		}
		/**
		* Display suggestion of similar commands for unknown commands, or options for unknown options.
		*
		* @param {boolean} [displaySuggestion]
		* @return {Command} `this` command for chaining
		*/
		showSuggestionAfterError(displaySuggestion = true) {
			this._showSuggestionAfterError = !!displaySuggestion;
			return this;
		}
		/**
		* Add a prepared subcommand.
		*
		* See .command() for creating an attached subcommand which inherits settings from its parent.
		*
		* @param {Command} cmd - new subcommand
		* @param {object} [opts] - configuration options
		* @return {Command} `this` command for chaining
		*/
		addCommand(cmd, opts) {
			if (!cmd._name) throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
			opts = opts || {};
			if (opts.isDefault) this._defaultCommandName = cmd._name;
			if (opts.noHelp || opts.hidden) cmd._hidden = true;
			this._registerCommand(cmd);
			cmd.parent = this;
			cmd._checkForBrokenPassThrough();
			return this;
		}
		/**
		* Factory routine to create a new unattached argument.
		*
		* See .argument() for creating an attached argument, which uses this routine to
		* create the argument. You can override createArgument to return a custom argument.
		*
		* @param {string} name
		* @param {string} [description]
		* @return {Argument} new argument
		*/
		createArgument(name, description) {
			return new Argument$2(name, description);
		}
		/**
		* Define argument syntax for command.
		*
		* The default is that the argument is required, and you can explicitly
		* indicate this with <> around the name. Put [] around the name for an optional argument.
		*
		* @example
		* program.argument('<input-file>');
		* program.argument('[output-file]');
		*
		* @param {string} name
		* @param {string} [description]
		* @param {(Function|*)} [fn] - custom argument processing function
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		argument(name, description, fn, defaultValue) {
			const argument = this.createArgument(name, description);
			if (typeof fn === "function") argument.default(defaultValue).argParser(fn);
			else argument.default(fn);
			this.addArgument(argument);
			return this;
		}
		/**
		* Define argument syntax for command, adding multiple at once (without descriptions).
		*
		* See also .argument().
		*
		* @example
		* program.arguments('<cmd> [env]');
		*
		* @param {string} names
		* @return {Command} `this` command for chaining
		*/
		arguments(names) {
			names.trim().split(/ +/).forEach((detail) => {
				this.argument(detail);
			});
			return this;
		}
		/**
		* Define argument syntax for command, adding a prepared argument.
		*
		* @param {Argument} argument
		* @return {Command} `this` command for chaining
		*/
		addArgument(argument) {
			const previousArgument = this.registeredArguments.slice(-1)[0];
			if (previousArgument && previousArgument.variadic) throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
			if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
			this.registeredArguments.push(argument);
			return this;
		}
		/**
		* Customise or override default help command. By default a help command is automatically added if your command has subcommands.
		*
		* @example
		*    program.helpCommand('help [cmd]');
		*    program.helpCommand('help [cmd]', 'show help');
		*    program.helpCommand(false); // suppress default help command
		*    program.helpCommand(true); // add help command even if no subcommands
		*
		* @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
		* @param {string} [description] - custom description
		* @return {Command} `this` command for chaining
		*/
		helpCommand(enableOrNameAndArgs, description) {
			if (typeof enableOrNameAndArgs === "boolean") {
				this._addImplicitHelpCommand = enableOrNameAndArgs;
				return this;
			}
			enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
			const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
			const helpDescription = description ?? "display help for command";
			const helpCommand = this.createCommand(helpName);
			helpCommand.helpOption(false);
			if (helpArgs) helpCommand.arguments(helpArgs);
			if (helpDescription) helpCommand.description(helpDescription);
			this._addImplicitHelpCommand = true;
			this._helpCommand = helpCommand;
			return this;
		}
		/**
		* Add prepared custom help command.
		*
		* @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
		* @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
		* @return {Command} `this` command for chaining
		*/
		addHelpCommand(helpCommand, deprecatedDescription) {
			if (typeof helpCommand !== "object") {
				this.helpCommand(helpCommand, deprecatedDescription);
				return this;
			}
			this._addImplicitHelpCommand = true;
			this._helpCommand = helpCommand;
			return this;
		}
		/**
		* Lazy create help command.
		*
		* @return {(Command|null)}
		* @package
		*/
		_getHelpCommand() {
			if (this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"))) {
				if (this._helpCommand === void 0) this.helpCommand(void 0, void 0);
				return this._helpCommand;
			}
			return null;
		}
		/**
		* Add hook for life cycle event.
		*
		* @param {string} event
		* @param {Function} listener
		* @return {Command} `this` command for chaining
		*/
		hook(event, listener) {
			const allowedValues = [
				"preSubcommand",
				"preAction",
				"postAction"
			];
			if (!allowedValues.includes(event)) throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
			if (this._lifeCycleHooks[event]) this._lifeCycleHooks[event].push(listener);
			else this._lifeCycleHooks[event] = [listener];
			return this;
		}
		/**
		* Register callback to use as replacement for calling process.exit.
		*
		* @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
		* @return {Command} `this` command for chaining
		*/
		exitOverride(fn) {
			if (fn) this._exitCallback = fn;
			else this._exitCallback = (err) => {
				if (err.code !== "commander.executeSubCommandAsync") throw err;
			};
			return this;
		}
		/**
		* Call process.exit, and _exitCallback if defined.
		*
		* @param {number} exitCode exit code for using with process.exit
		* @param {string} code an id string representing the error
		* @param {string} message human-readable description of the error
		* @return never
		* @private
		*/
		_exit(exitCode, code, message) {
			if (this._exitCallback) this._exitCallback(new CommanderError$2(exitCode, code, message));
			process$2.exit(exitCode);
		}
		/**
		* Register callback `fn` for the command.
		*
		* @example
		* program
		*   .command('serve')
		*   .description('start service')
		*   .action(function() {
		*      // do work here
		*   });
		*
		* @param {Function} fn
		* @return {Command} `this` command for chaining
		*/
		action(fn) {
			const listener = (args) => {
				const expectedArgsCount = this.registeredArguments.length;
				const actionArgs = args.slice(0, expectedArgsCount);
				if (this._storeOptionsAsProperties) actionArgs[expectedArgsCount] = this;
				else actionArgs[expectedArgsCount] = this.opts();
				actionArgs.push(this);
				return fn.apply(this, actionArgs);
			};
			this._actionHandler = listener;
			return this;
		}
		/**
		* Factory routine to create a new unattached option.
		*
		* See .option() for creating an attached option, which uses this routine to
		* create the option. You can override createOption to return a custom option.
		*
		* @param {string} flags
		* @param {string} [description]
		* @return {Option} new option
		*/
		createOption(flags, description) {
			return new Option$2(flags, description);
		}
		/**
		* Wrap parseArgs to catch 'commander.invalidArgument'.
		*
		* @param {(Option | Argument)} target
		* @param {string} value
		* @param {*} previous
		* @param {string} invalidArgumentMessage
		* @private
		*/
		_callParseArg(target, value, previous, invalidArgumentMessage) {
			try {
				return target.parseArg(value, previous);
			} catch (err) {
				if (err.code === "commander.invalidArgument") {
					const message = `${invalidArgumentMessage} ${err.message}`;
					this.error(message, {
						exitCode: err.exitCode,
						code: err.code
					});
				}
				throw err;
			}
		}
		/**
		* Check for option flag conflicts.
		* Register option if no conflicts found, or throw on conflict.
		*
		* @param {Option} option
		* @private
		*/
		_registerOption(option) {
			const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
			if (matchingOption) {
				const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
				throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
			}
			this.options.push(option);
		}
		/**
		* Check for command name and alias conflicts with existing commands.
		* Register command if no conflicts found, or throw on conflict.
		*
		* @param {Command} command
		* @private
		*/
		_registerCommand(command) {
			const knownBy = (cmd) => {
				return [cmd.name()].concat(cmd.aliases());
			};
			const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
			if (alreadyUsed) {
				const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
				const newCmd = knownBy(command).join("|");
				throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
			}
			this.commands.push(command);
		}
		/**
		* Add an option.
		*
		* @param {Option} option
		* @return {Command} `this` command for chaining
		*/
		addOption(option) {
			this._registerOption(option);
			const oname = option.name();
			const name = option.attributeName();
			if (option.negate) {
				const positiveLongFlag = option.long.replace(/^--no-/, "--");
				if (!this._findOption(positiveLongFlag)) this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
			} else if (option.defaultValue !== void 0) this.setOptionValueWithSource(name, option.defaultValue, "default");
			const handleOptionValue = (val, invalidValueMessage, valueSource) => {
				if (val == null && option.presetArg !== void 0) val = option.presetArg;
				const oldValue = this.getOptionValue(name);
				if (val !== null && option.parseArg) val = this._callParseArg(option, val, oldValue, invalidValueMessage);
				else if (val !== null && option.variadic) val = option._concatValue(val, oldValue);
				if (val == null) if (option.negate) val = false;
				else if (option.isBoolean() || option.optional) val = true;
				else val = "";
				this.setOptionValueWithSource(name, val, valueSource);
			};
			this.on("option:" + oname, (val) => {
				const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
				handleOptionValue(val, invalidValueMessage, "cli");
			});
			if (option.envVar) this.on("optionEnv:" + oname, (val) => {
				const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
				handleOptionValue(val, invalidValueMessage, "env");
			});
			return this;
		}
		/**
		* Internal implementation shared by .option() and .requiredOption()
		*
		* @return {Command} `this` command for chaining
		* @private
		*/
		_optionEx(config, flags, description, fn, defaultValue) {
			if (typeof flags === "object" && flags instanceof Option$2) throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
			const option = this.createOption(flags, description);
			option.makeOptionMandatory(!!config.mandatory);
			if (typeof fn === "function") option.default(defaultValue).argParser(fn);
			else if (fn instanceof RegExp) {
				const regex = fn;
				fn = (val, def) => {
					const m$1 = regex.exec(val);
					return m$1 ? m$1[0] : def;
				};
				option.default(defaultValue).argParser(fn);
			} else option.default(fn);
			return this.addOption(option);
		}
		/**
		* Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
		*
		* The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
		* option-argument is indicated by `<>` and an optional option-argument by `[]`.
		*
		* See the README for more details, and see also addOption() and requiredOption().
		*
		* @example
		* program
		*     .option('-p, --pepper', 'add pepper')
		*     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument
		*     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
		*     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
		*
		* @param {string} flags
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom option processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		option(flags, description, parseArg, defaultValue) {
			return this._optionEx({}, flags, description, parseArg, defaultValue);
		}
		/**
		* Add a required option which must have a value after parsing. This usually means
		* the option must be specified on the command line. (Otherwise the same as .option().)
		*
		* The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
		*
		* @param {string} flags
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom option processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		requiredOption(flags, description, parseArg, defaultValue) {
			return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
		}
		/**
		* Alter parsing of short flags with optional values.
		*
		* @example
		* // for `.option('-f,--flag [value]'):
		* program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
		* program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
		*
		* @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
		* @return {Command} `this` command for chaining
		*/
		combineFlagAndOptionalValue(combine = true) {
			this._combineFlagAndOptionalValue = !!combine;
			return this;
		}
		/**
		* Allow unknown options on the command line.
		*
		* @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
		* @return {Command} `this` command for chaining
		*/
		allowUnknownOption(allowUnknown = true) {
			this._allowUnknownOption = !!allowUnknown;
			return this;
		}
		/**
		* Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
		*
		* @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
		* @return {Command} `this` command for chaining
		*/
		allowExcessArguments(allowExcess = true) {
			this._allowExcessArguments = !!allowExcess;
			return this;
		}
		/**
		* Enable positional options. Positional means global options are specified before subcommands which lets
		* subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
		* The default behaviour is non-positional and global options may appear anywhere on the command line.
		*
		* @param {boolean} [positional]
		* @return {Command} `this` command for chaining
		*/
		enablePositionalOptions(positional = true) {
			this._enablePositionalOptions = !!positional;
			return this;
		}
		/**
		* Pass through options that come after command-arguments rather than treat them as command-options,
		* so actual command-options come before command-arguments. Turning this on for a subcommand requires
		* positional options to have been enabled on the program (parent commands).
		* The default behaviour is non-positional and options may appear before or after command-arguments.
		*
		* @param {boolean} [passThrough] for unknown options.
		* @return {Command} `this` command for chaining
		*/
		passThroughOptions(passThrough = true) {
			this._passThroughOptions = !!passThrough;
			this._checkForBrokenPassThrough();
			return this;
		}
		/**
		* @private
		*/
		_checkForBrokenPassThrough() {
			if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
		}
		/**
		* Whether to store option values as properties on command object,
		* or store separately (specify false). In both cases the option values can be accessed using .opts().
		*
		* @param {boolean} [storeAsProperties=true]
		* @return {Command} `this` command for chaining
		*/
		storeOptionsAsProperties(storeAsProperties = true) {
			if (this.options.length) throw new Error("call .storeOptionsAsProperties() before adding options");
			if (Object.keys(this._optionValues).length) throw new Error("call .storeOptionsAsProperties() before setting option values");
			this._storeOptionsAsProperties = !!storeAsProperties;
			return this;
		}
		/**
		* Retrieve option value.
		*
		* @param {string} key
		* @return {object} value
		*/
		getOptionValue(key) {
			if (this._storeOptionsAsProperties) return this[key];
			return this._optionValues[key];
		}
		/**
		* Store option value.
		*
		* @param {string} key
		* @param {object} value
		* @return {Command} `this` command for chaining
		*/
		setOptionValue(key, value) {
			return this.setOptionValueWithSource(key, value, void 0);
		}
		/**
		* Store option value and where the value came from.
		*
		* @param {string} key
		* @param {object} value
		* @param {string} source - expected values are default/config/env/cli/implied
		* @return {Command} `this` command for chaining
		*/
		setOptionValueWithSource(key, value, source) {
			if (this._storeOptionsAsProperties) this[key] = value;
			else this._optionValues[key] = value;
			this._optionValueSources[key] = source;
			return this;
		}
		/**
		* Get source of option value.
		* Expected values are default | config | env | cli | implied
		*
		* @param {string} key
		* @return {string}
		*/
		getOptionValueSource(key) {
			return this._optionValueSources[key];
		}
		/**
		* Get source of option value. See also .optsWithGlobals().
		* Expected values are default | config | env | cli | implied
		*
		* @param {string} key
		* @return {string}
		*/
		getOptionValueSourceWithGlobals(key) {
			let source;
			this._getCommandAndAncestors().forEach((cmd) => {
				if (cmd.getOptionValueSource(key) !== void 0) source = cmd.getOptionValueSource(key);
			});
			return source;
		}
		/**
		* Get user arguments from implied or explicit arguments.
		* Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
		*
		* @private
		*/
		_prepareUserArgs(argv$1, parseOptions$1) {
			if (argv$1 !== void 0 && !Array.isArray(argv$1)) throw new Error("first parameter to parse must be array or undefined");
			parseOptions$1 = parseOptions$1 || {};
			if (argv$1 === void 0 && parseOptions$1.from === void 0) {
				if (process$2.versions?.electron) parseOptions$1.from = "electron";
				const execArgv = process$2.execArgv ?? [];
				if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) parseOptions$1.from = "eval";
			}
			if (argv$1 === void 0) argv$1 = process$2.argv;
			this.rawArgs = argv$1.slice();
			let userArgs;
			switch (parseOptions$1.from) {
				case void 0:
				case "node":
					this._scriptPath = argv$1[1];
					userArgs = argv$1.slice(2);
					break;
				case "electron":
					if (process$2.defaultApp) {
						this._scriptPath = argv$1[1];
						userArgs = argv$1.slice(2);
					} else userArgs = argv$1.slice(1);
					break;
				case "user":
					userArgs = argv$1.slice(0);
					break;
				case "eval":
					userArgs = argv$1.slice(1);
					break;
				default: throw new Error(`unexpected parse option { from: '${parseOptions$1.from}' }`);
			}
			if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
			this._name = this._name || "program";
			return userArgs;
		}
		/**
		* Parse `argv`, setting options and invoking commands when defined.
		*
		* Use parseAsync instead of parse if any of your action handlers are async.
		*
		* Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
		*
		* Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
		* - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
		* - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
		* - `'user'`: just user arguments
		*
		* @example
		* program.parse(); // parse process.argv and auto-detect electron and special node flags
		* program.parse(process.argv); // assume argv[0] is app and argv[1] is script
		* program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
		*
		* @param {string[]} [argv] - optional, defaults to process.argv
		* @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
		* @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
		* @return {Command} `this` command for chaining
		*/
		parse(argv$1, parseOptions$1) {
			this._prepareForParse();
			const userArgs = this._prepareUserArgs(argv$1, parseOptions$1);
			this._parseCommand([], userArgs);
			return this;
		}
		/**
		* Parse `argv`, setting options and invoking commands when defined.
		*
		* Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
		*
		* Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
		* - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
		* - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
		* - `'user'`: just user arguments
		*
		* @example
		* await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
		* await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
		* await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
		*
		* @param {string[]} [argv]
		* @param {object} [parseOptions]
		* @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
		* @return {Promise}
		*/
		async parseAsync(argv$1, parseOptions$1) {
			this._prepareForParse();
			const userArgs = this._prepareUserArgs(argv$1, parseOptions$1);
			await this._parseCommand([], userArgs);
			return this;
		}
		_prepareForParse() {
			if (this._savedState === null) this.saveStateBeforeParse();
			else this.restoreStateBeforeParse();
		}
		/**
		* Called the first time parse is called to save state and allow a restore before subsequent calls to parse.
		* Not usually called directly, but available for subclasses to save their custom state.
		*
		* This is called in a lazy way. Only commands used in parsing chain will have state saved.
		*/
		saveStateBeforeParse() {
			this._savedState = {
				_name: this._name,
				_optionValues: { ...this._optionValues },
				_optionValueSources: { ...this._optionValueSources }
			};
		}
		/**
		* Restore state before parse for calls after the first.
		* Not usually called directly, but available for subclasses to save their custom state.
		*
		* This is called in a lazy way. Only commands used in parsing chain will have state restored.
		*/
		restoreStateBeforeParse() {
			if (this._storeOptionsAsProperties) throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);
			this._name = this._savedState._name;
			this._scriptPath = null;
			this.rawArgs = [];
			this._optionValues = { ...this._savedState._optionValues };
			this._optionValueSources = { ...this._savedState._optionValueSources };
			this.args = [];
			this.processedArgs = [];
		}
		/**
		* Throw if expected executable is missing. Add lots of help for author.
		*
		* @param {string} executableFile
		* @param {string} executableDir
		* @param {string} subcommandName
		*/
		_checkForMissingExecutable(executableFile, executableDir, subcommandName) {
			if (fs$1.existsSync(executableFile)) return;
			const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
			const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
			throw new Error(executableMissing);
		}
		/**
		* Execute a sub-command executable.
		*
		* @private
		*/
		_executeSubCommand(subcommand, args) {
			args = args.slice();
			let launchWithNode = false;
			const sourceExt = [
				".js",
				".ts",
				".tsx",
				".mjs",
				".cjs"
			];
			function findFile(baseDir, baseName) {
				const localBin = path$1.resolve(baseDir, baseName);
				if (fs$1.existsSync(localBin)) return localBin;
				if (sourceExt.includes(path$1.extname(baseName))) return void 0;
				const foundExt = sourceExt.find((ext) => fs$1.existsSync(`${localBin}${ext}`));
				if (foundExt) return `${localBin}${foundExt}`;
			}
			this._checkForMissingMandatoryOptions();
			this._checkForConflictingOptions();
			let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
			let executableDir = this._executableDir || "";
			if (this._scriptPath) {
				let resolvedScriptPath;
				try {
					resolvedScriptPath = fs$1.realpathSync(this._scriptPath);
				} catch {
					resolvedScriptPath = this._scriptPath;
				}
				executableDir = path$1.resolve(path$1.dirname(resolvedScriptPath), executableDir);
			}
			if (executableDir) {
				let localFile = findFile(executableDir, executableFile);
				if (!localFile && !subcommand._executableFile && this._scriptPath) {
					const legacyName = path$1.basename(this._scriptPath, path$1.extname(this._scriptPath));
					if (legacyName !== this._name) localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
				}
				executableFile = localFile || executableFile;
			}
			launchWithNode = sourceExt.includes(path$1.extname(executableFile));
			let proc;
			if (process$2.platform !== "win32") if (launchWithNode) {
				args.unshift(executableFile);
				args = incrementNodeInspectorPort(process$2.execArgv).concat(args);
				proc = childProcess.spawn(process$2.argv[0], args, { stdio: "inherit" });
			} else proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
			else {
				this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
				args.unshift(executableFile);
				args = incrementNodeInspectorPort(process$2.execArgv).concat(args);
				proc = childProcess.spawn(process$2.execPath, args, { stdio: "inherit" });
			}
			if (!proc.killed) [
				"SIGUSR1",
				"SIGUSR2",
				"SIGTERM",
				"SIGINT",
				"SIGHUP"
			].forEach((signal) => {
				process$2.on(signal, () => {
					if (proc.killed === false && proc.exitCode === null) proc.kill(signal);
				});
			});
			const exitCallback = this._exitCallback;
			proc.on("close", (code) => {
				code = code ?? 1;
				if (!exitCallback) process$2.exit(code);
				else exitCallback(new CommanderError$2(code, "commander.executeSubCommandAsync", "(close)"));
			});
			proc.on("error", (err) => {
				if (err.code === "ENOENT") this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
				else if (err.code === "EACCES") throw new Error(`'${executableFile}' not executable`);
				if (!exitCallback) process$2.exit(1);
				else {
					const wrappedError = new CommanderError$2(1, "commander.executeSubCommandAsync", "(error)");
					wrappedError.nestedError = err;
					exitCallback(wrappedError);
				}
			});
			this.runningCommand = proc;
		}
		/**
		* @private
		*/
		_dispatchSubcommand(commandName, operands, unknown) {
			const subCommand = this._findCommand(commandName);
			if (!subCommand) this.help({ error: true });
			subCommand._prepareForParse();
			let promiseChain;
			promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
			promiseChain = this._chainOrCall(promiseChain, () => {
				if (subCommand._executableHandler) this._executeSubCommand(subCommand, operands.concat(unknown));
				else return subCommand._parseCommand(operands, unknown);
			});
			return promiseChain;
		}
		/**
		* Invoke help directly if possible, or dispatch if necessary.
		* e.g. help foo
		*
		* @private
		*/
		_dispatchHelpCommand(subcommandName) {
			if (!subcommandName) this.help();
			const subCommand = this._findCommand(subcommandName);
			if (subCommand && !subCommand._executableHandler) subCommand.help();
			return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]);
		}
		/**
		* Check this.args against expected this.registeredArguments.
		*
		* @private
		*/
		_checkNumberOfArguments() {
			this.registeredArguments.forEach((arg, i$1) => {
				if (arg.required && this.args[i$1] == null) this.missingArgument(arg.name());
			});
			if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) return;
			if (this.args.length > this.registeredArguments.length) this._excessArguments(this.args);
		}
		/**
		* Process this.args using this.registeredArguments and save as this.processedArgs!
		*
		* @private
		*/
		_processArguments() {
			const myParseArg = (argument, value, previous) => {
				let parsedValue = value;
				if (value !== null && argument.parseArg) {
					const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
					parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
				}
				return parsedValue;
			};
			this._checkNumberOfArguments();
			const processedArgs = [];
			this.registeredArguments.forEach((declaredArg, index) => {
				let value = declaredArg.defaultValue;
				if (declaredArg.variadic) {
					if (index < this.args.length) {
						value = this.args.slice(index);
						if (declaredArg.parseArg) value = value.reduce((processed, v$2) => {
							return myParseArg(declaredArg, v$2, processed);
						}, declaredArg.defaultValue);
					} else if (value === void 0) value = [];
				} else if (index < this.args.length) {
					value = this.args[index];
					if (declaredArg.parseArg) value = myParseArg(declaredArg, value, declaredArg.defaultValue);
				}
				processedArgs[index] = value;
			});
			this.processedArgs = processedArgs;
		}
		/**
		* Once we have a promise we chain, but call synchronously until then.
		*
		* @param {(Promise|undefined)} promise
		* @param {Function} fn
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCall(promise, fn) {
			if (promise && promise.then && typeof promise.then === "function") return promise.then(() => fn());
			return fn();
		}
		/**
		*
		* @param {(Promise|undefined)} promise
		* @param {string} event
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCallHooks(promise, event) {
			let result = promise;
			const hooks = [];
			this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
				hookedCommand._lifeCycleHooks[event].forEach((callback) => {
					hooks.push({
						hookedCommand,
						callback
					});
				});
			});
			if (event === "postAction") hooks.reverse();
			hooks.forEach((hookDetail) => {
				result = this._chainOrCall(result, () => {
					return hookDetail.callback(hookDetail.hookedCommand, this);
				});
			});
			return result;
		}
		/**
		*
		* @param {(Promise|undefined)} promise
		* @param {Command} subCommand
		* @param {string} event
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCallSubCommandHook(promise, subCommand, event) {
			let result = promise;
			if (this._lifeCycleHooks[event] !== void 0) this._lifeCycleHooks[event].forEach((hook) => {
				result = this._chainOrCall(result, () => {
					return hook(this, subCommand);
				});
			});
			return result;
		}
		/**
		* Process arguments in context of this command.
		* Returns action result, in case it is a promise.
		*
		* @private
		*/
		_parseCommand(operands, unknown) {
			const parsed = this.parseOptions(unknown);
			this._parseOptionsEnv();
			this._parseOptionsImplied();
			operands = operands.concat(parsed.operands);
			unknown = parsed.unknown;
			this.args = operands.concat(unknown);
			if (operands && this._findCommand(operands[0])) return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
			if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) return this._dispatchHelpCommand(operands[1]);
			if (this._defaultCommandName) {
				this._outputHelpIfRequested(unknown);
				return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
			}
			if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) this.help({ error: true });
			this._outputHelpIfRequested(parsed.unknown);
			this._checkForMissingMandatoryOptions();
			this._checkForConflictingOptions();
			const checkForUnknownOptions = () => {
				if (parsed.unknown.length > 0) this.unknownOption(parsed.unknown[0]);
			};
			const commandEvent = `command:${this.name()}`;
			if (this._actionHandler) {
				checkForUnknownOptions();
				this._processArguments();
				let promiseChain;
				promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
				promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
				if (this.parent) promiseChain = this._chainOrCall(promiseChain, () => {
					this.parent.emit(commandEvent, operands, unknown);
				});
				promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
				return promiseChain;
			}
			if (this.parent && this.parent.listenerCount(commandEvent)) {
				checkForUnknownOptions();
				this._processArguments();
				this.parent.emit(commandEvent, operands, unknown);
			} else if (operands.length) {
				if (this._findCommand("*")) return this._dispatchSubcommand("*", operands, unknown);
				if (this.listenerCount("command:*")) this.emit("command:*", operands, unknown);
				else if (this.commands.length) this.unknownCommand();
				else {
					checkForUnknownOptions();
					this._processArguments();
				}
			} else if (this.commands.length) {
				checkForUnknownOptions();
				this.help({ error: true });
			} else {
				checkForUnknownOptions();
				this._processArguments();
			}
		}
		/**
		* Find matching command.
		*
		* @private
		* @return {Command | undefined}
		*/
		_findCommand(name) {
			if (!name) return void 0;
			return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
		}
		/**
		* Return an option matching `arg` if any.
		*
		* @param {string} arg
		* @return {Option}
		* @package
		*/
		_findOption(arg) {
			return this.options.find((option) => option.is(arg));
		}
		/**
		* Display an error message if a mandatory option does not have a value.
		* Called after checking for help flags in leaf subcommand.
		*
		* @private
		*/
		_checkForMissingMandatoryOptions() {
			this._getCommandAndAncestors().forEach((cmd) => {
				cmd.options.forEach((anOption) => {
					if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) cmd.missingMandatoryOptionValue(anOption);
				});
			});
		}
		/**
		* Display an error message if conflicting options are used together in this.
		*
		* @private
		*/
		_checkForConflictingLocalOptions() {
			const definedNonDefaultOptions = this.options.filter((option) => {
				const optionKey = option.attributeName();
				if (this.getOptionValue(optionKey) === void 0) return false;
				return this.getOptionValueSource(optionKey) !== "default";
			});
			definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0).forEach((option) => {
				const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
				if (conflictingAndDefined) this._conflictingOption(option, conflictingAndDefined);
			});
		}
		/**
		* Display an error message if conflicting options are used together.
		* Called after checking for help flags in leaf subcommand.
		*
		* @private
		*/
		_checkForConflictingOptions() {
			this._getCommandAndAncestors().forEach((cmd) => {
				cmd._checkForConflictingLocalOptions();
			});
		}
		/**
		* Parse options from `argv` removing known options,
		* and return argv split into operands and unknown arguments.
		*
		* Side effects: modifies command by storing options. Does not reset state if called again.
		*
		* Examples:
		*
		*     argv => operands, unknown
		*     --known kkk op => [op], []
		*     op --known kkk => [op], []
		*     sub --unknown uuu op => [sub], [--unknown uuu op]
		*     sub -- --unknown uuu op => [sub --unknown uuu op], []
		*
		* @param {string[]} argv
		* @return {{operands: string[], unknown: string[]}}
		*/
		parseOptions(argv$1) {
			const operands = [];
			const unknown = [];
			let dest = operands;
			const args = argv$1.slice();
			function maybeOption(arg) {
				return arg.length > 1 && arg[0] === "-";
			}
			let activeVariadicOption = null;
			while (args.length) {
				const arg = args.shift();
				if (arg === "--") {
					if (dest === unknown) dest.push(arg);
					dest.push(...args);
					break;
				}
				if (activeVariadicOption && !maybeOption(arg)) {
					this.emit(`option:${activeVariadicOption.name()}`, arg);
					continue;
				}
				activeVariadicOption = null;
				if (maybeOption(arg)) {
					const option = this._findOption(arg);
					if (option) {
						if (option.required) {
							const value = args.shift();
							if (value === void 0) this.optionMissingArgument(option);
							this.emit(`option:${option.name()}`, value);
						} else if (option.optional) {
							let value = null;
							if (args.length > 0 && !maybeOption(args[0])) value = args.shift();
							this.emit(`option:${option.name()}`, value);
						} else this.emit(`option:${option.name()}`);
						activeVariadicOption = option.variadic ? option : null;
						continue;
					}
				}
				if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
					const option = this._findOption(`-${arg[1]}`);
					if (option) {
						if (option.required || option.optional && this._combineFlagAndOptionalValue) this.emit(`option:${option.name()}`, arg.slice(2));
						else {
							this.emit(`option:${option.name()}`);
							args.unshift(`-${arg.slice(2)}`);
						}
						continue;
					}
				}
				if (/^--[^=]+=/.test(arg)) {
					const index = arg.indexOf("=");
					const option = this._findOption(arg.slice(0, index));
					if (option && (option.required || option.optional)) {
						this.emit(`option:${option.name()}`, arg.slice(index + 1));
						continue;
					}
				}
				if (maybeOption(arg)) dest = unknown;
				if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
					if (this._findCommand(arg)) {
						operands.push(arg);
						if (args.length > 0) unknown.push(...args);
						break;
					} else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
						operands.push(arg);
						if (args.length > 0) operands.push(...args);
						break;
					} else if (this._defaultCommandName) {
						unknown.push(arg);
						if (args.length > 0) unknown.push(...args);
						break;
					}
				}
				if (this._passThroughOptions) {
					dest.push(arg);
					if (args.length > 0) dest.push(...args);
					break;
				}
				dest.push(arg);
			}
			return {
				operands,
				unknown
			};
		}
		/**
		* Return an object containing local option values as key-value pairs.
		*
		* @return {object}
		*/
		opts() {
			if (this._storeOptionsAsProperties) {
				const result = {};
				const len = this.options.length;
				for (let i$1 = 0; i$1 < len; i$1++) {
					const key = this.options[i$1].attributeName();
					result[key] = key === this._versionOptionName ? this._version : this[key];
				}
				return result;
			}
			return this._optionValues;
		}
		/**
		* Return an object containing merged local and global option values as key-value pairs.
		*
		* @return {object}
		*/
		optsWithGlobals() {
			return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
		}
		/**
		* Display error message and exit (or call exitOverride).
		*
		* @param {string} message
		* @param {object} [errorOptions]
		* @param {string} [errorOptions.code] - an id string representing the error
		* @param {number} [errorOptions.exitCode] - used with process.exit
		*/
		error(message, errorOptions) {
			this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
			if (typeof this._showHelpAfterError === "string") this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
			else if (this._showHelpAfterError) {
				this._outputConfiguration.writeErr("\n");
				this.outputHelp({ error: true });
			}
			const config = errorOptions || {};
			const exitCode = config.exitCode || 1;
			const code = config.code || "commander.error";
			this._exit(exitCode, code, message);
		}
		/**
		* Apply any option related environment variables, if option does
		* not have a value from cli or client code.
		*
		* @private
		*/
		_parseOptionsEnv() {
			this.options.forEach((option) => {
				if (option.envVar && option.envVar in process$2.env) {
					const optionKey = option.attributeName();
					if (this.getOptionValue(optionKey) === void 0 || [
						"default",
						"config",
						"env"
					].includes(this.getOptionValueSource(optionKey))) if (option.required || option.optional) this.emit(`optionEnv:${option.name()}`, process$2.env[option.envVar]);
					else this.emit(`optionEnv:${option.name()}`);
				}
			});
		}
		/**
		* Apply any implied option values, if option is undefined or default value.
		*
		* @private
		*/
		_parseOptionsImplied() {
			const dualHelper = new DualOptions(this.options);
			const hasCustomOptionValue = (optionKey) => {
				return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
			};
			this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
				Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
					this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
				});
			});
		}
		/**
		* Argument `name` is missing.
		*
		* @param {string} name
		* @private
		*/
		missingArgument(name) {
			const message = `error: missing required argument '${name}'`;
			this.error(message, { code: "commander.missingArgument" });
		}
		/**
		* `Option` is missing an argument.
		*
		* @param {Option} option
		* @private
		*/
		optionMissingArgument(option) {
			const message = `error: option '${option.flags}' argument missing`;
			this.error(message, { code: "commander.optionMissingArgument" });
		}
		/**
		* `Option` does not have a value, and is a mandatory option.
		*
		* @param {Option} option
		* @private
		*/
		missingMandatoryOptionValue(option) {
			const message = `error: required option '${option.flags}' not specified`;
			this.error(message, { code: "commander.missingMandatoryOptionValue" });
		}
		/**
		* `Option` conflicts with another option.
		*
		* @param {Option} option
		* @param {Option} conflictingOption
		* @private
		*/
		_conflictingOption(option, conflictingOption) {
			const findBestOptionFromValue = (option$1) => {
				const optionKey = option$1.attributeName();
				const optionValue = this.getOptionValue(optionKey);
				const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
				const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
				if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) return negativeOption;
				return positiveOption || option$1;
			};
			const getErrorMessage = (option$1) => {
				const bestOption = findBestOptionFromValue(option$1);
				const optionKey = bestOption.attributeName();
				if (this.getOptionValueSource(optionKey) === "env") return `environment variable '${bestOption.envVar}'`;
				return `option '${bestOption.flags}'`;
			};
			const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
			this.error(message, { code: "commander.conflictingOption" });
		}
		/**
		* Unknown option `flag`.
		*
		* @param {string} flag
		* @private
		*/
		unknownOption(flag) {
			if (this._allowUnknownOption) return;
			let suggestion = "";
			if (flag.startsWith("--") && this._showSuggestionAfterError) {
				let candidateFlags = [];
				let command = this;
				do {
					const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
					candidateFlags = candidateFlags.concat(moreFlags);
					command = command.parent;
				} while (command && !command._enablePositionalOptions);
				suggestion = suggestSimilar(flag, candidateFlags);
			}
			const message = `error: unknown option '${flag}'${suggestion}`;
			this.error(message, { code: "commander.unknownOption" });
		}
		/**
		* Excess arguments, more than expected.
		*
		* @param {string[]} receivedArgs
		* @private
		*/
		_excessArguments(receivedArgs) {
			if (this._allowExcessArguments) return;
			const expected = this.registeredArguments.length;
			const s = expected === 1 ? "" : "s";
			const message = `error: too many arguments${this.parent ? ` for '${this.name()}'` : ""}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
			this.error(message, { code: "commander.excessArguments" });
		}
		/**
		* Unknown command.
		*
		* @private
		*/
		unknownCommand() {
			const unknownName = this.args[0];
			let suggestion = "";
			if (this._showSuggestionAfterError) {
				const candidateNames = [];
				this.createHelp().visibleCommands(this).forEach((command) => {
					candidateNames.push(command.name());
					if (command.alias()) candidateNames.push(command.alias());
				});
				suggestion = suggestSimilar(unknownName, candidateNames);
			}
			const message = `error: unknown command '${unknownName}'${suggestion}`;
			this.error(message, { code: "commander.unknownCommand" });
		}
		/**
		* Get or set the program version.
		*
		* This method auto-registers the "-V, --version" option which will print the version number.
		*
		* You can optionally supply the flags and description to override the defaults.
		*
		* @param {string} [str]
		* @param {string} [flags]
		* @param {string} [description]
		* @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
		*/
		version(str, flags, description) {
			if (str === void 0) return this._version;
			this._version = str;
			flags = flags || "-V, --version";
			description = description || "output the version number";
			const versionOption = this.createOption(flags, description);
			this._versionOptionName = versionOption.attributeName();
			this._registerOption(versionOption);
			this.on("option:" + versionOption.name(), () => {
				this._outputConfiguration.writeOut(`${str}\n`);
				this._exit(0, "commander.version", str);
			});
			return this;
		}
		/**
		* Set the description.
		*
		* @param {string} [str]
		* @param {object} [argsDescription]
		* @return {(string|Command)}
		*/
		description(str, argsDescription) {
			if (str === void 0 && argsDescription === void 0) return this._description;
			this._description = str;
			if (argsDescription) this._argsDescription = argsDescription;
			return this;
		}
		/**
		* Set the summary. Used when listed as subcommand of parent.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		summary(str) {
			if (str === void 0) return this._summary;
			this._summary = str;
			return this;
		}
		/**
		* Set an alias for the command.
		*
		* You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
		*
		* @param {string} [alias]
		* @return {(string|Command)}
		*/
		alias(alias) {
			if (alias === void 0) return this._aliases[0];
			/** @type {Command} */
			let command = this;
			if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) command = this.commands[this.commands.length - 1];
			if (alias === command._name) throw new Error("Command alias can't be the same as its name");
			const matchingCommand = this.parent?._findCommand(alias);
			if (matchingCommand) {
				const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
				throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
			}
			command._aliases.push(alias);
			return this;
		}
		/**
		* Set aliases for the command.
		*
		* Only the first alias is shown in the auto-generated help.
		*
		* @param {string[]} [aliases]
		* @return {(string[]|Command)}
		*/
		aliases(aliases) {
			if (aliases === void 0) return this._aliases;
			aliases.forEach((alias) => this.alias(alias));
			return this;
		}
		/**
		* Set / get the command usage `str`.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		usage(str) {
			if (str === void 0) {
				if (this._usage) return this._usage;
				const args = this.registeredArguments.map((arg) => {
					return humanReadableArgName(arg);
				});
				return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
			}
			this._usage = str;
			return this;
		}
		/**
		* Get or set the name of the command.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		name(str) {
			if (str === void 0) return this._name;
			this._name = str;
			return this;
		}
		/**
		* Set the name of the command from script filename, such as process.argv[1],
		* or require.main.filename, or __filename.
		*
		* (Used internally and public although not documented in README.)
		*
		* @example
		* program.nameFromFilename(require.main.filename);
		*
		* @param {string} filename
		* @return {Command}
		*/
		nameFromFilename(filename) {
			this._name = path$1.basename(filename, path$1.extname(filename));
			return this;
		}
		/**
		* Get or set the directory for searching for executable subcommands of this command.
		*
		* @example
		* program.executableDir(__dirname);
		* // or
		* program.executableDir('subcommands');
		*
		* @param {string} [path]
		* @return {(string|null|Command)}
		*/
		executableDir(path$2) {
			if (path$2 === void 0) return this._executableDir;
			this._executableDir = path$2;
			return this;
		}
		/**
		* Return program help documentation.
		*
		* @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
		* @return {string}
		*/
		helpInformation(contextOptions) {
			const helper = this.createHelp();
			const context = this._getOutputContext(contextOptions);
			helper.prepareContext({
				error: context.error,
				helpWidth: context.helpWidth,
				outputHasColors: context.hasColors
			});
			const text = helper.formatHelp(this, helper);
			if (context.hasColors) return text;
			return this._outputConfiguration.stripColor(text);
		}
		/**
		* @typedef HelpContext
		* @type {object}
		* @property {boolean} error
		* @property {number} helpWidth
		* @property {boolean} hasColors
		* @property {function} write - includes stripColor if needed
		*
		* @returns {HelpContext}
		* @private
		*/
		_getOutputContext(contextOptions) {
			contextOptions = contextOptions || {};
			const error = !!contextOptions.error;
			let baseWrite;
			let hasColors;
			let helpWidth;
			if (error) {
				baseWrite = (str) => this._outputConfiguration.writeErr(str);
				hasColors = this._outputConfiguration.getErrHasColors();
				helpWidth = this._outputConfiguration.getErrHelpWidth();
			} else {
				baseWrite = (str) => this._outputConfiguration.writeOut(str);
				hasColors = this._outputConfiguration.getOutHasColors();
				helpWidth = this._outputConfiguration.getOutHelpWidth();
			}
			const write = (str) => {
				if (!hasColors) str = this._outputConfiguration.stripColor(str);
				return baseWrite(str);
			};
			return {
				error,
				write,
				hasColors,
				helpWidth
			};
		}
		/**
		* Output help information for this command.
		*
		* Outputs built-in help, and custom text added using `.addHelpText()`.
		*
		* @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
		*/
		outputHelp(contextOptions) {
			let deprecatedCallback;
			if (typeof contextOptions === "function") {
				deprecatedCallback = contextOptions;
				contextOptions = void 0;
			}
			const outputContext = this._getOutputContext(contextOptions);
			/** @type {HelpTextEventContext} */
			const eventContext = {
				error: outputContext.error,
				write: outputContext.write,
				command: this
			};
			this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", eventContext));
			this.emit("beforeHelp", eventContext);
			let helpInformation = this.helpInformation({ error: outputContext.error });
			if (deprecatedCallback) {
				helpInformation = deprecatedCallback(helpInformation);
				if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) throw new Error("outputHelp callback must return a string or a Buffer");
			}
			outputContext.write(helpInformation);
			if (this._getHelpOption()?.long) this.emit(this._getHelpOption().long);
			this.emit("afterHelp", eventContext);
			this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", eventContext));
		}
		/**
		* You can pass in flags and a description to customise the built-in help option.
		* Pass in false to disable the built-in help option.
		*
		* @example
		* program.helpOption('-?, --help' 'show help'); // customise
		* program.helpOption(false); // disable
		*
		* @param {(string | boolean)} flags
		* @param {string} [description]
		* @return {Command} `this` command for chaining
		*/
		helpOption(flags, description) {
			if (typeof flags === "boolean") {
				// istanbul ignore if
				if (flags) this._helpOption = this._helpOption ?? void 0;
				else this._helpOption = null;
				return this;
			}
			flags = flags ?? "-h, --help";
			description = description ?? "display help for command";
			this._helpOption = this.createOption(flags, description);
			return this;
		}
		/**
		* Lazy create help option.
		* Returns null if has been disabled with .helpOption(false).
		*
		* @returns {(Option | null)} the help option
		* @package
		*/
		_getHelpOption() {
			if (this._helpOption === void 0) this.helpOption(void 0, void 0);
			return this._helpOption;
		}
		/**
		* Supply your own option to use for the built-in help option.
		* This is an alternative to using helpOption() to customise the flags and description etc.
		*
		* @param {Option} option
		* @return {Command} `this` command for chaining
		*/
		addHelpOption(option) {
			this._helpOption = option;
			return this;
		}
		/**
		* Output help information and exit.
		*
		* Outputs built-in help, and custom text added using `.addHelpText()`.
		*
		* @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
		*/
		help(contextOptions) {
			this.outputHelp(contextOptions);
			let exitCode = Number(process$2.exitCode ?? 0);
			if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) exitCode = 1;
			this._exit(exitCode, "commander.help", "(outputHelp)");
		}
		/**
		* // Do a little typing to coordinate emit and listener for the help text events.
		* @typedef HelpTextEventContext
		* @type {object}
		* @property {boolean} error
		* @property {Command} command
		* @property {function} write
		*/
		/**
		* Add additional text to be displayed with the built-in help.
		*
		* Position is 'before' or 'after' to affect just this command,
		* and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
		*
		* @param {string} position - before or after built-in help
		* @param {(string | Function)} text - string to add, or a function returning a string
		* @return {Command} `this` command for chaining
		*/
		addHelpText(position, text) {
			const allowedValues = [
				"beforeAll",
				"before",
				"after",
				"afterAll"
			];
			if (!allowedValues.includes(position)) throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
			const helpEvent = `${position}Help`;
			this.on(helpEvent, (context) => {
				let helpStr;
				if (typeof text === "function") helpStr = text({
					error: context.error,
					command: context.command
				});
				else helpStr = text;
				if (helpStr) context.write(`${helpStr}\n`);
			});
			return this;
		}
		/**
		* Output help information if help flags specified
		*
		* @param {Array} args - array of options to search for help flags
		* @private
		*/
		_outputHelpIfRequested(args) {
			const helpOption = this._getHelpOption();
			if (helpOption && args.find((arg) => helpOption.is(arg))) {
				this.outputHelp();
				this._exit(0, "commander.helpDisplayed", "(outputHelp)");
			}
		}
	};
	/**
	* Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
	*
	* @param {string[]} args - array of arguments from node.execArgv
	* @returns {string[]}
	* @private
	*/
	function incrementNodeInspectorPort(args) {
		return args.map((arg) => {
			if (!arg.startsWith("--inspect")) return arg;
			let debugOption;
			let debugHost = "127.0.0.1";
			let debugPort = "9229";
			let match;
			if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) debugOption = match[1];
			else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
				debugOption = match[1];
				if (/^\d+$/.test(match[3])) debugPort = match[3];
				else debugHost = match[3];
			} else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
				debugOption = match[1];
				debugHost = match[3];
				debugPort = match[4];
			}
			if (debugOption && debugPort !== "0") return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
			return arg;
		});
	}
	/**
	* @returns {boolean | undefined}
	* @package
	*/
	function useColor() {
		if (process$2.env.NO_COLOR || process$2.env.FORCE_COLOR === "0" || process$2.env.FORCE_COLOR === "false") return false;
		if (process$2.env.FORCE_COLOR || process$2.env.CLICOLOR_FORCE !== void 0) return true;
	}
	exports.Command = Command$2;
	exports.useColor = useColor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/index.js
var require_commander = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/index.js": ((exports) => {
	const { Argument: Argument$1 } = require_argument();
	const { Command: Command$1 } = require_command();
	const { CommanderError: CommanderError$1, InvalidArgumentError: InvalidArgumentError$1 } = require_error();
	const { Help: Help$1 } = require_help();
	const { Option: Option$1 } = require_option();
	exports.program = new Command$1();
	exports.createCommand = (name) => new Command$1(name);
	exports.createOption = (flags, description) => new Option$1(flags, description);
	exports.createArgument = (name, description) => new Argument$1(name, description);
	/**
	* Expose classes
	*/
	exports.Command = Command$1;
	exports.Option = Option$1;
	exports.Argument = Argument$1;
	exports.Help = Help$1;
	exports.CommanderError = CommanderError$1;
	exports.InvalidArgumentError = InvalidArgumentError$1;
	exports.InvalidOptionArgumentError = InvalidArgumentError$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/commander@13.1.0/node_modules/commander/esm.mjs
var import_commander = /* @__PURE__ */ __toESM(require_commander(), 1);
const { program, createCommand, createArgument, createOption, CommanderError, InvalidArgumentError, InvalidOptionArgumentError, Command, Argument, Option, Help } = import_commander.default;

//#endregion
//#region ../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js
var require_picocolors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js": ((exports, module) => {
	let p$1 = process || {}, argv = p$1.argv || [], env = p$1.env || {};
	let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p$1.platform === "win32" || (p$1.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
	let formatter = (open, close, replace = open) => (input) => {
		let string$5 = "" + input, index = string$5.indexOf(close, open.length);
		return ~index ? open + replaceClose(string$5, close, replace, index) + close : open + string$5 + close;
	};
	let replaceClose = (string$5, close, replace, index) => {
		let result = "", cursor$1 = 0;
		do {
			result += string$5.substring(cursor$1, index) + replace;
			cursor$1 = index + close.length;
			index = string$5.indexOf(close, cursor$1);
		} while (~index);
		return result + string$5.substring(cursor$1);
	};
	let createColors = (enabled = isColorSupported) => {
		let f$2 = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f$2("\x1B[0m", "\x1B[0m"),
			bold: f$2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f$2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f$2("\x1B[3m", "\x1B[23m"),
			underline: f$2("\x1B[4m", "\x1B[24m"),
			inverse: f$2("\x1B[7m", "\x1B[27m"),
			hidden: f$2("\x1B[8m", "\x1B[28m"),
			strikethrough: f$2("\x1B[9m", "\x1B[29m"),
			black: f$2("\x1B[30m", "\x1B[39m"),
			red: f$2("\x1B[31m", "\x1B[39m"),
			green: f$2("\x1B[32m", "\x1B[39m"),
			yellow: f$2("\x1B[33m", "\x1B[39m"),
			blue: f$2("\x1B[34m", "\x1B[39m"),
			magenta: f$2("\x1B[35m", "\x1B[39m"),
			cyan: f$2("\x1B[36m", "\x1B[39m"),
			white: f$2("\x1B[37m", "\x1B[39m"),
			gray: f$2("\x1B[90m", "\x1B[39m"),
			bgBlack: f$2("\x1B[40m", "\x1B[49m"),
			bgRed: f$2("\x1B[41m", "\x1B[49m"),
			bgGreen: f$2("\x1B[42m", "\x1B[49m"),
			bgYellow: f$2("\x1B[43m", "\x1B[49m"),
			bgBlue: f$2("\x1B[44m", "\x1B[49m"),
			bgMagenta: f$2("\x1B[45m", "\x1B[49m"),
			bgCyan: f$2("\x1B[46m", "\x1B[49m"),
			bgWhite: f$2("\x1B[47m", "\x1B[49m"),
			blackBright: f$2("\x1B[90m", "\x1B[39m"),
			redBright: f$2("\x1B[91m", "\x1B[39m"),
			greenBright: f$2("\x1B[92m", "\x1B[39m"),
			yellowBright: f$2("\x1B[93m", "\x1B[39m"),
			blueBright: f$2("\x1B[94m", "\x1B[39m"),
			magentaBright: f$2("\x1B[95m", "\x1B[39m"),
			cyanBright: f$2("\x1B[96m", "\x1B[39m"),
			whiteBright: f$2("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f$2("\x1B[100m", "\x1B[49m"),
			bgRedBright: f$2("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f$2("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f$2("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f$2("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f$2("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f$2("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f$2("\x1B[107m", "\x1B[49m")
		};
	};
	module.exports = createColors();
	module.exports.createColors = createColors;
}) });

//#endregion
//#region ../../node_modules/.pnpm/empathic@1.1.0/node_modules/empathic/resolve.mjs
/**
* Resolve an absolute path from {@link root}, but only
* if {@link input} isn't already absolute.
*
* @param input The path to resolve.
* @param root The base path; default = process.cwd()
* @returns The resolved absolute path.
*/
function absolute(input, root$1) {
	return isAbsolute(input) ? input : resolve(root$1 || ".", input);
}
function from(root$1, ident, silent) {
	try {
		let r = root$1 instanceof URL || root$1.startsWith("file://") ? join(fileURLToPath(root$1), "noop.js") : join(absolute(root$1), "noop.js");
		return createRequire(r).resolve(ident);
	} catch (err) {
		if (!silent) throw err;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/empathic@1.1.0/node_modules/empathic/walk.mjs
/**
* Get all parent directories of {@link base}.
* Stops at {@link Options['stop']} else system root ("/").
*
* @returns An array of absolute paths of all parent directories.
*/
function up$1(base, options) {
	let { stop, cwd: cwd$1 } = options || {};
	let tmp = absolute(base, cwd$1), root$1 = !stop;
	let prev, arr = [];
	if (stop) stop = absolute(stop, cwd$1);
	while (root$1 || tmp !== stop) {
		arr.push(tmp);
		tmp = dirname(prev = tmp);
		if (tmp === prev) break;
	}
	return arr;
}

//#endregion
//#region ../../node_modules/.pnpm/empathic@1.1.0/node_modules/empathic/find.mjs
/**
* Find an item by name, walking parent directories until found.
*
* @param name The item name to find.
* @returns The absolute path to the item, if found.
*/
function up(name, options) {
	let dir, tmp;
	let start = options && options.cwd || "";
	for (dir of up$1(start, options)) {
		tmp = join(dir, name);
		if (existsSync(tmp)) return tmp;
	}
}
/**
* Get the first path that matches any of the names provided.
*
* > [NOTE]
* > The order of {@link names} is respected.
*
* @param names The item names to find.
* @returns The absolute path of the first item found, if any.
*/
function any(names, options) {
	let dir, start = options && options.cwd || "";
	let j$2 = 0, len = names.length, tmp;
	for (dir of up$1(start, options)) for (j$2 = 0; j$2 < len; j$2++) {
		tmp = join(dir, names[j$2]);
		if (existsSync(tmp)) return tmp;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js
var require_src = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js": ((exports, module) => {
	const ESC = "\x1B";
	const CSI = `${ESC}[`;
	const beep = "\x07";
	const cursor = {
		to(x$3, y) {
			if (!y) return `${CSI}${x$3 + 1}G`;
			return `${CSI}${y + 1};${x$3 + 1}H`;
		},
		move(x$3, y) {
			let ret = "";
			if (x$3 < 0) ret += `${CSI}${-x$3}D`;
			else if (x$3 > 0) ret += `${CSI}${x$3}C`;
			if (y < 0) ret += `${CSI}${-y}A`;
			else if (y > 0) ret += `${CSI}${y}B`;
			return ret;
		},
		up: (count = 1) => `${CSI}${count}A`,
		down: (count = 1) => `${CSI}${count}B`,
		forward: (count = 1) => `${CSI}${count}C`,
		backward: (count = 1) => `${CSI}${count}D`,
		nextLine: (count = 1) => `${CSI}E`.repeat(count),
		prevLine: (count = 1) => `${CSI}F`.repeat(count),
		left: `${CSI}G`,
		hide: `${CSI}?25l`,
		show: `${CSI}?25h`,
		save: `${ESC}7`,
		restore: `${ESC}8`
	};
	const scroll = {
		up: (count = 1) => `${CSI}S`.repeat(count),
		down: (count = 1) => `${CSI}T`.repeat(count)
	};
	const erase = {
		screen: `${CSI}2J`,
		up: (count = 1) => `${CSI}1J`.repeat(count),
		down: (count = 1) => `${CSI}J`.repeat(count),
		line: `${CSI}2K`,
		lineEnd: `${CSI}K`,
		lineStart: `${CSI}1K`,
		lines(count) {
			let clear = "";
			for (let i$1 = 0; i$1 < count; i$1++) clear += this.line + (i$1 < count - 1 ? cursor.up() : "");
			if (count) clear += cursor.left;
			return clear;
		}
	};
	module.exports = {
		cursor,
		scroll,
		erase,
		beep
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/@clack+core@1.0.0-alpha.1/node_modules/@clack/core/dist/index.mjs
var import_src$1 = /* @__PURE__ */ __toESM(require_src(), 1);
var import_picocolors$3 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function hu({ onlyFirst: e$1 = !1 } = {}) {
	const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
	return new RegExp(t, e$1 ? void 0 : "g");
}
const cu = hu();
function Y(e$1) {
	if (typeof e$1 != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e$1}\``);
	return e$1.replace(cu, "");
}
function Z(e$1) {
	return e$1 && e$1.__esModule && Object.prototype.hasOwnProperty.call(e$1, "default") ? e$1.default : e$1;
}
var q$2 = { exports: {} };
(function(e$1) {
	var D$1 = {};
	e$1.exports = D$1, D$1.eastAsianWidth = function(s) {
		var i$1 = s.charCodeAt(0), F$1 = s.length == 2 ? s.charCodeAt(1) : 0, u = i$1;
		return 55296 <= i$1 && i$1 <= 56319 && 56320 <= F$1 && F$1 <= 57343 && (i$1 &= 1023, F$1 &= 1023, u = i$1 << 10 | F$1, u += 65536), u == 12288 || 65281 <= u && u <= 65376 || 65504 <= u && u <= 65510 ? "F" : u == 8361 || 65377 <= u && u <= 65470 || 65474 <= u && u <= 65479 || 65482 <= u && u <= 65487 || 65490 <= u && u <= 65495 || 65498 <= u && u <= 65500 || 65512 <= u && u <= 65518 ? "H" : 4352 <= u && u <= 4447 || 4515 <= u && u <= 4519 || 4602 <= u && u <= 4607 || 9001 <= u && u <= 9002 || 11904 <= u && u <= 11929 || 11931 <= u && u <= 12019 || 12032 <= u && u <= 12245 || 12272 <= u && u <= 12283 || 12289 <= u && u <= 12350 || 12353 <= u && u <= 12438 || 12441 <= u && u <= 12543 || 12549 <= u && u <= 12589 || 12593 <= u && u <= 12686 || 12688 <= u && u <= 12730 || 12736 <= u && u <= 12771 || 12784 <= u && u <= 12830 || 12832 <= u && u <= 12871 || 12880 <= u && u <= 13054 || 13056 <= u && u <= 19903 || 19968 <= u && u <= 42124 || 42128 <= u && u <= 42182 || 43360 <= u && u <= 43388 || 44032 <= u && u <= 55203 || 55216 <= u && u <= 55238 || 55243 <= u && u <= 55291 || 63744 <= u && u <= 64255 || 65040 <= u && u <= 65049 || 65072 <= u && u <= 65106 || 65108 <= u && u <= 65126 || 65128 <= u && u <= 65131 || 110592 <= u && u <= 110593 || 127488 <= u && u <= 127490 || 127504 <= u && u <= 127546 || 127552 <= u && u <= 127560 || 127568 <= u && u <= 127569 || 131072 <= u && u <= 194367 || 177984 <= u && u <= 196605 || 196608 <= u && u <= 262141 ? "W" : 32 <= u && u <= 126 || 162 <= u && u <= 163 || 165 <= u && u <= 166 || u == 172 || u == 175 || 10214 <= u && u <= 10221 || 10629 <= u && u <= 10630 ? "Na" : u == 161 || u == 164 || 167 <= u && u <= 168 || u == 170 || 173 <= u && u <= 174 || 176 <= u && u <= 180 || 182 <= u && u <= 186 || 188 <= u && u <= 191 || u == 198 || u == 208 || 215 <= u && u <= 216 || 222 <= u && u <= 225 || u == 230 || 232 <= u && u <= 234 || 236 <= u && u <= 237 || u == 240 || 242 <= u && u <= 243 || 247 <= u && u <= 250 || u == 252 || u == 254 || u == 257 || u == 273 || u == 275 || u == 283 || 294 <= u && u <= 295 || u == 299 || 305 <= u && u <= 307 || u == 312 || 319 <= u && u <= 322 || u == 324 || 328 <= u && u <= 331 || u == 333 || 338 <= u && u <= 339 || 358 <= u && u <= 359 || u == 363 || u == 462 || u == 464 || u == 466 || u == 468 || u == 470 || u == 472 || u == 474 || u == 476 || u == 593 || u == 609 || u == 708 || u == 711 || 713 <= u && u <= 715 || u == 717 || u == 720 || 728 <= u && u <= 731 || u == 733 || u == 735 || 768 <= u && u <= 879 || 913 <= u && u <= 929 || 931 <= u && u <= 937 || 945 <= u && u <= 961 || 963 <= u && u <= 969 || u == 1025 || 1040 <= u && u <= 1103 || u == 1105 || u == 8208 || 8211 <= u && u <= 8214 || 8216 <= u && u <= 8217 || 8220 <= u && u <= 8221 || 8224 <= u && u <= 8226 || 8228 <= u && u <= 8231 || u == 8240 || 8242 <= u && u <= 8243 || u == 8245 || u == 8251 || u == 8254 || u == 8308 || u == 8319 || 8321 <= u && u <= 8324 || u == 8364 || u == 8451 || u == 8453 || u == 8457 || u == 8467 || u == 8470 || 8481 <= u && u <= 8482 || u == 8486 || u == 8491 || 8531 <= u && u <= 8532 || 8539 <= u && u <= 8542 || 8544 <= u && u <= 8555 || 8560 <= u && u <= 8569 || u == 8585 || 8592 <= u && u <= 8601 || 8632 <= u && u <= 8633 || u == 8658 || u == 8660 || u == 8679 || u == 8704 || 8706 <= u && u <= 8707 || 8711 <= u && u <= 8712 || u == 8715 || u == 8719 || u == 8721 || u == 8725 || u == 8730 || 8733 <= u && u <= 8736 || u == 8739 || u == 8741 || 8743 <= u && u <= 8748 || u == 8750 || 8756 <= u && u <= 8759 || 8764 <= u && u <= 8765 || u == 8776 || u == 8780 || u == 8786 || 8800 <= u && u <= 8801 || 8804 <= u && u <= 8807 || 8810 <= u && u <= 8811 || 8814 <= u && u <= 8815 || 8834 <= u && u <= 8835 || 8838 <= u && u <= 8839 || u == 8853 || u == 8857 || u == 8869 || u == 8895 || u == 8978 || 9312 <= u && u <= 9449 || 9451 <= u && u <= 9547 || 9552 <= u && u <= 9587 || 9600 <= u && u <= 9615 || 9618 <= u && u <= 9621 || 9632 <= u && u <= 9633 || 9635 <= u && u <= 9641 || 9650 <= u && u <= 9651 || 9654 <= u && u <= 9655 || 9660 <= u && u <= 9661 || 9664 <= u && u <= 9665 || 9670 <= u && u <= 9672 || u == 9675 || 9678 <= u && u <= 9681 || 9698 <= u && u <= 9701 || u == 9711 || 9733 <= u && u <= 9734 || u == 9737 || 9742 <= u && u <= 9743 || 9748 <= u && u <= 9749 || u == 9756 || u == 9758 || u == 9792 || u == 9794 || 9824 <= u && u <= 9825 || 9827 <= u && u <= 9829 || 9831 <= u && u <= 9834 || 9836 <= u && u <= 9837 || u == 9839 || 9886 <= u && u <= 9887 || 9918 <= u && u <= 9919 || 9924 <= u && u <= 9933 || 9935 <= u && u <= 9953 || u == 9955 || 9960 <= u && u <= 9983 || u == 10045 || u == 10071 || 10102 <= u && u <= 10111 || 11093 <= u && u <= 11097 || 12872 <= u && u <= 12879 || 57344 <= u && u <= 63743 || 65024 <= u && u <= 65039 || u == 65533 || 127232 <= u && u <= 127242 || 127248 <= u && u <= 127277 || 127280 <= u && u <= 127337 || 127344 <= u && u <= 127386 || 917760 <= u && u <= 917999 || 983040 <= u && u <= 1048573 || 1048576 <= u && u <= 1114109 ? "A" : "N";
	}, D$1.characterLength = function(s) {
		var i$1 = this.eastAsianWidth(s);
		return i$1 == "F" || i$1 == "W" || i$1 == "A" ? 2 : 1;
	};
	function t(s) {
		return s.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
	}
	D$1.length = function(s) {
		for (var i$1 = t(s), F$1 = 0, u = 0; u < i$1.length; u++) F$1 = F$1 + this.characterLength(i$1[u]);
		return F$1;
	}, D$1.slice = function(s, i$1, F$1) {
		textLen = D$1.length(s), i$1 = i$1 || 0, F$1 = F$1 || 1, i$1 < 0 && (i$1 = textLen + i$1), F$1 < 0 && (F$1 = textLen + F$1);
		for (var u = "", r = 0, a = t(s), n$1 = 0; n$1 < a.length; n$1++) {
			var l$2 = a[n$1], o$1 = D$1.length(l$2);
			if (r >= i$1 - (o$1 == 2 ? 1 : 0)) if (r + o$1 <= F$1) u += l$2;
			else break;
			r += o$1;
		}
		return u;
	};
})(q$2);
var xu = q$2.exports;
const Bu = Z(xu);
var pu = function() {
	return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
const Au = Z(pu);
function b(e$1, D$1 = {}) {
	if (typeof e$1 != "string" || e$1.length === 0 || (D$1 = {
		ambiguousIsNarrow: !0,
		...D$1
	}, e$1 = Y(e$1), e$1.length === 0)) return 0;
	e$1 = e$1.replace(Au(), "  ");
	const t = D$1.ambiguousIsNarrow ? 1 : 2;
	let s = 0;
	for (const i$1 of e$1) {
		const F$1 = i$1.codePointAt(0);
		if (F$1 <= 31 || F$1 >= 127 && F$1 <= 159 || F$1 >= 768 && F$1 <= 879) continue;
		switch (Bu.eastAsianWidth(i$1)) {
			case "F":
			case "W":
				s += 2;
				break;
			case "A":
				s += t;
				break;
			default: s += 1;
		}
	}
	return s;
}
const M = 10, H$1 = (e$1 = 0) => (D$1) => `\x1B[${D$1 + e$1}m`, J$1 = (e$1 = 0) => (D$1) => `\x1B[${38 + e$1};5;${D$1}m`, Q = (e$1 = 0) => (D$1, t, s) => `\x1B[${38 + e$1};2;${D$1};${t};${s}m`, C = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
Object.keys(C.modifier);
const fu = Object.keys(C.color), du = Object.keys(C.bgColor);
[...fu, ...du];
function gu() {
	const e$1 = /* @__PURE__ */ new Map();
	for (const [D$1, t] of Object.entries(C)) {
		for (const [s, i$1] of Object.entries(t)) C[s] = {
			open: `\x1B[${i$1[0]}m`,
			close: `\x1B[${i$1[1]}m`
		}, t[s] = C[s], e$1.set(i$1[0], i$1[1]);
		Object.defineProperty(C, D$1, {
			value: t,
			enumerable: !1
		});
	}
	return Object.defineProperty(C, "codes", {
		value: e$1,
		enumerable: !1
	}), C.color.close = "\x1B[39m", C.bgColor.close = "\x1B[49m", C.color.ansi = H$1(), C.color.ansi256 = J$1(), C.color.ansi16m = Q(), C.bgColor.ansi = H$1(M), C.bgColor.ansi256 = J$1(M), C.bgColor.ansi16m = Q(M), Object.defineProperties(C, {
		rgbToAnsi256: {
			value: (D$1, t, s) => D$1 === t && t === s ? D$1 < 8 ? 16 : D$1 > 248 ? 231 : Math.round((D$1 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(D$1 / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(s / 255 * 5),
			enumerable: !1
		},
		hexToRgb: {
			value: (D$1) => {
				const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(D$1.toString(16));
				if (!t) return [
					0,
					0,
					0
				];
				let [s] = t;
				s.length === 3 && (s = [...s].map((F$1) => F$1 + F$1).join(""));
				const i$1 = Number.parseInt(s, 16);
				return [
					i$1 >> 16 & 255,
					i$1 >> 8 & 255,
					i$1 & 255
				];
			},
			enumerable: !1
		},
		hexToAnsi256: {
			value: (D$1) => C.rgbToAnsi256(...C.hexToRgb(D$1)),
			enumerable: !1
		},
		ansi256ToAnsi: {
			value: (D$1) => {
				if (D$1 < 8) return 30 + D$1;
				if (D$1 < 16) return 90 + (D$1 - 8);
				let t, s, i$1;
				if (D$1 >= 232) t = ((D$1 - 232) * 10 + 8) / 255, s = t, i$1 = t;
				else {
					D$1 -= 16;
					const r = D$1 % 36;
					t = Math.floor(D$1 / 36) / 5, s = Math.floor(r / 6) / 5, i$1 = r % 6 / 5;
				}
				const F$1 = Math.max(t, s, i$1) * 2;
				if (F$1 === 0) return 30;
				let u = 30 + (Math.round(i$1) << 2 | Math.round(s) << 1 | Math.round(t));
				return F$1 === 2 && (u += 60), u;
			},
			enumerable: !1
		},
		rgbToAnsi: {
			value: (D$1, t, s) => C.ansi256ToAnsi(C.rgbToAnsi256(D$1, t, s)),
			enumerable: !1
		},
		hexToAnsi: {
			value: (D$1) => C.ansi256ToAnsi(C.hexToAnsi256(D$1)),
			enumerable: !1
		}
	}), C;
}
const mu = gu(), $$1 = new Set(["\x1B", ""]), vu = 39, O$1 = "\x07", X$2 = "[", bu = "]", uu = "m", T$1 = `${bu}8;;`, Du = (e$1) => `${$$1.values().next().value}${X$2}${e$1}${uu}`, tu = (e$1) => `${$$1.values().next().value}${T$1}${e$1}${O$1}`, wu = (e$1) => e$1.split(" ").map((D$1) => b(D$1)), j$1 = (e$1, D$1, t) => {
	const s = [...D$1];
	let i$1 = !1, F$1 = !1, u = b(Y(e$1[e$1.length - 1]));
	for (const [r, a] of s.entries()) {
		const n$1 = b(a);
		if (u + n$1 <= t ? e$1[e$1.length - 1] += a : (e$1.push(a), u = 0), $$1.has(a) && (i$1 = !0, F$1 = s.slice(r + 1).join("").startsWith(T$1)), i$1) {
			F$1 ? a === O$1 && (i$1 = !1, F$1 = !1) : a === uu && (i$1 = !1);
			continue;
		}
		u += n$1, u === t && r < s.length - 1 && (e$1.push(""), u = 0);
	}
	!u && e$1[e$1.length - 1].length > 0 && e$1.length > 1 && (e$1[e$1.length - 2] += e$1.pop());
}, yu = (e$1) => {
	const D$1 = e$1.split(" ");
	let t = D$1.length;
	for (; t > 0 && !(b(D$1[t - 1]) > 0);) t--;
	return t === D$1.length ? e$1 : D$1.slice(0, t).join(" ") + D$1.slice(t).join("");
}, _u = (e$1, D$1, t = {}) => {
	if (t.trim !== !1 && e$1.trim() === "") return "";
	let s = "", i$1, F$1;
	const u = wu(e$1);
	let r = [""];
	for (const [n$1, l$2] of e$1.split(" ").entries()) {
		t.trim !== !1 && (r[r.length - 1] = r[r.length - 1].trimStart());
		let o$1 = b(r[r.length - 1]);
		if (n$1 !== 0 && (o$1 >= D$1 && (t.wordWrap === !1 || t.trim === !1) && (r.push(""), o$1 = 0), (o$1 > 0 || t.trim === !1) && (r[r.length - 1] += " ", o$1++)), t.hard && u[n$1] > D$1) {
			const A = D$1 - o$1, y = 1 + Math.floor((u[n$1] - A - 1) / D$1);
			Math.floor((u[n$1] - 1) / D$1) < y && r.push(""), j$1(r, l$2, D$1);
			continue;
		}
		if (o$1 + u[n$1] > D$1 && o$1 > 0 && u[n$1] > 0) {
			if (t.wordWrap === !1 && o$1 < D$1) {
				j$1(r, l$2, D$1);
				continue;
			}
			r.push("");
		}
		if (o$1 + u[n$1] > D$1 && t.wordWrap === !1) {
			j$1(r, l$2, D$1);
			continue;
		}
		r[r.length - 1] += l$2;
	}
	t.trim !== !1 && (r = r.map((n$1) => yu(n$1)));
	const a = [...r.join(`
`)];
	for (const [n$1, l$2] of a.entries()) {
		if (s += l$2, $$1.has(l$2)) {
			const { groups: A } = (/* @__PURE__ */ new RegExp(`(?:\\${X$2}(?<code>\\d+)m|\\${T$1}(?<uri>.*)${O$1})`)).exec(a.slice(n$1).join("")) || { groups: {} };
			if (A.code !== void 0) {
				const y = Number.parseFloat(A.code);
				i$1 = y === vu ? void 0 : y;
			} else A.uri !== void 0 && (F$1 = A.uri.length === 0 ? void 0 : A.uri);
		}
		const o$1 = mu.codes.get(Number(i$1));
		a[n$1 + 1] === `
` ? (F$1 && (s += tu("")), i$1 && o$1 && (s += Du(o$1))) : l$2 === `
` && (i$1 && o$1 && (s += Du(i$1)), F$1 && (s += tu(F$1)));
	}
	return s;
};
function eu(e$1, D$1, t) {
	return String(e$1).normalize().replace(/\r\n/g, `
`).split(`
`).map((s) => _u(s, D$1, t)).join(`
`);
}
const c$1 = {
	actions: new Set([
		"up",
		"down",
		"left",
		"right",
		"space",
		"enter",
		"cancel"
	]),
	aliases: new Map([
		["k", "up"],
		["j", "down"],
		["h", "left"],
		["l", "right"],
		["", "cancel"],
		["escape", "cancel"]
	]),
	messages: {
		cancel: "Canceled",
		error: "Something went wrong"
	}
};
function W$1(e$1, D$1) {
	if (typeof e$1 == "string") return c$1.aliases.get(e$1) === D$1;
	for (const t of e$1) if (t !== void 0 && W$1(t, D$1)) return !0;
	return !1;
}
function ku(e$1, D$1) {
	if (e$1 === D$1) return;
	const t = e$1.split(`
`), s = D$1.split(`
`), i$1 = [];
	for (let F$1 = 0; F$1 < Math.max(t.length, s.length); F$1++) t[F$1] !== s[F$1] && i$1.push(F$1);
	return i$1;
}
const Iu = globalThis.process.platform.startsWith("win"), L$2 = Symbol("clack:cancel");
function Vu(e$1) {
	return e$1 === L$2;
}
function S(e$1, D$1) {
	const t = e$1;
	t.isTTY && t.setRawMode(D$1);
}
function Mu({ input: e$1 = stdin, output: D$1 = stdout, overwrite: t = !0, hideCursor: s = !0 } = {}) {
	const i$1 = _.createInterface({
		input: e$1,
		output: D$1,
		prompt: "",
		tabSize: 1
	});
	_.emitKeypressEvents(e$1, i$1), e$1 instanceof ReadStream && e$1.isTTY && e$1.setRawMode(!0);
	const F$1 = (u, { name: r, sequence: a }) => {
		if (W$1([
			String(u),
			r,
			a
		], "cancel")) {
			s && D$1.write(import_src$1.cursor.show), process.exit(0);
			return;
		}
		if (!t) return;
		const l$2 = r === "return" ? 0 : -1, o$1 = r === "return" ? -1 : 0;
		_.moveCursor(D$1, l$2, o$1, () => {
			_.clearLine(D$1, 1, () => {
				e$1.once("keypress", F$1);
			});
		});
	};
	return s && D$1.write(import_src$1.cursor.hide), e$1.once("keypress", F$1), () => {
		e$1.off("keypress", F$1), s && D$1.write(import_src$1.cursor.show), e$1 instanceof ReadStream && e$1.isTTY && !Iu && e$1.setRawMode(!1), i$1.terminal = !1, i$1.close();
	};
}
const Ou = (e$1) => e$1 instanceof WriteStream && e$1.columns ? e$1.columns : 80;
var Tu = Object.defineProperty, ju = (e$1, D$1, t) => D$1 in e$1 ? Tu(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, E$1 = (e$1, D$1, t) => (ju(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t);
let p = class {
	constructor(D$1, t = !0) {
		E$1(this, "input"), E$1(this, "output"), E$1(this, "_abortSignal"), E$1(this, "rl"), E$1(this, "opts"), E$1(this, "_render"), E$1(this, "_track", !1), E$1(this, "_prevFrame", ""), E$1(this, "_subscribers", /* @__PURE__ */ new Map()), E$1(this, "_cursor", 0), E$1(this, "state", "initial"), E$1(this, "error", ""), E$1(this, "value"), E$1(this, "userInput", "");
		const { input: s = stdin, output: i$1 = stdout, render: F$1, signal: u,...r } = D$1;
		this.opts = r, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = F$1.bind(this), this._track = t, this._abortSignal = u, this.input = s, this.output = i$1;
	}
	unsubscribe() {
		this._subscribers.clear();
	}
	setSubscriber(D$1, t) {
		const s = this._subscribers.get(D$1) ?? [];
		s.push(t), this._subscribers.set(D$1, s);
	}
	on(D$1, t) {
		this.setSubscriber(D$1, { cb: t });
	}
	once(D$1, t) {
		this.setSubscriber(D$1, {
			cb: t,
			once: !0
		});
	}
	emit(D$1, ...t) {
		const s = this._subscribers.get(D$1) ?? [], i$1 = [];
		for (const F$1 of s) F$1.cb(...t), F$1.once && i$1.push(() => s.splice(s.indexOf(F$1), 1));
		for (const F$1 of i$1) F$1();
	}
	prompt() {
		return new Promise((D$1) => {
			if (this._abortSignal) {
				if (this._abortSignal.aborted) return this.state = "cancel", this.close(), D$1(L$2);
				this._abortSignal.addEventListener("abort", () => {
					this.state = "cancel", this.close();
				}, { once: !0 });
			}
			this.rl = Eu.createInterface({
				input: this.input,
				tabSize: 2,
				prompt: "",
				escapeCodeTimeout: 50,
				terminal: !0
			}), this.rl.prompt(), this.opts.initialUserInput !== void 0 && this._setUserInput(this.opts.initialUserInput, !0), this.input.on("keypress", this.onKeypress), S(this.input, !0), this.output.on("resize", this.render), this.render(), this.once("submit", () => {
				this.output.write(import_src$1.cursor.show), this.output.off("resize", this.render), S(this.input, !1), D$1(this.value);
			}), this.once("cancel", () => {
				this.output.write(import_src$1.cursor.show), this.output.off("resize", this.render), S(this.input, !1), D$1(L$2);
			});
		});
	}
	_isActionKey(D$1, t) {
		return D$1 === "	";
	}
	_setValue(D$1) {
		this.value = D$1, this.emit("value", this.value);
	}
	_setUserInput(D$1, t) {
		this.userInput = D$1 ?? "", this.emit("userInput", this.userInput), t && this._track && this.rl && (this.rl.write(this.userInput), this._cursor = this.rl.cursor);
	}
	onKeypress(D$1, t) {
		if (this._track && t.name !== "return" && (t.name && this._isActionKey(D$1, t) && this.rl?.write(null, {
			ctrl: !0,
			name: "h"
		}), this._cursor = this.rl?.cursor ?? 0, this._setUserInput(this.rl?.line)), this.state === "error" && (this.state = "active"), t?.name && (!this._track && c$1.aliases.has(t.name) && this.emit("cursor", c$1.aliases.get(t.name)), c$1.actions.has(t.name) && this.emit("cursor", t.name)), D$1 && (D$1.toLowerCase() === "y" || D$1.toLowerCase() === "n") && this.emit("confirm", D$1.toLowerCase() === "y"), this.emit("key", D$1?.toLowerCase(), t), t?.name === "return") {
			if (this.opts.validate) {
				const s = this.opts.validate(this.value);
				s && (this.error = s instanceof Error ? s.message : s, this.state = "error", this.rl?.write(this.userInput));
			}
			this.state !== "error" && (this.state = "submit");
		}
		W$1([
			D$1,
			t?.name,
			t?.sequence
		], "cancel") && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
	}
	close() {
		this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), S(this.input, !1), this.rl?.close(), this.rl = void 0, this.emit(`${this.state}`, this.value), this.unsubscribe();
	}
	restoreCursor() {
		const D$1 = eu(this._prevFrame, process.stdout.columns, { hard: !0 }).split(`
`).length - 1;
		this.output.write(import_src$1.cursor.move(-999, D$1 * -1));
	}
	render() {
		const D$1 = eu(this._render(this) ?? "", process.stdout.columns, { hard: !0 });
		if (D$1 !== this._prevFrame) {
			if (this.state === "initial") this.output.write(import_src$1.cursor.hide);
			else {
				const t = ku(this._prevFrame, D$1);
				if (this.restoreCursor(), t && t?.length === 1) {
					const s = t[0];
					this.output.write(import_src$1.cursor.move(0, s)), this.output.write(import_src$1.erase.lines(1));
					const i$1 = D$1.split(`
`);
					this.output.write(i$1[s]), this._prevFrame = D$1, this.output.write(import_src$1.cursor.move(0, i$1.length - s - 1));
					return;
				}
				if (t && t?.length > 1) {
					const s = t[0];
					this.output.write(import_src$1.cursor.move(0, s)), this.output.write(import_src$1.erase.down());
					const i$1 = D$1.split(`
`).slice(s);
					this.output.write(i$1.join(`
`)), this._prevFrame = D$1;
					return;
				}
				this.output.write(import_src$1.erase.down());
			}
			this.output.write(D$1), this.state === "initial" && (this.state = "active"), this._prevFrame = D$1;
		}
	}
}, Wu = class extends p {
	get cursor() {
		return this.value ? 0 : 1;
	}
	get _value() {
		return this.cursor === 0;
	}
	constructor(D$1) {
		super(D$1, !1), this.value = !!D$1.initialValue, this.on("userInput", () => {
			this.value = this._value;
		}), this.on("confirm", (t) => {
			this.output.write(import_src$1.cursor.move(0, -1)), this.value = t, this.state = "submit", this.close();
		}), this.on("cursor", () => {
			this.value = !this.value;
		});
	}
};
var Lu = Object.defineProperty, Nu = (e$1, D$1, t) => D$1 in e$1 ? Lu(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, su = (e$1, D$1, t) => (Nu(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t), iu = (e$1, D$1, t) => {
	if (!D$1.has(e$1)) throw TypeError("Cannot " + t);
}, N$1 = (e$1, D$1, t) => (iu(e$1, D$1, "read from private field"), t ? t.call(e$1) : D$1.get(e$1)), Pu = (e$1, D$1, t) => {
	if (D$1.has(e$1)) throw TypeError("Cannot add the same private member more than once");
	D$1 instanceof WeakSet ? D$1.add(e$1) : D$1.set(e$1, t);
}, Ru = (e$1, D$1, t, s) => (iu(e$1, D$1, "write to private field"), s ? s.call(e$1, t) : D$1.set(e$1, t), t), d;
let Ku = class extends p {
	constructor(D$1) {
		super(D$1, !1), su(this, "options"), su(this, "cursor", 0), Pu(this, d, void 0);
		const { options: t } = D$1;
		Ru(this, d, D$1.selectableGroups !== !1), this.options = Object.entries(t).flatMap(([s, i$1]) => [{
			value: s,
			group: !0,
			label: s
		}, ...i$1.map((F$1) => ({
			...F$1,
			group: s
		}))]), this.value = [...D$1.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: s }) => s === D$1.cursorAt), N$1(this, d) ? 0 : 1), this.on("cursor", (s) => {
			switch (s) {
				case "left":
				case "up": {
					this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
					const i$1 = this.options[this.cursor]?.group === !0;
					!N$1(this, d) && i$1 && (this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1);
					break;
				}
				case "down":
				case "right": {
					this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
					const i$1 = this.options[this.cursor]?.group === !0;
					!N$1(this, d) && i$1 && (this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1);
					break;
				}
				case "space":
					this.toggleValue();
					break;
			}
		});
	}
	getGroupItems(D$1) {
		return this.options.filter((t) => t.group === D$1);
	}
	isGroupSelected(D$1) {
		const t = this.getGroupItems(D$1), s = this.value;
		return s === void 0 ? !1 : t.every((i$1) => s.includes(i$1.value));
	}
	toggleValue() {
		const D$1 = this.options[this.cursor];
		if (this.value === void 0 && (this.value = []), D$1.group === !0) {
			const t = D$1.value, s = this.getGroupItems(t);
			this.isGroupSelected(t) ? this.value = this.value.filter((i$1) => s.findIndex((F$1) => F$1.value === i$1) === -1) : this.value = [...this.value, ...s.map((i$1) => i$1.value)], this.value = Array.from(new Set(this.value));
		} else this.value = this.value.includes(D$1.value) ? this.value.filter((s) => s !== D$1.value) : [...this.value, D$1.value];
	}
};
d = /* @__PURE__ */ new WeakMap();
var Gu = Object.defineProperty, zu = (e$1, D$1, t) => D$1 in e$1 ? Gu(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, Fu = (e$1, D$1, t) => (zu(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t);
let Uu = class extends p {
	constructor(D$1) {
		super(D$1, !1), Fu(this, "options"), Fu(this, "cursor", 0), this.options = D$1.options, this.value = [...D$1.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: t }) => t === D$1.cursorAt), 0), this.on("key", (t) => {
			t === "a" && this.toggleAll();
		}), this.on("cursor", (t) => {
			switch (t) {
				case "left":
				case "up":
					this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
					break;
				case "down":
				case "right":
					this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
					break;
				case "space":
					this.toggleValue();
					break;
			}
		});
	}
	get _value() {
		return this.options[this.cursor].value;
	}
	toggleAll() {
		this.value = this.value !== void 0 && this.value.length === this.options.length ? [] : this.options.map((t) => t.value);
	}
	toggleValue() {
		this.value === void 0 && (this.value = []);
		this.value = this.value.includes(this._value) ? this.value.filter((t) => t !== this._value) : [...this.value, this._value];
	}
};
var Yu = Object.defineProperty, Zu = (e$1, D$1, t) => D$1 in e$1 ? Yu(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, qu = (e$1, D$1, t) => (Zu(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t);
let Hu = class extends p {
	constructor({ mask: D$1,...t }) {
		super(t), qu(this, "_mask", ""), this._mask = D$1 ?? "", this.on("userInput", (s) => {
			this._setValue(s);
		});
	}
	get cursor() {
		return this._cursor;
	}
	get masked() {
		return this.userInput.replaceAll(/./g, this._mask);
	}
	get userInputWithCursor() {
		if (this.state === "submit" || this.state === "cancel") return this.masked;
		const D$1 = this.userInput;
		if (this.cursor >= D$1.length) return `${this.masked}${import_picocolors$3.default.inverse(import_picocolors$3.default.hidden("_"))}`;
		const t = this.masked, s = t.slice(0, this.cursor), i$1 = t.slice(this.cursor);
		return `${s}${import_picocolors$3.default.inverse(i$1[0])}${i$1.slice(1)}`;
	}
};
var Ju = Object.defineProperty, Qu = (e$1, D$1, t) => D$1 in e$1 ? Ju(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, ru = (e$1, D$1, t) => (Qu(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t);
let Xu = class extends p {
	constructor(D$1) {
		super(D$1, !1), ru(this, "options"), ru(this, "cursor", 0), this.options = D$1.options, this.cursor = this.options.findIndex(({ value: t }) => t === D$1.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (t) => {
			switch (t) {
				case "left":
				case "up":
					this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
					break;
				case "down":
				case "right":
					this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
					break;
			}
			this.changeValue();
		});
	}
	get _selectedValue() {
		return this.options[this.cursor];
	}
	changeValue() {
		this.value = this._selectedValue.value;
	}
};
var uD = Object.defineProperty, DD = (e$1, D$1, t) => D$1 in e$1 ? uD(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, Cu = (e$1, D$1, t) => (DD(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t);
let tD = class extends p {
	constructor(D$1) {
		super(D$1, !1), Cu(this, "options"), Cu(this, "cursor", 0), this.options = D$1.options;
		const t = this.options.map(({ value: [s] }) => s?.toLowerCase());
		this.cursor = Math.max(t.indexOf(D$1.initialValue), 0), this.on("key", (s) => {
			if (!s || !t.includes(s)) return;
			const i$1 = this.options.find(({ value: [F$1] }) => F$1?.toLowerCase() === s);
			i$1 && (this.value = i$1.value, this.state = "submit", this.emit("submit"));
		});
	}
};
var eD = class extends p {
	get userInputWithCursor() {
		if (this.state === "submit") return this.userInput;
		const D$1 = this.userInput;
		if (this.cursor >= D$1.length) return `${this.userInput}\u2588`;
		const t = D$1.slice(0, this.cursor), [s, ...i$1] = D$1.slice(this.cursor);
		return `${t}${import_picocolors$3.default.inverse(s)}${i$1.join("")}`;
	}
	get cursor() {
		return this._cursor;
	}
	constructor(D$1) {
		super({
			...D$1,
			initialUserInput: D$1.initialUserInput ?? D$1.initialValue
		}), this.on("userInput", (t) => {
			this._setValue(t);
		}), this.on("finalize", () => {
			this.value || (this.value = D$1.defaultValue), this.value === void 0 && (this.value = "");
		});
	}
};
var sD = Object.defineProperty, iD = (e$1, D$1, t) => D$1 in e$1 ? sD(e$1, D$1, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : e$1[D$1] = t, w = (e$1, D$1, t) => (iD(e$1, typeof D$1 != "symbol" ? D$1 + "" : D$1, t), t), P$1 = (e$1, D$1, t) => {
	if (!D$1.has(e$1)) throw TypeError("Cannot " + t);
}, x$2 = (e$1, D$1, t) => (P$1(e$1, D$1, "read from private field"), t ? t.call(e$1) : D$1.get(e$1)), g = (e$1, D$1, t) => {
	if (D$1.has(e$1)) throw TypeError("Cannot add the same private member more than once");
	D$1 instanceof WeakSet ? D$1.add(e$1) : D$1.set(e$1, t);
}, m = (e$1, D$1, t, s) => (P$1(e$1, D$1, "write to private field"), s ? s.call(e$1, t) : D$1.set(e$1, t), t), nu = (e$1, D$1, t) => (P$1(e$1, D$1, "access private method"), t), B$1, k$1, I$1, v$1, R$2, ou, K$1, au;
function FD(e$1, D$1) {
	if (e$1 === void 0 || D$1.length === 0) return 0;
	const t = D$1.findIndex((s) => s.value === e$1);
	return t !== -1 ? t : 0;
}
function rD(e$1, D$1) {
	return (D$1.label ?? String(D$1.value)).toLowerCase().includes(e$1.toLowerCase());
}
function CD(e$1, D$1) {
	if (D$1) return e$1 ? D$1 : D$1[0];
}
var nD = class extends p {
	constructor(D$1) {
		super(D$1), g(this, R$2), g(this, K$1), w(this, "filteredOptions"), w(this, "multiple"), w(this, "isNavigating", !1), w(this, "selectedValues", []), w(this, "focusedValue"), g(this, B$1, 0), g(this, k$1, ""), g(this, I$1, void 0), g(this, v$1, void 0), m(this, v$1, D$1.options);
		const t = this.options;
		this.filteredOptions = [...t], this.multiple = D$1.multiple === !0, m(this, I$1, D$1.filter ?? rD);
		let s;
		if (D$1.initialValue && Array.isArray(D$1.initialValue) ? this.multiple ? s = D$1.initialValue : s = D$1.initialValue.slice(0, 1) : !this.multiple && this.options.length > 0 && (s = [this.options[0].value]), s) for (const i$1 of s) {
			const F$1 = t.findIndex((u) => u.value === i$1);
			F$1 !== -1 && (this.toggleSelected(i$1), m(this, B$1, F$1));
		}
		this.focusedValue = this.options[x$2(this, B$1)]?.value, this.on("key", (i$1, F$1) => nu(this, R$2, ou).call(this, i$1, F$1)), this.on("userInput", (i$1) => nu(this, K$1, au).call(this, i$1));
	}
	get cursor() {
		return x$2(this, B$1);
	}
	get userInputWithCursor() {
		if (!this.userInput) return import_picocolors$3.default.inverse(import_picocolors$3.default.hidden("_"));
		if (this._cursor >= this.userInput.length) return `${this.userInput}\u2588`;
		const D$1 = this.userInput.slice(0, this._cursor), [t, ...s] = this.userInput.slice(this._cursor);
		return `${D$1}${import_picocolors$3.default.inverse(t)}${s.join("")}`;
	}
	get options() {
		return typeof x$2(this, v$1) == "function" ? x$2(this, v$1).call(this) : x$2(this, v$1);
	}
	_isActionKey(D$1, t) {
		return D$1 === "	" || this.multiple && this.isNavigating && t.name === "space" && D$1 !== void 0 && D$1 !== "";
	}
	deselectAll() {
		this.selectedValues = [];
	}
	toggleSelected(D$1) {
		this.filteredOptions.length !== 0 && (this.multiple ? this.selectedValues.includes(D$1) ? this.selectedValues = this.selectedValues.filter((t) => t !== D$1) : this.selectedValues = [...this.selectedValues, D$1] : this.selectedValues = [D$1]);
	}
};
B$1 = /* @__PURE__ */ new WeakMap(), k$1 = /* @__PURE__ */ new WeakMap(), I$1 = /* @__PURE__ */ new WeakMap(), v$1 = /* @__PURE__ */ new WeakMap(), R$2 = /* @__PURE__ */ new WeakSet(), ou = function(e$1, D$1) {
	const t = D$1.name === "up", s = D$1.name === "down", i$1 = D$1.name === "return";
	t || s ? (m(this, B$1, Math.max(0, Math.min(x$2(this, B$1) + (t ? -1 : 1), this.filteredOptions.length - 1))), this.focusedValue = this.filteredOptions[x$2(this, B$1)]?.value, this.multiple || (this.selectedValues = [this.focusedValue]), this.isNavigating = !0) : i$1 ? this.value = CD(this.multiple, this.selectedValues) : this.multiple ? this.focusedValue !== void 0 && (D$1.name === "tab" || this.isNavigating && D$1.name === "space") ? this.toggleSelected(this.focusedValue) : this.isNavigating = !1 : this.focusedValue && (this.selectedValues = [this.focusedValue]);
}, K$1 = /* @__PURE__ */ new WeakSet(), au = function(e$1) {
	if (e$1 !== x$2(this, k$1)) {
		m(this, k$1, e$1);
		const D$1 = this.options;
		e$1 ? this.filteredOptions = D$1.filter((t) => x$2(this, I$1).call(this, e$1, t)) : this.filteredOptions = [...D$1], m(this, B$1, FD(this.focusedValue, this.filteredOptions)), this.focusedValue = this.filteredOptions[x$2(this, B$1)]?.value, this.multiple || (this.focusedValue !== void 0 ? this.toggleSelected(this.focusedValue) : this.deselectAll());
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@clack+prompts@1.0.0-alpha.1/node_modules/@clack/prompts/dist/index.mjs
var import_picocolors$1 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var import_picocolors$2 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
var import_src = /* @__PURE__ */ __toESM(require_src(), 1);
function Pe() {
	return process$1.platform !== "win32" ? process$1.env.TERM !== "linux" : !!process$1.env.CI || !!process$1.env.WT_SESSION || !!process$1.env.TERMINUS_SUBLIME || process$1.env.ConEmuTask === "{cmd::Cmder}" || process$1.env.TERM_PROGRAM === "Terminus-Sublime" || process$1.env.TERM_PROGRAM === "vscode" || process$1.env.TERM === "xterm-256color" || process$1.env.TERM === "alacritty" || process$1.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
const N = Pe(), D = () => process.env.CI === "true", v = (t, i$1) => N ? t : i$1, ne = v("", "*"), G = v("", "x"), F = v("", "x"), O = v("", "o"), oe = v("", "T"), o = v("", "|"), f = v("", ""), P = v("", ">"), L$1 = v("", " "), k = v("", "[]"), x$1 = v("", "[+]"), B = v("", "[ ]"), ae = v("", ""), U$1 = v("", "-"), ue = v("", "+"), ce = v("", "+"), le = v("", "+"), H = v("", ""), K = v("", "*"), q$1 = v("", "!"), X$1 = v("", "x"), E = (t) => {
	switch (t) {
		case "initial":
		case "active": return import_picocolors$2.default.cyan(ne);
		case "cancel": return import_picocolors$2.default.red(G);
		case "error": return import_picocolors$2.default.yellow(F);
		case "submit": return import_picocolors$2.default.green(O);
	}
}, j = (t) => {
	const { cursor: i$1, options: r, style: s } = t, n$1 = t.output ?? process.stdout, a = n$1 instanceof WriteStream && n$1.rows !== void 0 ? n$1.rows : 10, l$2 = import_picocolors$2.default.dim("..."), c$2 = t.maxItems ?? Number.POSITIVE_INFINITY, u = Math.max(a - 4, 0), $$2 = Math.min(u, Math.max(c$2, 5));
	let m$1 = 0;
	i$1 >= m$1 + $$2 - 3 ? m$1 = Math.max(Math.min(i$1 - $$2 + 3, r.length - $$2), 0) : i$1 < m$1 + 2 && (m$1 = Math.max(i$1 - 2, 0));
	const h$2 = $$2 < r.length && m$1 > 0, g$1 = $$2 < r.length && m$1 + $$2 < r.length;
	return r.slice(m$1, m$1 + $$2).map((p$2, d$1, y) => {
		const w$1 = d$1 === 0 && h$2, b$1 = d$1 === y.length - 1 && g$1;
		return w$1 || b$1 ? l$2 : s(p$2, d$1 + m$1 === i$1);
	});
};
function $e(t) {
	return t.label ?? String(t.value ?? "");
}
function pe(t, i$1) {
	if (!t) return !0;
	const r = (i$1.label ?? String(i$1.value ?? "")).toLowerCase(), s = (i$1.hint ?? "").toLowerCase(), n$1 = String(i$1.value).toLowerCase(), a = t.toLowerCase();
	return r.includes(a) || s.includes(a) || n$1.includes(a);
}
function Le(t, i$1) {
	const r = [];
	for (const s of i$1) t.includes(s.value) && r.push(s);
	return r;
}
const me$1 = (t) => new nD({
	options: t.options,
	initialValue: t.initialValue ? [t.initialValue] : void 0,
	initialUserInput: t.initialUserInput,
	filter: (i$1, r) => pe(i$1, r),
	signal: t.signal,
	input: t.input,
	output: t.output,
	validate: t.validate,
	render() {
		const i$1 = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, r = this.userInput, s = String(this.value ?? ""), n$1 = this.options, a = t.placeholder, l$2 = s === "" && a !== void 0;
		switch (this.state) {
			case "submit": {
				const c$2 = Le(this.selectedValues, n$1), u = c$2.length > 0 ? c$2.map($e).join(", ") : "";
				return `${i$1}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.dim(u)}`;
			}
			case "cancel": return `${i$1}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(r))}`;
			default: {
				const c$2 = this.isNavigating || l$2 ? import_picocolors$2.default.dim(l$2 ? a : r) : this.userInputWithCursor, u = this.filteredOptions.length !== n$1.length ? import_picocolors$2.default.dim(` (${this.filteredOptions.length} match${this.filteredOptions.length === 1 ? "" : "es"})`) : "", $$2 = this.filteredOptions.length === 0 ? [] : j({
					cursor: this.cursor,
					options: this.filteredOptions,
					style: (p$2, d$1) => {
						const y = $e(p$2), w$1 = p$2.hint && p$2.value === this.focusedValue ? import_picocolors$2.default.dim(` (${p$2.hint})`) : "";
						return d$1 ? `${import_picocolors$2.default.green(P)} ${y}${w$1}` : `${import_picocolors$2.default.dim(L$1)} ${import_picocolors$2.default.dim(y)}${w$1}`;
					},
					maxItems: t.maxItems,
					output: t.output
				}), m$1 = [
					`${import_picocolors$2.default.dim("/")} to select`,
					`${import_picocolors$2.default.dim("Enter:")} confirm`,
					`${import_picocolors$2.default.dim("Type:")} to search`
				], h$2 = this.filteredOptions.length === 0 && r ? [`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.yellow("No matches found")}`] : [], g$1 = this.state === "error" ? [`${import_picocolors$2.default.yellow(o)}  ${import_picocolors$2.default.yellow(this.error)}`] : [];
				return [
					i$1,
					`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.dim("Search:")} ${c$2}${u}`,
					...h$2,
					...g$1,
					...$$2.map((p$2) => `${import_picocolors$2.default.cyan(o)}  ${p$2}`),
					`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.dim(m$1.join("  "))}`,
					`${import_picocolors$2.default.cyan(f)}`
				].join(`
`);
			}
		}
	}
}).prompt(), Ne = (t) => {
	const i$1 = (s, n$1, a, l$2) => {
		const c$2 = a.includes(s.value), u = s.label ?? String(s.value ?? ""), $$2 = s.hint && l$2 !== void 0 && s.value === l$2 ? import_picocolors$2.default.dim(` (${s.hint})`) : "", m$1 = c$2 ? import_picocolors$2.default.green(x$1) : import_picocolors$2.default.dim(B);
		return n$1 ? `${m$1} ${u}${$$2}` : `${m$1} ${import_picocolors$2.default.dim(u)}`;
	}, r = new nD({
		options: t.options,
		multiple: !0,
		filter: (s, n$1) => pe(s, n$1),
		validate: () => {
			if (t.required && r.selectedValues.length === 0) return "Please select at least one item";
		},
		initialValue: t.initialValues,
		signal: t.signal,
		input: t.input,
		output: t.output,
		render() {
			const s = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, n$1 = this.userInput, a = t.placeholder, l$2 = n$1 === "" && a !== void 0, c$2 = this.isNavigating || l$2 ? import_picocolors$2.default.dim(l$2 ? a : n$1) : this.userInputWithCursor, u = this.options, $$2 = this.filteredOptions.length !== u.length ? import_picocolors$2.default.dim(` (${this.filteredOptions.length} match${this.filteredOptions.length === 1 ? "" : "es"})`) : "";
			switch (this.state) {
				case "submit": return `${s}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.dim(`${this.selectedValues.length} items selected`)}`;
				case "cancel": return `${s}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(n$1))}`;
				default: {
					const m$1 = [
						`${import_picocolors$2.default.dim("/")} to navigate`,
						`${import_picocolors$2.default.dim("Space:")} select`,
						`${import_picocolors$2.default.dim("Enter:")} confirm`,
						`${import_picocolors$2.default.dim("Type:")} to search`
					], h$2 = this.filteredOptions.length === 0 && n$1 ? [`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.yellow("No matches found")}`] : [], g$1 = this.state === "error" ? [`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.yellow(this.error)}`] : [], p$2 = j({
						cursor: this.cursor,
						options: this.filteredOptions,
						style: (d$1, y) => i$1(d$1, y, this.selectedValues, this.focusedValue),
						maxItems: t.maxItems,
						output: t.output
					});
					return [
						s,
						`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.dim("Search:")} ${c$2}${$$2}`,
						...h$2,
						...g$1,
						...p$2.map((d$1) => `${import_picocolors$2.default.cyan(o)}  ${d$1}`),
						`${import_picocolors$2.default.cyan(o)}  ${import_picocolors$2.default.dim(m$1.join("  "))}`,
						`${import_picocolors$2.default.cyan(f)}`
					].join(`
`);
				}
			}
		}
	});
	return r.prompt();
}, ke = (t) => {
	const i$1 = t.active ?? "Yes", r = t.inactive ?? "No";
	return new Wu({
		active: i$1,
		inactive: r,
		signal: t.signal,
		input: t.input,
		output: t.output,
		initialValue: t.initialValue ?? !0,
		render() {
			const s = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, n$1 = this.value ? i$1 : r;
			switch (this.state) {
				case "submit": return `${s}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.dim(n$1)}`;
				case "cancel": return `${s}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(n$1))}
${import_picocolors$2.default.gray(o)}`;
				default: return `${s}${import_picocolors$2.default.cyan(o)}  ${this.value ? `${import_picocolors$2.default.green(P)} ${i$1}` : `${import_picocolors$2.default.dim(L$1)} ${import_picocolors$2.default.dim(i$1)}`} ${import_picocolors$2.default.dim("/")} ${this.value ? `${import_picocolors$2.default.dim(L$1)} ${import_picocolors$2.default.dim(r)}` : `${import_picocolors$2.default.green(P)} ${r}`}
${import_picocolors$2.default.cyan(f)}
`;
			}
		}
	}).prompt();
}, Be = (t) => {
	const { selectableGroups: i$1 = !0, groupSpacing: r = 0 } = t, s = (a, l$2, c$2 = []) => {
		const u = a.label ?? String(a.value), $$2 = typeof a.group == "string", m$1 = $$2 && (c$2[c$2.indexOf(a) + 1] ?? { group: !0 }), h$2 = $$2 && m$1.group === !0, g$1 = $$2 ? i$1 ? `${h$2 ? f : o} ` : "  " : "", p$2 = r > 0 && !$$2 ? `
${import_picocolors$2.default.cyan(o)}  `.repeat(r) : "";
		if (l$2 === "active") return `${p$2}${import_picocolors$2.default.dim(g$1)}${import_picocolors$2.default.cyan(k)} ${u} ${a.hint ? import_picocolors$2.default.dim(`(${a.hint})`) : ""}`;
		if (l$2 === "group-active") return `${p$2}${g$1}${import_picocolors$2.default.cyan(k)} ${import_picocolors$2.default.dim(u)}`;
		if (l$2 === "group-active-selected") return `${p$2}${g$1}${import_picocolors$2.default.green(x$1)} ${import_picocolors$2.default.dim(u)}`;
		if (l$2 === "selected") {
			const y = $$2 || i$1 ? import_picocolors$2.default.green(x$1) : "";
			return `${p$2}${import_picocolors$2.default.dim(g$1)}${y} ${import_picocolors$2.default.dim(u)} ${a.hint ? import_picocolors$2.default.dim(`(${a.hint})`) : ""}`;
		}
		if (l$2 === "cancelled") return `${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(u))}`;
		if (l$2 === "active-selected") return `${p$2}${import_picocolors$2.default.dim(g$1)}${import_picocolors$2.default.green(x$1)} ${u} ${a.hint ? import_picocolors$2.default.dim(`(${a.hint})`) : ""}`;
		if (l$2 === "submitted") return `${import_picocolors$2.default.dim(u)}`;
		const d$1 = $$2 || i$1 ? import_picocolors$2.default.dim(B) : "";
		return `${p$2}${import_picocolors$2.default.dim(g$1)}${d$1} ${import_picocolors$2.default.dim(u)}`;
	}, n$1 = t.required ?? !0;
	return new Ku({
		options: t.options,
		signal: t.signal,
		input: t.input,
		output: t.output,
		initialValues: t.initialValues,
		required: n$1,
		cursorAt: t.cursorAt,
		selectableGroups: i$1,
		validate(a) {
			if (n$1 && (a === void 0 || a.length === 0)) return `Please select at least one option.
${import_picocolors$2.default.reset(import_picocolors$2.default.dim(`Press ${import_picocolors$2.default.gray(import_picocolors$2.default.bgWhite(import_picocolors$2.default.inverse(" space ")))} to select, ${import_picocolors$2.default.gray(import_picocolors$2.default.bgWhite(import_picocolors$2.default.inverse(" enter ")))} to submit`))}`;
		},
		render() {
			const a = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, l$2 = this.value ?? [];
			switch (this.state) {
				case "submit": return `${a}${import_picocolors$2.default.gray(o)}  ${this.options.filter(({ value: c$2 }) => l$2.includes(c$2)).map((c$2) => s(c$2, "submitted")).join(import_picocolors$2.default.dim(", "))}`;
				case "cancel": {
					const c$2 = this.options.filter(({ value: u }) => l$2.includes(u)).map((u) => s(u, "cancelled")).join(import_picocolors$2.default.dim(", "));
					return `${a}${import_picocolors$2.default.gray(o)}  ${c$2.trim() ? `${c$2}
${import_picocolors$2.default.gray(o)}` : ""}`;
				}
				case "error": {
					const c$2 = this.error.split(`
`).map((u, $$2) => $$2 === 0 ? `${import_picocolors$2.default.yellow(f)}  ${import_picocolors$2.default.yellow(u)}` : `   ${u}`).join(`
`);
					return `${a}${import_picocolors$2.default.yellow(o)}  ${this.options.map((u, $$2, m$1) => {
						const h$2 = l$2.includes(u.value) || u.group === !0 && this.isGroupSelected(`${u.value}`), g$1 = $$2 === this.cursor;
						return !g$1 && typeof u.group == "string" && this.options[this.cursor].value === u.group ? s(u, h$2 ? "group-active-selected" : "group-active", m$1) : g$1 && h$2 ? s(u, "active-selected", m$1) : h$2 ? s(u, "selected", m$1) : s(u, g$1 ? "active" : "inactive", m$1);
					}).join(`
${import_picocolors$2.default.yellow(o)}  `)}
${c$2}
`;
				}
				default: return `${a}${import_picocolors$2.default.cyan(o)}  ${this.options.map((c$2, u, $$2) => {
					const m$1 = l$2.includes(c$2.value) || c$2.group === !0 && this.isGroupSelected(`${c$2.value}`), h$2 = u === this.cursor;
					return !h$2 && typeof c$2.group == "string" && this.options[this.cursor].value === c$2.group ? s(c$2, m$1 ? "group-active-selected" : "group-active", $$2) : h$2 && m$1 ? s(c$2, "active-selected", $$2) : m$1 ? s(c$2, "selected", $$2) : s(c$2, h$2 ? "active" : "inactive", $$2);
				}).join(`
${import_picocolors$2.default.cyan(o)}  `)}
${import_picocolors$2.default.cyan(f)}
`;
			}
		}
	}).prompt();
}, We = async (t, i$1) => {
	const r = {}, s = Object.keys(t);
	for (const n$1 of s) {
		const a = t[n$1], l$2 = await a({ results: r })?.catch((c$2) => {
			throw c$2;
		});
		if (typeof i$1?.onCancel == "function" && Vu(l$2)) {
			r[n$1] = "canceled", i$1.onCancel({ results: r });
			continue;
		}
		r[n$1] = l$2;
	}
	return r;
}, T = {
	message: (t = [], { symbol: i$1 = import_picocolors$2.default.gray(o), secondarySymbol: r = import_picocolors$2.default.gray(o), output: s = process.stdout, spacing: n$1 = 1 } = {}) => {
		const a = [];
		for (let c$2 = 0; c$2 < n$1; c$2++) a.push(`${r}`);
		const l$2 = Array.isArray(t) ? t : t.split(`
`);
		if (l$2.length > 0) {
			const [c$2, ...u] = l$2;
			c$2.length > 0 ? a.push(`${i$1}  ${c$2}`) : a.push(i$1);
			for (const $$2 of u) $$2.length > 0 ? a.push(`${r}  ${$$2}`) : a.push(r);
		}
		s.write(`${a.join(`
`)}
`);
	},
	info: (t, i$1) => {
		T.message(t, {
			...i$1,
			symbol: import_picocolors$2.default.blue(H)
		});
	},
	success: (t, i$1) => {
		T.message(t, {
			...i$1,
			symbol: import_picocolors$2.default.green(K)
		});
	},
	step: (t, i$1) => {
		T.message(t, {
			...i$1,
			symbol: import_picocolors$2.default.green(O)
		});
	},
	warn: (t, i$1) => {
		T.message(t, {
			...i$1,
			symbol: import_picocolors$2.default.yellow(q$1)
		});
	},
	warning: (t, i$1) => {
		T.warn(t, i$1);
	},
	error: (t, i$1) => {
		T.message(t, {
			...i$1,
			symbol: import_picocolors$2.default.red(X$1)
		});
	}
}, De = (t = "", i$1) => {
	(i$1?.output ?? process.stdout).write(`${import_picocolors$2.default.gray(f)}  ${import_picocolors$2.default.red(t)}

`);
}, Ge = (t = "", i$1) => {
	(i$1?.output ?? process.stdout).write(`${import_picocolors$2.default.gray(oe)}  ${t}
`);
}, Fe = (t = "", i$1) => {
	(i$1?.output ?? process.stdout).write(`${import_picocolors$2.default.gray(o)}
${import_picocolors$2.default.gray(f)}  ${t}

`);
}, Ue = (t) => {
	const i$1 = (s, n$1) => {
		const a = s.label ?? String(s.value);
		return n$1 === "active" ? `${import_picocolors$2.default.cyan(k)} ${a} ${s.hint ? import_picocolors$2.default.dim(`(${s.hint})`) : ""}` : n$1 === "selected" ? `${import_picocolors$2.default.green(x$1)} ${import_picocolors$2.default.dim(a)} ${s.hint ? import_picocolors$2.default.dim(`(${s.hint})`) : ""}` : n$1 === "cancelled" ? `${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(a))}` : n$1 === "active-selected" ? `${import_picocolors$2.default.green(x$1)} ${a} ${s.hint ? import_picocolors$2.default.dim(`(${s.hint})`) : ""}` : n$1 === "submitted" ? `${import_picocolors$2.default.dim(a)}` : `${import_picocolors$2.default.dim(B)} ${import_picocolors$2.default.dim(a)}`;
	}, r = t.required ?? !0;
	return new Uu({
		options: t.options,
		signal: t.signal,
		input: t.input,
		output: t.output,
		initialValues: t.initialValues,
		required: r,
		cursorAt: t.cursorAt,
		validate(s) {
			if (r && (s === void 0 || s.length === 0)) return `Please select at least one option.
${import_picocolors$2.default.reset(import_picocolors$2.default.dim(`Press ${import_picocolors$2.default.gray(import_picocolors$2.default.bgWhite(import_picocolors$2.default.inverse(" space ")))} to select, ${import_picocolors$2.default.gray(import_picocolors$2.default.bgWhite(import_picocolors$2.default.inverse(" enter ")))} to submit`))}`;
		},
		render() {
			const s = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, n$1 = this.value ?? [], a = (l$2, c$2) => {
				const u = n$1.includes(l$2.value);
				return c$2 && u ? i$1(l$2, "active-selected") : u ? i$1(l$2, "selected") : i$1(l$2, c$2 ? "active" : "inactive");
			};
			switch (this.state) {
				case "submit": return `${s}${import_picocolors$2.default.gray(o)}  ${this.options.filter(({ value: l$2 }) => n$1.includes(l$2)).map((l$2) => i$1(l$2, "submitted")).join(import_picocolors$2.default.dim(", ")) || import_picocolors$2.default.dim("none")}`;
				case "cancel": {
					const l$2 = this.options.filter(({ value: c$2 }) => n$1.includes(c$2)).map((c$2) => i$1(c$2, "cancelled")).join(import_picocolors$2.default.dim(", "));
					return `${s}${import_picocolors$2.default.gray(o)}  ${l$2.trim() ? `${l$2}
${import_picocolors$2.default.gray(o)}` : ""}`;
				}
				case "error": {
					const l$2 = this.error.split(`
`).map((c$2, u) => u === 0 ? `${import_picocolors$2.default.yellow(f)}  ${import_picocolors$2.default.yellow(c$2)}` : `   ${c$2}`).join(`
`);
					return `${s + import_picocolors$2.default.yellow(o)}  ${j({
						output: t.output,
						options: this.options,
						cursor: this.cursor,
						maxItems: t.maxItems,
						style: a
					}).join(`
${import_picocolors$2.default.yellow(o)}  `)}
${l$2}
`;
				}
				default: return `${s}${import_picocolors$2.default.cyan(o)}  ${j({
					output: t.output,
					options: this.options,
					cursor: this.cursor,
					maxItems: t.maxItems,
					style: a
				}).join(`
${import_picocolors$2.default.cyan(o)}  `)}
${import_picocolors$2.default.cyan(f)}
`;
			}
		}
	}).prompt();
}, He = (t) => import_picocolors$2.default.dim(t), Ke = (t = "", i$1 = "", r) => {
	const s = r?.format ?? He, n$1 = [
		"",
		...t.split(`
`).map(s),
		""
	], a = stripVTControlCharacters(i$1).length, l$2 = r?.output ?? process.stdout, c$2 = Math.max(n$1.reduce(($$2, m$1) => {
		const h$2 = stripVTControlCharacters(m$1);
		return h$2.length > $$2 ? h$2.length : $$2;
	}, 0), a) + 2, u = n$1.map(($$2) => `${import_picocolors$2.default.gray(o)}  ${$$2}${" ".repeat(c$2 - stripVTControlCharacters($$2).length)}${import_picocolors$2.default.gray(o)}`).join(`
`);
	l$2.write(`${import_picocolors$2.default.gray(o)}
${import_picocolors$2.default.green(O)}  ${import_picocolors$2.default.reset(i$1)} ${import_picocolors$2.default.gray(U$1.repeat(Math.max(c$2 - a - 1, 1)) + ue)}
${u}
${import_picocolors$2.default.gray(ce + U$1.repeat(c$2 + 2) + le)}
`);
}, qe = (t) => new Hu({
	validate: t.validate,
	mask: t.mask ?? ae,
	signal: t.signal,
	input: t.input,
	output: t.output,
	render() {
		const i$1 = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, r = this.userInputWithCursor, s = this.masked;
		switch (this.state) {
			case "error": return `${i$1.trim()}
${import_picocolors$2.default.yellow(o)}  ${s}
${import_picocolors$2.default.yellow(f)}  ${import_picocolors$2.default.yellow(this.error)}
`;
			case "submit": return `${i$1}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.dim(s)}`;
			case "cancel": return `${i$1}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(s))}${s ? `
${import_picocolors$2.default.gray(o)}` : ""}`;
			default: return `${i$1}${import_picocolors$2.default.cyan(o)}  ${r}
${import_picocolors$2.default.cyan(f)}
`;
		}
	}
}).prompt(), Xe = (t) => {
	const i$1 = t.validate;
	return me$1({
		...t,
		initialUserInput: t.initialValue ?? t.root ?? process.cwd(),
		maxItems: 5,
		validate(r) {
			if (!Array.isArray(r)) {
				if (!r) return "Please select a path";
				if (i$1) return i$1(r);
			}
		},
		options() {
			const r = this.userInput;
			if (r === "") return [];
			try {
				let s;
				return existsSync(r) ? lstatSync(r).isDirectory() ? s = r : s = dirname(r) : s = dirname(r), readdirSync(s).map((n$1) => {
					const a = join(s, n$1), l$2 = lstatSync(a);
					return {
						name: n$1,
						path: a,
						isDirectory: l$2.isDirectory()
					};
				}).filter(({ path: n$1, isDirectory: a }) => n$1.startsWith(r) && (t.directory || !a)).map((n$1) => ({ value: n$1.path }));
			} catch {
				return [];
			}
		}
	});
}, J = ({ indicator: t = "dots", onCancel: i$1, output: r = process.stdout, cancelMessage: s, errorMessage: n$1, frames: a = N ? [
	"",
	"",
	"",
	""
] : [
	"",
	"o",
	"O",
	"0"
], delay: l$2 = N ? 80 : 120, signal: c$2 } = {}) => {
	const u = D();
	let $$2, m$1, h$2 = !1, g$1 = !1, p$2 = "", d$1, y = performance.now();
	const w$1 = (S$1) => {
		const I$2 = S$1 > 1 ? n$1 ?? c$1.messages.error : s ?? c$1.messages.cancel;
		g$1 = S$1 === 1, h$2 && (Z$1(I$2, S$1), g$1 && typeof i$1 == "function" && i$1());
	}, b$1 = () => w$1(2), M$1 = () => w$1(1), ge$1 = () => {
		process.on("uncaughtExceptionMonitor", b$1), process.on("unhandledRejection", b$1), process.on("SIGINT", M$1), process.on("SIGTERM", M$1), process.on("exit", w$1), c$2 && c$2.addEventListener("abort", M$1);
	}, ye = () => {
		process.removeListener("uncaughtExceptionMonitor", b$1), process.removeListener("unhandledRejection", b$1), process.removeListener("SIGINT", M$1), process.removeListener("SIGTERM", M$1), process.removeListener("exit", w$1), c$2 && c$2.removeEventListener("abort", M$1);
	}, Y$1 = () => {
		if (d$1 === void 0) return;
		u && r.write(`
`);
		const S$1 = d$1.split(`
`);
		r.write(import_src.cursor.move(-999, S$1.length - 1)), r.write(import_src.erase.down(S$1.length));
	}, z = (S$1) => S$1.replace(/\.+$/, ""), Q$1 = (S$1) => {
		const I$2 = (performance.now() - S$1) / 1e3, _$1 = Math.floor(I$2 / 60), A = Math.floor(I$2 % 60);
		return _$1 > 0 ? `[${_$1}m ${A}s]` : `[${A}s]`;
	}, ve$1 = (S$1 = "") => {
		h$2 = !0, $$2 = Mu({ output: r }), p$2 = z(S$1), y = performance.now(), r.write(`${import_picocolors$2.default.gray(o)}
`);
		let I$2 = 0, _$1 = 0;
		ge$1(), m$1 = setInterval(() => {
			if (u && p$2 === d$1) return;
			Y$1(), d$1 = p$2;
			const A = import_picocolors$2.default.magenta(a[I$2]);
			if (u) r.write(`${A}  ${p$2}...`);
			else if (t === "timer") r.write(`${A}  ${p$2} ${Q$1(y)}`);
			else {
				const fe = ".".repeat(Math.floor(_$1)).slice(0, 3);
				r.write(`${A}  ${p$2}${fe}`);
			}
			I$2 = I$2 + 1 < a.length ? I$2 + 1 : 0, _$1 = _$1 < 4 ? _$1 + .125 : 0;
		}, l$2);
	}, Z$1 = (S$1 = "", I$2 = 0) => {
		h$2 = !1, clearInterval(m$1), Y$1();
		const _$1 = I$2 === 0 ? import_picocolors$2.default.green(O) : I$2 === 1 ? import_picocolors$2.default.red(G) : import_picocolors$2.default.red(F);
		p$2 = S$1 ?? p$2, t === "timer" ? r.write(`${_$1}  ${p$2} ${Q$1(y)}
`) : r.write(`${_$1}  ${p$2}
`), ye(), $$2();
	};
	return {
		start: ve$1,
		stop: Z$1,
		message: (S$1 = "") => {
			p$2 = z(S$1 ?? p$2);
		},
		get isCancelled() {
			return g$1;
		}
	};
}, de = {
	light: v("", "-"),
	heavy: v("", "="),
	block: v("", "#")
};
const Ye = (t) => {
	const i$1 = (r, s = "inactive") => {
		const n$1 = r.label ?? String(r.value);
		return s === "selected" ? `${import_picocolors$2.default.dim(n$1)}` : s === "cancelled" ? `${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(n$1))}` : s === "active" ? `${import_picocolors$2.default.bgCyan(import_picocolors$2.default.gray(` ${r.value} `))} ${n$1} ${r.hint ? import_picocolors$2.default.dim(`(${r.hint})`) : ""}` : `${import_picocolors$2.default.gray(import_picocolors$2.default.bgWhite(import_picocolors$2.default.inverse(` ${r.value} `)))} ${n$1} ${r.hint ? import_picocolors$2.default.dim(`(${r.hint})`) : ""}`;
	};
	return new tD({
		options: t.options,
		signal: t.signal,
		input: t.input,
		output: t.output,
		initialValue: t.initialValue,
		render() {
			const r = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`;
			switch (this.state) {
				case "submit": return `${r}${import_picocolors$2.default.gray(o)}  ${i$1(this.options.find((s) => s.value === this.value) ?? t.options[0], "selected")}`;
				case "cancel": return `${r}${import_picocolors$2.default.gray(o)}  ${i$1(this.options[0], "cancelled")}
${import_picocolors$2.default.gray(o)}`;
				default: return `${r}${import_picocolors$2.default.cyan(o)}  ${this.options.map((s, n$1) => i$1(s, n$1 === this.cursor ? "active" : "inactive")).join(`
${import_picocolors$2.default.cyan(o)}  `)}
${import_picocolors$2.default.cyan(f)}
`;
			}
		}
	}).prompt();
}, ze = (t) => {
	const i$1 = (r, s) => {
		const n$1 = r.label ?? String(r.value);
		switch (s) {
			case "selected": return `${import_picocolors$2.default.dim(n$1)}`;
			case "active": return `${import_picocolors$2.default.green(P)} ${n$1} ${r.hint ? import_picocolors$2.default.dim(`(${r.hint})`) : ""}`;
			case "cancelled": return `${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(n$1))}`;
			default: return `${import_picocolors$2.default.dim(L$1)} ${import_picocolors$2.default.dim(n$1)}`;
		}
	};
	return new Xu({
		options: t.options,
		signal: t.signal,
		input: t.input,
		output: t.output,
		initialValue: t.initialValue,
		render() {
			const r = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`;
			switch (this.state) {
				case "submit": return `${r}${import_picocolors$2.default.gray(o)}  ${i$1(this.options[this.cursor], "selected")}`;
				case "cancel": return `${r}${import_picocolors$2.default.gray(o)}  ${i$1(this.options[this.cursor], "cancelled")}
${import_picocolors$2.default.gray(o)}`;
				default: return `${r}${import_picocolors$2.default.cyan(o)}  ${j({
					output: t.output,
					cursor: this.cursor,
					options: this.options,
					maxItems: t.maxItems,
					style: (s, n$1) => i$1(s, n$1 ? "active" : "inactive")
				}).join(`
${import_picocolors$2.default.cyan(o)}  `)}
${import_picocolors$2.default.cyan(f)}
`;
			}
		}
	}).prompt();
}, he = `${import_picocolors$2.default.gray(o)}  `, R$1 = {
	message: async (t, { symbol: i$1 = import_picocolors$2.default.gray(o) } = {}) => {
		process.stdout.write(`${import_picocolors$2.default.gray(o)}
${i$1}  `);
		let r = 3;
		for await (let s of t) {
			s = s.replace(/\n/g, `
${he}`), s.includes(`
`) && (r = 3 + stripVTControlCharacters(s.slice(s.lastIndexOf(`
`))).length);
			const n$1 = stripVTControlCharacters(s).length;
			r + n$1 < process.stdout.columns ? (r += n$1, process.stdout.write(s)) : (process.stdout.write(`
${he}${s.trimStart()}`), r = 3 + stripVTControlCharacters(s.trimStart()).length);
		}
		process.stdout.write(`
`);
	},
	info: (t) => R$1.message(t, { symbol: import_picocolors$2.default.blue(H) }),
	success: (t) => R$1.message(t, { symbol: import_picocolors$2.default.green(K) }),
	step: (t) => R$1.message(t, { symbol: import_picocolors$2.default.green(O) }),
	warn: (t) => R$1.message(t, { symbol: import_picocolors$2.default.yellow(q$1) }),
	warning: (t) => R$1.warn(t),
	error: (t) => R$1.message(t, { symbol: import_picocolors$2.default.red(X$1) })
}, Qe = async (t, i$1) => {
	for (const r of t) {
		if (r.enabled === !1) continue;
		const s = J(i$1);
		s.start(r.title);
		const n$1 = await r.task(s.message);
		s.stop(n$1 || r.title);
	}
}, Ze = (t) => {
	const i$1 = t.output ?? process.stdout, r = Ou(i$1), s = import_picocolors$1.gray(o), n$1 = t.spacing ?? 1, a = 3, l$2 = t.retainLog === !0, c$2 = D();
	i$1.write(`${s}
`), i$1.write(`${import_picocolors$1.green(O)}  ${t.title}
`);
	for (let d$1 = 0; d$1 < n$1; d$1++) i$1.write(`${s}
`);
	let u = "", $$2 = "", m$1 = !1;
	const h$2 = (d$1) => {
		if (u.length === 0) return;
		const y = u.split(`
`).reduce((w$1, b$1) => b$1 === "" ? w$1 + 1 : w$1 + Math.ceil((b$1.length + a) / r), 0) + 1 + (d$1 ? n$1 + 2 : 0);
		i$1.write(import_src.erase.lines(y));
	}, g$1 = (d$1, y) => {
		T.message(d$1.split(`
`).map(import_picocolors$1.dim), {
			output: i$1,
			secondarySymbol: s,
			symbol: s,
			spacing: y ?? n$1
		});
	}, p$2 = () => {
		l$2 === !0 && $$2.length > 0 ? g$1(`${$$2}
${u}`) : g$1(u);
	};
	return {
		message(d$1, y) {
			if (h$2(!1), (y?.raw !== !0 || !m$1) && u !== "" && (u += `
`), u += d$1, m$1 = y?.raw === !0, t.limit !== void 0) {
				const w$1 = u.split(`
`), b$1 = w$1.length - t.limit;
				if (b$1 > 0) {
					const M$1 = w$1.splice(0, b$1);
					l$2 && ($$2 += ($$2 === "" ? "" : `
`) + M$1.join(`
`));
				}
				u = w$1.join(`
`);
			}
			c$2 || g$1(u, 0);
		},
		error(d$1, y) {
			h$2(!0), T.error(d$1, {
				output: i$1,
				secondarySymbol: s,
				spacing: 1
			}), y?.showLog !== !1 && p$2(), u = $$2 = "";
		},
		success(d$1, y) {
			h$2(!0), T.success(d$1, {
				output: i$1,
				secondarySymbol: s,
				spacing: 1
			}), y?.showLog === !0 && p$2(), u = $$2 = "";
		}
	};
}, et$1 = (t) => new eD({
	validate: t.validate,
	placeholder: t.placeholder,
	defaultValue: t.defaultValue,
	initialValue: t.initialValue,
	output: t.output,
	signal: t.signal,
	input: t.input,
	render() {
		const i$1 = `${import_picocolors$2.default.gray(o)}
${E(this.state)}  ${t.message}
`, r = t.placeholder ? import_picocolors$2.default.inverse(t.placeholder[0]) + import_picocolors$2.default.dim(t.placeholder.slice(1)) : import_picocolors$2.default.inverse(import_picocolors$2.default.hidden("_")), s = this.userInput ? this.userInputWithCursor : r, n$1 = this.value ?? "";
		switch (this.state) {
			case "error": return `${i$1.trim()}
${import_picocolors$2.default.yellow(o)}  ${s}
${import_picocolors$2.default.yellow(f)}  ${import_picocolors$2.default.yellow(this.error)}
`;
			case "submit": return `${i$1}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.dim(n$1)}`;
			case "cancel": return `${i$1}${import_picocolors$2.default.gray(o)}  ${import_picocolors$2.default.strikethrough(import_picocolors$2.default.dim(n$1))}${n$1.trim() ? `
${import_picocolors$2.default.gray(o)}` : ""}`;
			default: return `${i$1}${import_picocolors$2.default.cyan(o)}  ${s}
${import_picocolors$2.default.cyan(f)}
`;
		}
	}
}).prompt();

//#endregion
//#region ../core/addon/config.ts
function defineAddon(config) {
	return config;
}
function defineAddonOptions() {
	return createOptionBuilder({});
}
function createOptionBuilder(options) {
	return {
		add(key, question) {
			const newOptions = {
				...options,
				[key]: question
			};
			return createOptionBuilder(newOptions);
		},
		build() {
			return options;
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/dedent@1.6.0/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
	var keys = Object.keys(object);
	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		enumerableOnly && (symbols = symbols.filter(function(sym) {
			return Object.getOwnPropertyDescriptor(object, sym).enumerable;
		})), keys.push.apply(keys, symbols);
	}
	return keys;
}
function _objectSpread(target) {
	for (var i$1 = 1; i$1 < arguments.length; i$1++) {
		var source = null != arguments[i$1] ? arguments[i$1] : {};
		i$1 % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
			_defineProperty(target, key, source[key]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
			Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
		});
	}
	return target;
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(arg) {
	var key = _toPrimitive(arg, "string");
	return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
	if (typeof input !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (typeof res !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
const dedent$1 = createDedent({});
var dedent_default = dedent$1;
function createDedent(options) {
	dedent$2.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
	return dedent$2;
	function dedent$2(strings, ...values) {
		const raw = typeof strings === "string" ? [strings] : strings.raw;
		const { escapeSpecialCharacters = Array.isArray(strings), trimWhitespace = true } = options;
		let result = "";
		for (let i$1 = 0; i$1 < raw.length; i$1++) {
			let next = raw[i$1];
			if (escapeSpecialCharacters) next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
			result += next;
			if (i$1 < values.length) result += values[i$1];
		}
		const lines = result.split("\n");
		let mindent = null;
		for (const l$2 of lines) {
			const m$1 = l$2.match(/^(\s+)\S+/);
			if (m$1) {
				const indent$2 = m$1[1].length;
				if (!mindent) mindent = indent$2;
				else mindent = Math.min(mindent, indent$2);
			}
		}
		if (mindent !== null) {
			const m$1 = mindent;
			result = lines.map((l$2) => l$2[0] === " " || l$2[0] === "	" ? l$2.slice(m$1) : l$2).join("\n");
		}
		if (trimWhitespace) result = result.trim();
		if (escapeSpecialCharacters) result = result.replace(/\\n/g, "\n");
		return result;
	}
}

//#endregion
//#region ../core/utils.ts
function createPrinter(...conditions) {
	return conditions.map((condition) => {
		return (content, alt = "") => condition ? content : alt;
	});
}

//#endregion
//#region ../core/common.ts
function splitVersion(str) {
	const [major, minor, patch] = str?.split(".") ?? [];
	function toVersionNumber(val) {
		return val !== void 0 && val !== "" && !isNaN(Number(val)) ? Number(val) : void 0;
	}
	return {
		major: toVersionNumber(major),
		minor: toVersionNumber(minor),
		patch: toVersionNumber(patch)
	};
}
function isVersionUnsupportedBelow(versionStr, belowStr) {
	const version$1 = splitVersion(versionStr);
	const below = splitVersion(belowStr);
	if (version$1.major === void 0 || below.major === void 0) return void 0;
	if (version$1.major < below.major) return true;
	if (version$1.major > below.major) return false;
	if (version$1.minor === void 0 || below.minor === void 0) if (version$1.major === below.major) return false;
	else return true;
	if (version$1.minor < below.minor) return true;
	if (version$1.minor > below.minor) return false;
	if (version$1.patch === void 0 || below.patch === void 0) if (version$1.minor === below.minor) return false;
	else return true;
	if (version$1.patch < below.patch) return true;
	if (version$1.patch > below.patch) return false;
	if (version$1.patch === below.patch) return false;
}

//#endregion
//#region ../../node_modules/.pnpm/zimmerframe@1.1.2/node_modules/zimmerframe/src/walk.js
/**
* @template {{type: string}} T
* @template {Record<string, any> | null} U
* @param {T} node
* @param {U} state
* @param {import('./types').Visitors<T, U>} visitors
*/
function walk(node, state, visitors) {
	const universal = visitors._;
	let stopped = false;
	/** @type {import('./types').Visitor<T, U, T>} _ */
	function default_visitor(_$1, { next, state: state$1 }) {
		next(state$1);
	}
	/**
	* @param {T} node
	* @param {T[]} path
	* @param {U} state
	* @returns {T | undefined}
	*/
	function visit$6(node$1, path$2, state$1) {
		if (stopped) return;
		if (!node$1.type) return;
		/** @type {T | void} */
		let result;
		/** @type {Record<string, any>} */
		const mutations = {};
		/** @type {import('./types').Context<T, U>} */
		const context = {
			path: path$2,
			state: state$1,
			next: (next_state = state$1) => {
				path$2.push(node$1);
				for (const key in node$1) {
					if (key === "type") continue;
					const child_node = node$1[key];
					if (child_node && typeof child_node === "object") if (Array.isArray(child_node)) {
						/** @type {Record<number, T>} */
						const array_mutations = {};
						child_node.forEach((node$2, i$1) => {
							if (node$2 && typeof node$2 === "object") {
								const result$1 = visit$6(node$2, path$2, next_state);
								if (result$1) array_mutations[i$1] = result$1;
							}
						});
						if (Object.keys(array_mutations).length > 0) mutations[key] = child_node.map((node$2, i$1) => array_mutations[i$1] ?? node$2);
					} else {
						const result$1 = visit$6(child_node, path$2, next_state);
						if (result$1) mutations[key] = result$1;
					}
				}
				path$2.pop();
				if (Object.keys(mutations).length > 0) return apply_mutations(node$1, mutations);
			},
			stop: () => {
				stopped = true;
			},
			visit: (next_node, next_state = state$1) => {
				path$2.push(node$1);
				const result$1 = visit$6(next_node, path$2, next_state) ?? next_node;
				path$2.pop();
				return result$1;
			}
		};
		let visitor = visitors[node$1.type] ?? default_visitor;
		if (universal) {
			/** @type {T | void} */
			let inner_result;
			result = universal(node$1, {
				...context,
				next: (next_state = state$1) => {
					state$1 = next_state;
					inner_result = visitor(node$1, {
						...context,
						state: next_state
					});
					return inner_result;
				}
			});
			if (!result && inner_result) result = inner_result;
		} else result = visitor(node$1, context);
		if (!result) {
			if (Object.keys(mutations).length > 0) result = apply_mutations(node$1, mutations);
		}
		if (result) return result;
	}
	return visit$6(node, [], state) ?? node;
}
/**
* @template {Record<string, any>} T
* @param {T} node
* @param {Record<string, any>} mutations
* @returns {T}
*/
function apply_mutations(node, mutations) {
	/** @type {Record<string, any>} */
	const obj = {};
	const descriptors = Object.getOwnPropertyDescriptors(node);
	for (const key in descriptors) Object.defineProperty(obj, key, descriptors[key]);
	for (const key in mutations) obj[key] = mutations[key];
	return obj;
}

//#endregion
//#region ../../node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/esm/index.js
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function(ElementType$1) {
	/** Type for the root element of a document */
	ElementType$1["Root"] = "root";
	/** Type for Text */
	ElementType$1["Text"] = "text";
	/** Type for <? ... ?> */
	ElementType$1["Directive"] = "directive";
	/** Type for <!-- ... --> */
	ElementType$1["Comment"] = "comment";
	/** Type for <script> tags */
	ElementType$1["Script"] = "script";
	/** Type for <style> tags */
	ElementType$1["Style"] = "style";
	/** Type for Any tag */
	ElementType$1["Tag"] = "tag";
	/** Type for <![CDATA[ ... ]]> */
	ElementType$1["CDATA"] = "cdata";
	/** Type for <!doctype ...> */
	ElementType$1["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
/**
* Tests whether an element is a tag or not.
*
* @param elem Element to test
*/
function isTag(elem) {
	return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
/** Type for the root element of a document */
const Root$8 = ElementType.Root;
/** Type for Text */
const Text$1 = ElementType.Text;
/** Type for <? ... ?> */
const Directive = ElementType.Directive;
/** Type for <!-- ... --> */
const Comment$7 = ElementType.Comment;
/** Type for <script> tags */
const Script = ElementType.Script;
/** Type for <style> tags */
const Style = ElementType.Style;
/** Type for Any tag */
const Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
const CDATA$1 = ElementType.CDATA;
/** Type for <!doctype ...> */
const Doctype = ElementType.Doctype;

//#endregion
//#region ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/node.js
/**
* This object will be used as the prototype for Nodes when creating a
* DOM-Level-1-compliant structure.
*/
var Node$10 = class {
	constructor() {
		/** Parent of the node */
		this.parent = null;
		/** Previous sibling */
		this.prev = null;
		/** Next sibling */
		this.next = null;
		/** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
		this.startIndex = null;
		/** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
		this.endIndex = null;
	}
	/**
	* Same as {@link parent}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get parentNode() {
		return this.parent;
	}
	set parentNode(parent) {
		this.parent = parent;
	}
	/**
	* Same as {@link prev}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get previousSibling() {
		return this.prev;
	}
	set previousSibling(prev) {
		this.prev = prev;
	}
	/**
	* Same as {@link next}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get nextSibling() {
		return this.next;
	}
	set nextSibling(next) {
		this.next = next;
	}
	/**
	* Clone this node, and optionally its children.
	*
	* @param recursive Clone child nodes as well.
	* @returns A clone of the node.
	*/
	cloneNode(recursive = false) {
		return cloneNode$1(this, recursive);
	}
};
/**
* A node that contains some data.
*/
var DataNode = class extends Node$10 {
	/**
	* @param data The content of the data node
	*/
	constructor(data$1) {
		super();
		this.data = data$1;
	}
	/**
	* Same as {@link data}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get nodeValue() {
		return this.data;
	}
	set nodeValue(data$1) {
		this.data = data$1;
	}
};
/**
* Text within the document.
*/
var Text = class extends DataNode {
	constructor() {
		super(...arguments);
		this.type = ElementType.Text;
	}
	get nodeType() {
		return 3;
	}
};
/**
* Comments within the document.
*/
var Comment$6 = class extends DataNode {
	constructor() {
		super(...arguments);
		this.type = ElementType.Comment;
	}
	get nodeType() {
		return 8;
	}
};
/**
* Processing instructions, including doc types.
*/
var ProcessingInstruction = class extends DataNode {
	constructor(name, data$1) {
		super(data$1);
		this.name = name;
		this.type = ElementType.Directive;
	}
	get nodeType() {
		return 1;
	}
};
/**
* A `Node` that can have children.
*/
var NodeWithChildren = class extends Node$10 {
	/**
	* @param children Children of the node. Only certain node types can have children.
	*/
	constructor(children) {
		super();
		this.children = children;
	}
	/** First child of the node. */
	get firstChild() {
		var _a$1;
		return (_a$1 = this.children[0]) !== null && _a$1 !== void 0 ? _a$1 : null;
	}
	/** Last child of the node. */
	get lastChild() {
		return this.children.length > 0 ? this.children[this.children.length - 1] : null;
	}
	/**
	* Same as {@link children}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get childNodes() {
		return this.children;
	}
	set childNodes(children) {
		this.children = children;
	}
};
var CDATA = class extends NodeWithChildren {
	constructor() {
		super(...arguments);
		this.type = ElementType.CDATA;
	}
	get nodeType() {
		return 4;
	}
};
/**
* The root node of the document.
*/
var Document = class extends NodeWithChildren {
	constructor() {
		super(...arguments);
		this.type = ElementType.Root;
	}
	get nodeType() {
		return 9;
	}
};
/**
* An element within the DOM.
*/
var Element = class extends NodeWithChildren {
	/**
	* @param name Name of the tag, eg. `div`, `span`.
	* @param attribs Object mapping attribute names to attribute values.
	* @param children Children of the node.
	*/
	constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
		super(children);
		this.name = name;
		this.attribs = attribs;
		this.type = type;
	}
	get nodeType() {
		return 1;
	}
	/**
	* Same as {@link name}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get tagName() {
		return this.name;
	}
	set tagName(name) {
		this.name = name;
	}
	get attributes() {
		return Object.keys(this.attribs).map((name) => {
			var _a$1, _b;
			return {
				name,
				value: this.attribs[name],
				namespace: (_a$1 = this["x-attribsNamespace"]) === null || _a$1 === void 0 ? void 0 : _a$1[name],
				prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
			};
		});
	}
};
/**
* @param node Node to check.
* @returns `true` if the node is a `Element`, `false` otherwise.
*/
function isTag$1(node) {
	return isTag(node);
}
/**
* @param node Node to check.
* @returns `true` if the node has the type `CDATA`, `false` otherwise.
*/
function isCDATA(node) {
	return node.type === ElementType.CDATA;
}
/**
* @param node Node to check.
* @returns `true` if the node has the type `Text`, `false` otherwise.
*/
function isText(node) {
	return node.type === ElementType.Text;
}
/**
* @param node Node to check.
* @returns `true` if the node has the type `Comment`, `false` otherwise.
*/
function isComment(node) {
	return node.type === ElementType.Comment;
}
/**
* @param node Node to check.
* @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
*/
function isDirective(node) {
	return node.type === ElementType.Directive;
}
/**
* @param node Node to check.
* @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
*/
function isDocument$1(node) {
	return node.type === ElementType.Root;
}
/**
* Clone a node, and optionally its children.
*
* @param recursive Clone child nodes as well.
* @returns A clone of the node.
*/
function cloneNode$1(node, recursive = false) {
	let result;
	if (isText(node)) result = new Text(node.data);
	else if (isComment(node)) result = new Comment$6(node.data);
	else if (isTag$1(node)) {
		const children = recursive ? cloneChildren(node.children) : [];
		const clone = new Element(node.name, { ...node.attribs }, children);
		children.forEach((child) => child.parent = clone);
		if (node.namespace != null) clone.namespace = node.namespace;
		if (node["x-attribsNamespace"]) clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
		if (node["x-attribsPrefix"]) clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
		result = clone;
	} else if (isCDATA(node)) {
		const children = recursive ? cloneChildren(node.children) : [];
		const clone = new CDATA(children);
		children.forEach((child) => child.parent = clone);
		result = clone;
	} else if (isDocument$1(node)) {
		const children = recursive ? cloneChildren(node.children) : [];
		const clone = new Document(children);
		children.forEach((child) => child.parent = clone);
		if (node["x-mode"]) clone["x-mode"] = node["x-mode"];
		result = clone;
	} else if (isDirective(node)) {
		const instruction = new ProcessingInstruction(node.name, node.data);
		if (node["x-name"] != null) {
			instruction["x-name"] = node["x-name"];
			instruction["x-publicId"] = node["x-publicId"];
			instruction["x-systemId"] = node["x-systemId"];
		}
		result = instruction;
	} else throw new Error(`Not implemented yet: ${node.type}`);
	result.startIndex = node.startIndex;
	result.endIndex = node.endIndex;
	if (node.sourceCodeLocation != null) result.sourceCodeLocation = node.sourceCodeLocation;
	return result;
}
function cloneChildren(childs) {
	const children = childs.map((child) => cloneNode$1(child, true));
	for (let i$1 = 1; i$1 < children.length; i$1++) {
		children[i$1].prev = children[i$1 - 1];
		children[i$1 - 1].next = children[i$1];
	}
	return children;
}

//#endregion
//#region ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/index.js
const defaultOpts = {
	withStartIndices: false,
	withEndIndices: false,
	xmlMode: false
};
var DomHandler = class {
	/**
	* @param callback Called once parsing has completed.
	* @param options Settings for the handler.
	* @param elementCB Callback whenever a tag is closed.
	*/
	constructor(callback, options, elementCB) {
		/** The elements of the DOM */
		this.dom = [];
		/** The root element for the DOM */
		this.root = new Document(this.dom);
		/** Indicated whether parsing has been completed. */
		this.done = false;
		/** Stack of open tags. */
		this.tagStack = [this.root];
		/** A data node that is still being written to. */
		this.lastNode = null;
		/** Reference to the parser instance. Used for location information. */
		this.parser = null;
		if (typeof options === "function") {
			elementCB = options;
			options = defaultOpts;
		}
		if (typeof callback === "object") {
			options = callback;
			callback = void 0;
		}
		this.callback = callback !== null && callback !== void 0 ? callback : null;
		this.options = options !== null && options !== void 0 ? options : defaultOpts;
		this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
	}
	onparserinit(parser$2) {
		this.parser = parser$2;
	}
	onreset() {
		this.dom = [];
		this.root = new Document(this.dom);
		this.done = false;
		this.tagStack = [this.root];
		this.lastNode = null;
		this.parser = null;
	}
	onend() {
		if (this.done) return;
		this.done = true;
		this.parser = null;
		this.handleCallback(null);
	}
	onerror(error) {
		this.handleCallback(error);
	}
	onclosetag() {
		this.lastNode = null;
		const elem = this.tagStack.pop();
		if (this.options.withEndIndices) elem.endIndex = this.parser.endIndex;
		if (this.elementCB) this.elementCB(elem);
	}
	onopentag(name, attribs) {
		const type = this.options.xmlMode ? ElementType.Tag : void 0;
		const element = new Element(name, attribs, void 0, type);
		this.addNode(element);
		this.tagStack.push(element);
	}
	ontext(data$1) {
		const { lastNode } = this;
		if (lastNode && lastNode.type === ElementType.Text) {
			lastNode.data += data$1;
			if (this.options.withEndIndices) lastNode.endIndex = this.parser.endIndex;
		} else {
			const node = new Text(data$1);
			this.addNode(node);
			this.lastNode = node;
		}
	}
	oncomment(data$1) {
		if (this.lastNode && this.lastNode.type === ElementType.Comment) {
			this.lastNode.data += data$1;
			return;
		}
		const node = new Comment$6(data$1);
		this.addNode(node);
		this.lastNode = node;
	}
	oncommentend() {
		this.lastNode = null;
	}
	oncdatastart() {
		const text = new Text("");
		const node = new CDATA([text]);
		this.addNode(node);
		text.parent = node;
		this.lastNode = text;
	}
	oncdataend() {
		this.lastNode = null;
	}
	onprocessinginstruction(name, data$1) {
		const node = new ProcessingInstruction(name, data$1);
		this.addNode(node);
	}
	handleCallback(error) {
		if (typeof this.callback === "function") this.callback(error, this.dom);
		else if (error) throw error;
	}
	addNode(node) {
		const parent = this.tagStack[this.tagStack.length - 1];
		const previousSibling = parent.children[parent.children.length - 1];
		if (this.options.withStartIndices) node.startIndex = this.parser.startIndex;
		if (this.options.withEndIndices) node.endIndex = this.parser.endIndex;
		parent.children.push(node);
		if (previousSibling) {
			node.prev = previousSibling;
			previousSibling.next = node;
		}
		node.parent = parent;
		this.lastNode = null;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array("<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT\"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0p\xA0mp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;".split("").map((c$2) => c$2.charCodeAt(0)));

//#endregion
//#region ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array("aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c$2) => c$2.charCodeAt(0)));

//#endregion
//#region ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/decode_codepoint.js
var _a;
const decodeMap = new Map([
	[0, 65533],
	[128, 8364],
	[130, 8218],
	[131, 402],
	[132, 8222],
	[133, 8230],
	[134, 8224],
	[135, 8225],
	[136, 710],
	[137, 8240],
	[138, 352],
	[139, 8249],
	[140, 338],
	[142, 381],
	[145, 8216],
	[146, 8217],
	[147, 8220],
	[148, 8221],
	[149, 8226],
	[150, 8211],
	[151, 8212],
	[152, 732],
	[153, 8482],
	[154, 353],
	[155, 8250],
	[156, 339],
	[158, 382],
	[159, 376]
]);
/**
* Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
*/
const fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
	let output = "";
	if (codePoint > 65535) {
		codePoint -= 65536;
		output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
		codePoint = 56320 | codePoint & 1023;
	}
	output += String.fromCharCode(codePoint);
	return output;
};
/**
* Replace the given code point with a replacement character if it is a
* surrogate or is outside the valid range. Otherwise return the code
* point unchanged.
*/
function replaceCodePoint(codePoint) {
	var _a$1;
	if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) return 65533;
	return (_a$1 = decodeMap.get(codePoint)) !== null && _a$1 !== void 0 ? _a$1 : codePoint;
}

//#endregion
//#region ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/decode.js
var CharCodes$1;
(function(CharCodes$2) {
	CharCodes$2[CharCodes$2["NUM"] = 35] = "NUM";
	CharCodes$2[CharCodes$2["SEMI"] = 59] = "SEMI";
	CharCodes$2[CharCodes$2["EQUALS"] = 61] = "EQUALS";
	CharCodes$2[CharCodes$2["ZERO"] = 48] = "ZERO";
	CharCodes$2[CharCodes$2["NINE"] = 57] = "NINE";
	CharCodes$2[CharCodes$2["LOWER_A"] = 97] = "LOWER_A";
	CharCodes$2[CharCodes$2["LOWER_F"] = 102] = "LOWER_F";
	CharCodes$2[CharCodes$2["LOWER_X"] = 120] = "LOWER_X";
	CharCodes$2[CharCodes$2["LOWER_Z"] = 122] = "LOWER_Z";
	CharCodes$2[CharCodes$2["UPPER_A"] = 65] = "UPPER_A";
	CharCodes$2[CharCodes$2["UPPER_F"] = 70] = "UPPER_F";
	CharCodes$2[CharCodes$2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes$1 || (CharCodes$1 = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags$1) {
	BinTrieFlags$1[BinTrieFlags$1["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
	BinTrieFlags$1[BinTrieFlags$1["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
	BinTrieFlags$1[BinTrieFlags$1["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
	return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
}
function isHexadecimalCharacter(code) {
	return code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F || code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
	return code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z || code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z || isNumber(code);
}
/**
* Checks if the given character is a valid end character for an entity in an attribute.
*
* Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
* See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
*/
function isEntityInAttributeInvalidEnd(code) {
	return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState$1) {
	EntityDecoderState$1[EntityDecoderState$1["EntityStart"] = 0] = "EntityStart";
	EntityDecoderState$1[EntityDecoderState$1["NumericStart"] = 1] = "NumericStart";
	EntityDecoderState$1[EntityDecoderState$1["NumericDecimal"] = 2] = "NumericDecimal";
	EntityDecoderState$1[EntityDecoderState$1["NumericHex"] = 3] = "NumericHex";
	EntityDecoderState$1[EntityDecoderState$1["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode$1) {
	/** Entities in text nodes that can end with any character. */
	DecodingMode$1[DecodingMode$1["Legacy"] = 0] = "Legacy";
	/** Only allow entities terminated with a semicolon. */
	DecodingMode$1[DecodingMode$1["Strict"] = 1] = "Strict";
	/** Entities in attributes have limitations on ending characters. */
	DecodingMode$1[DecodingMode$1["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
/**
* Token decoder with support of writing partial entities.
*/
var EntityDecoder = class {
	constructor(decodeTree, emitCodePoint, errors$4) {
		this.decodeTree = decodeTree;
		this.emitCodePoint = emitCodePoint;
		this.errors = errors$4;
		/** The current state of the decoder. */
		this.state = EntityDecoderState.EntityStart;
		/** Characters that were consumed while parsing an entity. */
		this.consumed = 1;
		/**
		* The result of the entity.
		*
		* Either the result index of a numeric entity, or the codepoint of a
		* numeric entity.
		*/
		this.result = 0;
		/** The current index in the decode tree. */
		this.treeIndex = 0;
		/** The number of characters that were consumed in excess. */
		this.excess = 1;
		/** The mode in which the decoder is operating. */
		this.decodeMode = DecodingMode.Strict;
	}
	/** Resets the instance to make it reusable. */
	startEntity(decodeMode) {
		this.decodeMode = decodeMode;
		this.state = EntityDecoderState.EntityStart;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.consumed = 1;
	}
	/**
	* Write an entity to the decoder. This can be called multiple times with partial entities.
	* If the entity is incomplete, the decoder will return -1.
	*
	* Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
	* entity is incomplete, and resume when the next string is written.
	*
	* @param string The string containing the entity (or a continuation of the entity).
	* @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	write(str, offset) {
		switch (this.state) {
			case EntityDecoderState.EntityStart:
				if (str.charCodeAt(offset) === CharCodes$1.NUM) {
					this.state = EntityDecoderState.NumericStart;
					this.consumed += 1;
					return this.stateNumericStart(str, offset + 1);
				}
				this.state = EntityDecoderState.NamedEntity;
				return this.stateNamedEntity(str, offset);
			case EntityDecoderState.NumericStart: return this.stateNumericStart(str, offset);
			case EntityDecoderState.NumericDecimal: return this.stateNumericDecimal(str, offset);
			case EntityDecoderState.NumericHex: return this.stateNumericHex(str, offset);
			case EntityDecoderState.NamedEntity: return this.stateNamedEntity(str, offset);
		}
	}
	/**
	* Switches between the numeric decimal and hexadecimal states.
	*
	* Equivalent to the `Numeric character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericStart(str, offset) {
		if (offset >= str.length) return -1;
		if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
			this.state = EntityDecoderState.NumericHex;
			this.consumed += 1;
			return this.stateNumericHex(str, offset + 1);
		}
		this.state = EntityDecoderState.NumericDecimal;
		return this.stateNumericDecimal(str, offset);
	}
	addToNumericResult(str, start, end, base) {
		if (start !== end) {
			const digitCount = end - start;
			this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
			this.consumed += digitCount;
		}
	}
	/**
	* Parses a hexadecimal numeric entity.
	*
	* Equivalent to the `Hexademical character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericHex(str, offset) {
		const startIdx = offset;
		while (offset < str.length) {
			const char = str.charCodeAt(offset);
			if (isNumber(char) || isHexadecimalCharacter(char)) offset += 1;
			else {
				this.addToNumericResult(str, startIdx, offset, 16);
				return this.emitNumericEntity(char, 3);
			}
		}
		this.addToNumericResult(str, startIdx, offset, 16);
		return -1;
	}
	/**
	* Parses a decimal numeric entity.
	*
	* Equivalent to the `Decimal character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericDecimal(str, offset) {
		const startIdx = offset;
		while (offset < str.length) {
			const char = str.charCodeAt(offset);
			if (isNumber(char)) offset += 1;
			else {
				this.addToNumericResult(str, startIdx, offset, 10);
				return this.emitNumericEntity(char, 2);
			}
		}
		this.addToNumericResult(str, startIdx, offset, 10);
		return -1;
	}
	/**
	* Validate and emit a numeric entity.
	*
	* Implements the logic from the `Hexademical character reference start
	* state` and `Numeric character reference end state` in the HTML spec.
	*
	* @param lastCp The last code point of the entity. Used to see if the
	*               entity was terminated with a semicolon.
	* @param expectedLength The minimum number of characters that should be
	*                       consumed. Used to validate that at least one digit
	*                       was consumed.
	* @returns The number of characters that were consumed.
	*/
	emitNumericEntity(lastCp, expectedLength) {
		var _a$1;
		if (this.consumed <= expectedLength) {
			(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
			return 0;
		}
		if (lastCp === CharCodes$1.SEMI) this.consumed += 1;
		else if (this.decodeMode === DecodingMode.Strict) return 0;
		this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
		if (this.errors) {
			if (lastCp !== CharCodes$1.SEMI) this.errors.missingSemicolonAfterCharacterReference();
			this.errors.validateNumericCharacterReference(this.result);
		}
		return this.consumed;
	}
	/**
	* Parses a named entity.
	*
	* Equivalent to the `Named character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNamedEntity(str, offset) {
		const { decodeTree } = this;
		let current = decodeTree[this.treeIndex];
		let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		for (; offset < str.length; offset++, this.excess++) {
			const char = str.charCodeAt(offset);
			this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			if (this.treeIndex < 0) return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
			current = decodeTree[this.treeIndex];
			valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			if (valueLength !== 0) {
				if (char === CharCodes$1.SEMI) return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
				if (this.decodeMode !== DecodingMode.Strict) {
					this.result = this.treeIndex;
					this.consumed += this.excess;
					this.excess = 0;
				}
			}
		}
		return -1;
	}
	/**
	* Emit a named entity that was not terminated with a semicolon.
	*
	* @returns The number of characters consumed.
	*/
	emitNotTerminatedNamedEntity() {
		var _a$1;
		const { result, decodeTree } = this;
		const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		this.emitNamedEntityData(result, valueLength, this.consumed);
		(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.missingSemicolonAfterCharacterReference();
		return this.consumed;
	}
	/**
	* Emit a named entity.
	*
	* @param result The index of the entity in the decode tree.
	* @param valueLength The number of bytes in the entity.
	* @param consumed The number of characters consumed.
	*
	* @returns The number of characters consumed.
	*/
	emitNamedEntityData(result, valueLength, consumed) {
		const { decodeTree } = this;
		this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
		if (valueLength === 3) this.emitCodePoint(decodeTree[result + 2], consumed);
		return consumed;
	}
	/**
	* Signal to the parser that the end of the input was reached.
	*
	* Remaining data will be emitted and relevant errors will be produced.
	*
	* @returns The number of characters consumed.
	*/
	end() {
		var _a$1;
		switch (this.state) {
			case EntityDecoderState.NamedEntity: return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
			case EntityDecoderState.NumericDecimal: return this.emitNumericEntity(0, 2);
			case EntityDecoderState.NumericHex: return this.emitNumericEntity(0, 3);
			case EntityDecoderState.NumericStart:
				(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			case EntityDecoderState.EntityStart: return 0;
		}
	}
};
/**
* Creates a function that decodes entities in a string.
*
* @param decodeTree The decode tree.
* @returns A function that decodes entities in a string.
*/
function getDecoder(decodeTree) {
	let ret = "";
	const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
	return function decodeWithTrie(str, decodeMode) {
		let lastIndex = 0;
		let offset = 0;
		while ((offset = str.indexOf("&", offset)) >= 0) {
			ret += str.slice(lastIndex, offset);
			decoder.startEntity(decodeMode);
			const len = decoder.write(str, offset + 1);
			if (len < 0) {
				lastIndex = offset + decoder.end();
				break;
			}
			lastIndex = offset + len;
			offset = len === 0 ? lastIndex + 1 : lastIndex;
		}
		const result = ret + str.slice(lastIndex);
		ret = "";
		return result;
	};
}
/**
* Determines the branch of the current node that is taken given the current
* character. This function is used to traverse the trie.
*
* @param decodeTree The trie.
* @param current The current node.
* @param nodeIdx The index right after the current node and its value.
* @param char The current character.
* @returns The index of the next node, or -1 if no branch is taken.
*/
function determineBranch(decodeTree, current, nodeIdx, char) {
	const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
	const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
	if (branchCount === 0) return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
	if (jumpOffset) {
		const value = char - jumpOffset;
		return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
	}
	let lo = nodeIdx;
	let hi = lo + branchCount - 1;
	while (lo <= hi) {
		const mid = lo + hi >>> 1;
		const midVal = decodeTree[mid];
		if (midVal < char) lo = mid + 1;
		else if (midVal > char) hi = mid - 1;
		else return decodeTree[mid + branchCount];
	}
	return -1;
}
const htmlDecoder = getDecoder(decode_data_html_default);
const xmlDecoder = getDecoder(decode_data_xml_default);

//#endregion
//#region ../../node_modules/.pnpm/htmlparser2@9.1.0/node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes;
(function(CharCodes$2) {
	CharCodes$2[CharCodes$2["Tab"] = 9] = "Tab";
	CharCodes$2[CharCodes$2["NewLine"] = 10] = "NewLine";
	CharCodes$2[CharCodes$2["FormFeed"] = 12] = "FormFeed";
	CharCodes$2[CharCodes$2["CarriageReturn"] = 13] = "CarriageReturn";
	CharCodes$2[CharCodes$2["Space"] = 32] = "Space";
	CharCodes$2[CharCodes$2["ExclamationMark"] = 33] = "ExclamationMark";
	CharCodes$2[CharCodes$2["Number"] = 35] = "Number";
	CharCodes$2[CharCodes$2["Amp"] = 38] = "Amp";
	CharCodes$2[CharCodes$2["SingleQuote"] = 39] = "SingleQuote";
	CharCodes$2[CharCodes$2["DoubleQuote"] = 34] = "DoubleQuote";
	CharCodes$2[CharCodes$2["Dash"] = 45] = "Dash";
	CharCodes$2[CharCodes$2["Slash"] = 47] = "Slash";
	CharCodes$2[CharCodes$2["Zero"] = 48] = "Zero";
	CharCodes$2[CharCodes$2["Nine"] = 57] = "Nine";
	CharCodes$2[CharCodes$2["Semi"] = 59] = "Semi";
	CharCodes$2[CharCodes$2["Lt"] = 60] = "Lt";
	CharCodes$2[CharCodes$2["Eq"] = 61] = "Eq";
	CharCodes$2[CharCodes$2["Gt"] = 62] = "Gt";
	CharCodes$2[CharCodes$2["Questionmark"] = 63] = "Questionmark";
	CharCodes$2[CharCodes$2["UpperA"] = 65] = "UpperA";
	CharCodes$2[CharCodes$2["LowerA"] = 97] = "LowerA";
	CharCodes$2[CharCodes$2["UpperF"] = 70] = "UpperF";
	CharCodes$2[CharCodes$2["LowerF"] = 102] = "LowerF";
	CharCodes$2[CharCodes$2["UpperZ"] = 90] = "UpperZ";
	CharCodes$2[CharCodes$2["LowerZ"] = 122] = "LowerZ";
	CharCodes$2[CharCodes$2["LowerX"] = 120] = "LowerX";
	CharCodes$2[CharCodes$2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function(State$1) {
	State$1[State$1["Text"] = 1] = "Text";
	State$1[State$1["BeforeTagName"] = 2] = "BeforeTagName";
	State$1[State$1["InTagName"] = 3] = "InTagName";
	State$1[State$1["InSelfClosingTag"] = 4] = "InSelfClosingTag";
	State$1[State$1["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
	State$1[State$1["InClosingTagName"] = 6] = "InClosingTagName";
	State$1[State$1["AfterClosingTagName"] = 7] = "AfterClosingTagName";
	State$1[State$1["BeforeAttributeName"] = 8] = "BeforeAttributeName";
	State$1[State$1["InAttributeName"] = 9] = "InAttributeName";
	State$1[State$1["AfterAttributeName"] = 10] = "AfterAttributeName";
	State$1[State$1["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
	State$1[State$1["InAttributeValueDq"] = 12] = "InAttributeValueDq";
	State$1[State$1["InAttributeValueSq"] = 13] = "InAttributeValueSq";
	State$1[State$1["InAttributeValueNq"] = 14] = "InAttributeValueNq";
	State$1[State$1["BeforeDeclaration"] = 15] = "BeforeDeclaration";
	State$1[State$1["InDeclaration"] = 16] = "InDeclaration";
	State$1[State$1["InProcessingInstruction"] = 17] = "InProcessingInstruction";
	State$1[State$1["BeforeComment"] = 18] = "BeforeComment";
	State$1[State$1["CDATASequence"] = 19] = "CDATASequence";
	State$1[State$1["InSpecialComment"] = 20] = "InSpecialComment";
	State$1[State$1["InCommentLike"] = 21] = "InCommentLike";
	State$1[State$1["BeforeSpecialS"] = 22] = "BeforeSpecialS";
	State$1[State$1["BeforeSpecialT"] = 23] = "BeforeSpecialT";
	State$1[State$1["SpecialStartSequence"] = 24] = "SpecialStartSequence";
	State$1[State$1["InSpecialTag"] = 25] = "InSpecialTag";
	State$1[State$1["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace(c$2) {
	return c$2 === CharCodes.Space || c$2 === CharCodes.NewLine || c$2 === CharCodes.Tab || c$2 === CharCodes.FormFeed || c$2 === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c$2) {
	return c$2 === CharCodes.Slash || c$2 === CharCodes.Gt || isWhitespace(c$2);
}
function isASCIIAlpha(c$2) {
	return c$2 >= CharCodes.LowerA && c$2 <= CharCodes.LowerZ || c$2 >= CharCodes.UpperA && c$2 <= CharCodes.UpperZ;
}
var QuoteType;
(function(QuoteType$1) {
	QuoteType$1[QuoteType$1["NoValue"] = 0] = "NoValue";
	QuoteType$1[QuoteType$1["Unquoted"] = 1] = "Unquoted";
	QuoteType$1[QuoteType$1["Single"] = 2] = "Single";
	QuoteType$1[QuoteType$1["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
/**
* Sequences used to match longer strings.
*
* We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
* sequences with an increased offset.
*/
const Sequences = {
	Cdata: new Uint8Array([
		67,
		68,
		65,
		84,
		65,
		91
	]),
	CdataEnd: new Uint8Array([
		93,
		93,
		62
	]),
	CommentEnd: new Uint8Array([
		45,
		45,
		62
	]),
	ScriptEnd: new Uint8Array([
		60,
		47,
		115,
		99,
		114,
		105,
		112,
		116
	]),
	StyleEnd: new Uint8Array([
		60,
		47,
		115,
		116,
		121,
		108,
		101
	]),
	TitleEnd: new Uint8Array([
		60,
		47,
		116,
		105,
		116,
		108,
		101
	]),
	TextareaEnd: new Uint8Array([
		60,
		47,
		116,
		101,
		120,
		116,
		97,
		114,
		101,
		97
	])
};
var Tokenizer = class {
	constructor({ xmlMode = false, decodeEntities = true }, cbs) {
		this.cbs = cbs;
		/** The current state the tokenizer is in. */
		this.state = State.Text;
		/** The read buffer. */
		this.buffer = "";
		/** The beginning of the section that is currently being read. */
		this.sectionStart = 0;
		/** The index within the buffer that we are currently looking at. */
		this.index = 0;
		/** The start of the last entity. */
		this.entityStart = 0;
		/** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
		this.baseState = State.Text;
		/** For special parsing behavior inside of script and style tags. */
		this.isSpecial = false;
		/** Indicates whether the tokenizer has been paused. */
		this.running = true;
		/** The offset of the current buffer. */
		this.offset = 0;
		this.currentSequence = void 0;
		this.sequenceIndex = 0;
		this.xmlMode = xmlMode;
		this.decodeEntities = decodeEntities;
		this.entityDecoder = new EntityDecoder(xmlMode ? decode_data_xml_default : decode_data_html_default, (cp, consumed) => this.emitCodePoint(cp, consumed));
	}
	reset() {
		this.state = State.Text;
		this.buffer = "";
		this.sectionStart = 0;
		this.index = 0;
		this.baseState = State.Text;
		this.currentSequence = void 0;
		this.running = true;
		this.offset = 0;
	}
	write(chunk) {
		this.offset += this.buffer.length;
		this.buffer = chunk;
		this.parse();
	}
	end() {
		if (this.running) this.finish();
	}
	pause() {
		this.running = false;
	}
	resume() {
		this.running = true;
		if (this.index < this.buffer.length + this.offset) this.parse();
	}
	stateText(c$2) {
		if (c$2 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
			if (this.index > this.sectionStart) this.cbs.ontext(this.sectionStart, this.index);
			this.state = State.BeforeTagName;
			this.sectionStart = this.index;
		} else if (this.decodeEntities && c$2 === CharCodes.Amp) this.startEntity();
	}
	stateSpecialStartSequence(c$2) {
		const isEnd = this.sequenceIndex === this.currentSequence.length;
		if (!(isEnd ? isEndOfTagSection(c$2) : (c$2 | 32) === this.currentSequence[this.sequenceIndex])) this.isSpecial = false;
		else if (!isEnd) {
			this.sequenceIndex++;
			return;
		}
		this.sequenceIndex = 0;
		this.state = State.InTagName;
		this.stateInTagName(c$2);
	}
	/** Look for an end tag. For <title> tags, also decode entities. */
	stateInSpecialTag(c$2) {
		if (this.sequenceIndex === this.currentSequence.length) {
			if (c$2 === CharCodes.Gt || isWhitespace(c$2)) {
				const endOfText = this.index - this.currentSequence.length;
				if (this.sectionStart < endOfText) {
					const actualIndex = this.index;
					this.index = endOfText;
					this.cbs.ontext(this.sectionStart, endOfText);
					this.index = actualIndex;
				}
				this.isSpecial = false;
				this.sectionStart = endOfText + 2;
				this.stateInClosingTagName(c$2);
				return;
			}
			this.sequenceIndex = 0;
		}
		if ((c$2 | 32) === this.currentSequence[this.sequenceIndex]) this.sequenceIndex += 1;
		else if (this.sequenceIndex === 0) {
			if (this.currentSequence === Sequences.TitleEnd) {
				if (this.decodeEntities && c$2 === CharCodes.Amp) this.startEntity();
			} else if (this.fastForwardTo(CharCodes.Lt)) this.sequenceIndex = 1;
		} else this.sequenceIndex = Number(c$2 === CharCodes.Lt);
	}
	stateCDATASequence(c$2) {
		if (c$2 === Sequences.Cdata[this.sequenceIndex]) {
			if (++this.sequenceIndex === Sequences.Cdata.length) {
				this.state = State.InCommentLike;
				this.currentSequence = Sequences.CdataEnd;
				this.sequenceIndex = 0;
				this.sectionStart = this.index + 1;
			}
		} else {
			this.sequenceIndex = 0;
			this.state = State.InDeclaration;
			this.stateInDeclaration(c$2);
		}
	}
	/**
	* When we wait for one specific character, we can speed things up
	* by skipping through the buffer until we find it.
	*
	* @returns Whether the character was found.
	*/
	fastForwardTo(c$2) {
		while (++this.index < this.buffer.length + this.offset) if (this.buffer.charCodeAt(this.index - this.offset) === c$2) return true;
		this.index = this.buffer.length + this.offset - 1;
		return false;
	}
	/**
	* Comments and CDATA end with `-->` and `]]>`.
	*
	* Their common qualities are:
	* - Their end sequences have a distinct character they start with.
	* - That character is then repeated, so we have to check multiple repeats.
	* - All characters but the start character of the sequence can be skipped.
	*/
	stateInCommentLike(c$2) {
		if (c$2 === this.currentSequence[this.sequenceIndex]) {
			if (++this.sequenceIndex === this.currentSequence.length) {
				if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, this.index, 2);
				else this.cbs.oncomment(this.sectionStart, this.index, 2);
				this.sequenceIndex = 0;
				this.sectionStart = this.index + 1;
				this.state = State.Text;
			}
		} else if (this.sequenceIndex === 0) {
			if (this.fastForwardTo(this.currentSequence[0])) this.sequenceIndex = 1;
		} else if (c$2 !== this.currentSequence[this.sequenceIndex - 1]) this.sequenceIndex = 0;
	}
	/**
	* HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
	*
	* XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
	* We allow anything that wouldn't end the tag.
	*/
	isTagStartChar(c$2) {
		return this.xmlMode ? !isEndOfTagSection(c$2) : isASCIIAlpha(c$2);
	}
	startSpecial(sequence$1, offset) {
		this.isSpecial = true;
		this.currentSequence = sequence$1;
		this.sequenceIndex = offset;
		this.state = State.SpecialStartSequence;
	}
	stateBeforeTagName(c$2) {
		if (c$2 === CharCodes.ExclamationMark) {
			this.state = State.BeforeDeclaration;
			this.sectionStart = this.index + 1;
		} else if (c$2 === CharCodes.Questionmark) {
			this.state = State.InProcessingInstruction;
			this.sectionStart = this.index + 1;
		} else if (this.isTagStartChar(c$2)) {
			const lower = c$2 | 32;
			this.sectionStart = this.index;
			if (this.xmlMode) this.state = State.InTagName;
			else if (lower === Sequences.ScriptEnd[2]) this.state = State.BeforeSpecialS;
			else if (lower === Sequences.TitleEnd[2]) this.state = State.BeforeSpecialT;
			else this.state = State.InTagName;
		} else if (c$2 === CharCodes.Slash) this.state = State.BeforeClosingTagName;
		else {
			this.state = State.Text;
			this.stateText(c$2);
		}
	}
	stateInTagName(c$2) {
		if (isEndOfTagSection(c$2)) {
			this.cbs.onopentagname(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$2);
		}
	}
	stateBeforeClosingTagName(c$2) {
		if (isWhitespace(c$2)) {} else if (c$2 === CharCodes.Gt) this.state = State.Text;
		else {
			this.state = this.isTagStartChar(c$2) ? State.InClosingTagName : State.InSpecialComment;
			this.sectionStart = this.index;
		}
	}
	stateInClosingTagName(c$2) {
		if (c$2 === CharCodes.Gt || isWhitespace(c$2)) {
			this.cbs.onclosetag(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.state = State.AfterClosingTagName;
			this.stateAfterClosingTagName(c$2);
		}
	}
	stateAfterClosingTagName(c$2) {
		if (c$2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeAttributeName(c$2) {
		if (c$2 === CharCodes.Gt) {
			this.cbs.onopentagend(this.index);
			if (this.isSpecial) {
				this.state = State.InSpecialTag;
				this.sequenceIndex = 0;
			} else this.state = State.Text;
			this.sectionStart = this.index + 1;
		} else if (c$2 === CharCodes.Slash) this.state = State.InSelfClosingTag;
		else if (!isWhitespace(c$2)) {
			this.state = State.InAttributeName;
			this.sectionStart = this.index;
		}
	}
	stateInSelfClosingTag(c$2) {
		if (c$2 === CharCodes.Gt) {
			this.cbs.onselfclosingtag(this.index);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
			this.isSpecial = false;
		} else if (!isWhitespace(c$2)) {
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$2);
		}
	}
	stateInAttributeName(c$2) {
		if (c$2 === CharCodes.Eq || isEndOfTagSection(c$2)) {
			this.cbs.onattribname(this.sectionStart, this.index);
			this.sectionStart = this.index;
			this.state = State.AfterAttributeName;
			this.stateAfterAttributeName(c$2);
		}
	}
	stateAfterAttributeName(c$2) {
		if (c$2 === CharCodes.Eq) this.state = State.BeforeAttributeValue;
		else if (c$2 === CharCodes.Slash || c$2 === CharCodes.Gt) {
			this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
			this.sectionStart = -1;
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$2);
		} else if (!isWhitespace(c$2)) {
			this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
			this.state = State.InAttributeName;
			this.sectionStart = this.index;
		}
	}
	stateBeforeAttributeValue(c$2) {
		if (c$2 === CharCodes.DoubleQuote) {
			this.state = State.InAttributeValueDq;
			this.sectionStart = this.index + 1;
		} else if (c$2 === CharCodes.SingleQuote) {
			this.state = State.InAttributeValueSq;
			this.sectionStart = this.index + 1;
		} else if (!isWhitespace(c$2)) {
			this.sectionStart = this.index;
			this.state = State.InAttributeValueNq;
			this.stateInAttributeValueNoQuotes(c$2);
		}
	}
	handleInAttributeValue(c$2, quote$1) {
		if (c$2 === quote$1 || !this.decodeEntities && this.fastForwardTo(quote$1)) {
			this.cbs.onattribdata(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.cbs.onattribend(quote$1 === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
			this.state = State.BeforeAttributeName;
		} else if (this.decodeEntities && c$2 === CharCodes.Amp) this.startEntity();
	}
	stateInAttributeValueDoubleQuotes(c$2) {
		this.handleInAttributeValue(c$2, CharCodes.DoubleQuote);
	}
	stateInAttributeValueSingleQuotes(c$2) {
		this.handleInAttributeValue(c$2, CharCodes.SingleQuote);
	}
	stateInAttributeValueNoQuotes(c$2) {
		if (isWhitespace(c$2) || c$2 === CharCodes.Gt) {
			this.cbs.onattribdata(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.cbs.onattribend(QuoteType.Unquoted, this.index);
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$2);
		} else if (this.decodeEntities && c$2 === CharCodes.Amp) this.startEntity();
	}
	stateBeforeDeclaration(c$2) {
		if (c$2 === CharCodes.OpeningSquareBracket) {
			this.state = State.CDATASequence;
			this.sequenceIndex = 0;
		} else this.state = c$2 === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
	}
	stateInDeclaration(c$2) {
		if (c$2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.cbs.ondeclaration(this.sectionStart, this.index);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateInProcessingInstruction(c$2) {
		if (c$2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.cbs.onprocessinginstruction(this.sectionStart, this.index);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeComment(c$2) {
		if (c$2 === CharCodes.Dash) {
			this.state = State.InCommentLike;
			this.currentSequence = Sequences.CommentEnd;
			this.sequenceIndex = 2;
			this.sectionStart = this.index + 1;
		} else this.state = State.InDeclaration;
	}
	stateInSpecialComment(c$2) {
		if (c$2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.cbs.oncomment(this.sectionStart, this.index, 0);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeSpecialS(c$2) {
		const lower = c$2 | 32;
		if (lower === Sequences.ScriptEnd[3]) this.startSpecial(Sequences.ScriptEnd, 4);
		else if (lower === Sequences.StyleEnd[3]) this.startSpecial(Sequences.StyleEnd, 4);
		else {
			this.state = State.InTagName;
			this.stateInTagName(c$2);
		}
	}
	stateBeforeSpecialT(c$2) {
		const lower = c$2 | 32;
		if (lower === Sequences.TitleEnd[3]) this.startSpecial(Sequences.TitleEnd, 4);
		else if (lower === Sequences.TextareaEnd[3]) this.startSpecial(Sequences.TextareaEnd, 4);
		else {
			this.state = State.InTagName;
			this.stateInTagName(c$2);
		}
	}
	startEntity() {
		this.baseState = this.state;
		this.state = State.InEntity;
		this.entityStart = this.index;
		this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
	}
	stateInEntity() {
		const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
		if (length >= 0) {
			this.state = this.baseState;
			if (length === 0) this.index = this.entityStart;
		} else this.index = this.offset + this.buffer.length - 1;
	}
	/**
	* Remove data that has already been consumed from the buffer.
	*/
	cleanup() {
		if (this.running && this.sectionStart !== this.index) {
			if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
				this.cbs.ontext(this.sectionStart, this.index);
				this.sectionStart = this.index;
			} else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = this.index;
			}
		}
	}
	shouldContinue() {
		return this.index < this.buffer.length + this.offset && this.running;
	}
	/**
	* Iterates through the buffer, calling the function corresponding to the current state.
	*
	* States that are more likely to be hit are higher up, as a performance improvement.
	*/
	parse() {
		while (this.shouldContinue()) {
			const c$2 = this.buffer.charCodeAt(this.index - this.offset);
			switch (this.state) {
				case State.Text:
					this.stateText(c$2);
					break;
				case State.SpecialStartSequence:
					this.stateSpecialStartSequence(c$2);
					break;
				case State.InSpecialTag:
					this.stateInSpecialTag(c$2);
					break;
				case State.CDATASequence:
					this.stateCDATASequence(c$2);
					break;
				case State.InAttributeValueDq:
					this.stateInAttributeValueDoubleQuotes(c$2);
					break;
				case State.InAttributeName:
					this.stateInAttributeName(c$2);
					break;
				case State.InCommentLike:
					this.stateInCommentLike(c$2);
					break;
				case State.InSpecialComment:
					this.stateInSpecialComment(c$2);
					break;
				case State.BeforeAttributeName:
					this.stateBeforeAttributeName(c$2);
					break;
				case State.InTagName:
					this.stateInTagName(c$2);
					break;
				case State.InClosingTagName:
					this.stateInClosingTagName(c$2);
					break;
				case State.BeforeTagName:
					this.stateBeforeTagName(c$2);
					break;
				case State.AfterAttributeName:
					this.stateAfterAttributeName(c$2);
					break;
				case State.InAttributeValueSq:
					this.stateInAttributeValueSingleQuotes(c$2);
					break;
				case State.BeforeAttributeValue:
					this.stateBeforeAttributeValue(c$2);
					break;
				case State.BeforeClosingTagName:
					this.stateBeforeClosingTagName(c$2);
					break;
				case State.AfterClosingTagName:
					this.stateAfterClosingTagName(c$2);
					break;
				case State.BeforeSpecialS:
					this.stateBeforeSpecialS(c$2);
					break;
				case State.BeforeSpecialT:
					this.stateBeforeSpecialT(c$2);
					break;
				case State.InAttributeValueNq:
					this.stateInAttributeValueNoQuotes(c$2);
					break;
				case State.InSelfClosingTag:
					this.stateInSelfClosingTag(c$2);
					break;
				case State.InDeclaration:
					this.stateInDeclaration(c$2);
					break;
				case State.BeforeDeclaration:
					this.stateBeforeDeclaration(c$2);
					break;
				case State.BeforeComment:
					this.stateBeforeComment(c$2);
					break;
				case State.InProcessingInstruction:
					this.stateInProcessingInstruction(c$2);
					break;
				case State.InEntity:
					this.stateInEntity();
					break;
			}
			this.index++;
		}
		this.cleanup();
	}
	finish() {
		if (this.state === State.InEntity) {
			this.entityDecoder.end();
			this.state = this.baseState;
		}
		this.handleTrailingData();
		this.cbs.onend();
	}
	/** Handle any trailing data. */
	handleTrailingData() {
		const endIndex = this.buffer.length + this.offset;
		if (this.sectionStart >= endIndex) return;
		if (this.state === State.InCommentLike) if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, endIndex, 0);
		else this.cbs.oncomment(this.sectionStart, endIndex, 0);
		else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {} else this.cbs.ontext(this.sectionStart, endIndex);
	}
	emitCodePoint(cp, consumed) {
		if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
			if (this.sectionStart < this.entityStart) this.cbs.onattribdata(this.sectionStart, this.entityStart);
			this.sectionStart = this.entityStart + consumed;
			this.index = this.sectionStart - 1;
			this.cbs.onattribentity(cp);
		} else {
			if (this.sectionStart < this.entityStart) this.cbs.ontext(this.sectionStart, this.entityStart);
			this.sectionStart = this.entityStart + consumed;
			this.index = this.sectionStart - 1;
			this.cbs.ontextentity(cp, this.sectionStart);
		}
	}
};

//#endregion
//#region ../../node_modules/.pnpm/htmlparser2@9.1.0/node_modules/htmlparser2/lib/esm/Parser.js
const formTags = new Set([
	"input",
	"option",
	"optgroup",
	"select",
	"button",
	"datalist",
	"textarea"
]);
const pTag = new Set(["p"]);
const tableSectionTags = new Set(["thead", "tbody"]);
const ddtTags = new Set(["dd", "dt"]);
const rtpTags = new Set(["rt", "rp"]);
const openImpliesClose = new Map([
	["tr", new Set([
		"tr",
		"th",
		"td"
	])],
	["th", new Set(["th"])],
	["td", new Set([
		"thead",
		"th",
		"td"
	])],
	["body", new Set([
		"head",
		"link",
		"script"
	])],
	["li", new Set(["li"])],
	["p", pTag],
	["h1", pTag],
	["h2", pTag],
	["h3", pTag],
	["h4", pTag],
	["h5", pTag],
	["h6", pTag],
	["select", formTags],
	["input", formTags],
	["output", formTags],
	["button", formTags],
	["datalist", formTags],
	["textarea", formTags],
	["option", new Set(["option"])],
	["optgroup", new Set(["optgroup", "option"])],
	["dd", ddtTags],
	["dt", ddtTags],
	["address", pTag],
	["article", pTag],
	["aside", pTag],
	["blockquote", pTag],
	["details", pTag],
	["div", pTag],
	["dl", pTag],
	["fieldset", pTag],
	["figcaption", pTag],
	["figure", pTag],
	["footer", pTag],
	["form", pTag],
	["header", pTag],
	["hr", pTag],
	["main", pTag],
	["nav", pTag],
	["ol", pTag],
	["pre", pTag],
	["section", pTag],
	["table", pTag],
	["ul", pTag],
	["rt", rtpTags],
	["rp", rtpTags],
	["tbody", tableSectionTags],
	["tfoot", tableSectionTags]
]);
const voidElements = new Set([
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
]);
const foreignContextElements = new Set(["math", "svg"]);
const htmlIntegrationElements = new Set([
	"mi",
	"mo",
	"mn",
	"ms",
	"mtext",
	"annotation-xml",
	"foreignobject",
	"desc",
	"title"
]);
const reNameEnd = /\s|\//;
var Parser$4 = class {
	constructor(cbs, options = {}) {
		var _a$1, _b, _c, _d, _e, _f;
		this.options = options;
		/** The start index of the last event. */
		this.startIndex = 0;
		/** The end index of the last event. */
		this.endIndex = 0;
		/**
		* Store the start index of the current open tag,
		* so we can update the start index for attributes.
		*/
		this.openTagStart = 0;
		this.tagname = "";
		this.attribname = "";
		this.attribvalue = "";
		this.attribs = null;
		this.stack = [];
		this.buffers = [];
		this.bufferOffset = 0;
		/** The index of the last written buffer. Used when resuming after a `pause()`. */
		this.writeIndex = 0;
		/** Indicates whether the parser has finished running / `.end` has been called. */
		this.ended = false;
		this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
		this.htmlMode = !this.options.xmlMode;
		this.lowerCaseTagNames = (_a$1 = options.lowerCaseTags) !== null && _a$1 !== void 0 ? _a$1 : this.htmlMode;
		this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
		this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
		this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
		this.foreignContext = [!this.htmlMode];
		(_f = (_e = this.cbs).onparserinit) === null || _f === void 0 || _f.call(_e, this);
	}
	/** @internal */
	ontext(start, endIndex) {
		var _a$1, _b;
		const data$1 = this.getSlice(start, endIndex);
		this.endIndex = endIndex - 1;
		(_b = (_a$1 = this.cbs).ontext) === null || _b === void 0 || _b.call(_a$1, data$1);
		this.startIndex = endIndex;
	}
	/** @internal */
	ontextentity(cp, endIndex) {
		var _a$1, _b;
		this.endIndex = endIndex - 1;
		(_b = (_a$1 = this.cbs).ontext) === null || _b === void 0 || _b.call(_a$1, fromCodePoint(cp));
		this.startIndex = endIndex;
	}
	/**
	* Checks if the current tag is a void element. Override this if you want
	* to specify your own additional void elements.
	*/
	isVoidElement(name) {
		return this.htmlMode && voidElements.has(name);
	}
	/** @internal */
	onopentagname(start, endIndex) {
		this.endIndex = endIndex;
		let name = this.getSlice(start, endIndex);
		if (this.lowerCaseTagNames) name = name.toLowerCase();
		this.emitOpenTag(name);
	}
	emitOpenTag(name) {
		var _a$1, _b, _c, _d;
		this.openTagStart = this.startIndex;
		this.tagname = name;
		const impliesClose = this.htmlMode && openImpliesClose.get(name);
		if (impliesClose) while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
			const element = this.stack.shift();
			(_b = (_a$1 = this.cbs).onclosetag) === null || _b === void 0 || _b.call(_a$1, element, true);
		}
		if (!this.isVoidElement(name)) {
			this.stack.unshift(name);
			if (this.htmlMode) {
				if (foreignContextElements.has(name)) this.foreignContext.unshift(true);
				else if (htmlIntegrationElements.has(name)) this.foreignContext.unshift(false);
			}
		}
		(_d = (_c = this.cbs).onopentagname) === null || _d === void 0 || _d.call(_c, name);
		if (this.cbs.onopentag) this.attribs = {};
	}
	endOpenTag(isImplied) {
		var _a$1, _b;
		this.startIndex = this.openTagStart;
		if (this.attribs) {
			(_b = (_a$1 = this.cbs).onopentag) === null || _b === void 0 || _b.call(_a$1, this.tagname, this.attribs, isImplied);
			this.attribs = null;
		}
		if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) this.cbs.onclosetag(this.tagname, true);
		this.tagname = "";
	}
	/** @internal */
	onopentagend(endIndex) {
		this.endIndex = endIndex;
		this.endOpenTag(false);
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onclosetag(start, endIndex) {
		var _a$1, _b, _c, _d, _e, _f, _g, _h;
		this.endIndex = endIndex;
		let name = this.getSlice(start, endIndex);
		if (this.lowerCaseTagNames) name = name.toLowerCase();
		if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) this.foreignContext.shift();
		if (!this.isVoidElement(name)) {
			const pos = this.stack.indexOf(name);
			if (pos !== -1) for (let index = 0; index <= pos; index++) {
				const element = this.stack.shift();
				(_b = (_a$1 = this.cbs).onclosetag) === null || _b === void 0 || _b.call(_a$1, element, index !== pos);
			}
			else if (this.htmlMode && name === "p") {
				this.emitOpenTag("p");
				this.closeCurrentTag(true);
			}
		} else if (this.htmlMode && name === "br") {
			(_d = (_c = this.cbs).onopentagname) === null || _d === void 0 || _d.call(_c, "br");
			(_f = (_e = this.cbs).onopentag) === null || _f === void 0 || _f.call(_e, "br", {}, true);
			(_h = (_g = this.cbs).onclosetag) === null || _h === void 0 || _h.call(_g, "br", false);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onselfclosingtag(endIndex) {
		this.endIndex = endIndex;
		if (this.recognizeSelfClosing || this.foreignContext[0]) {
			this.closeCurrentTag(false);
			this.startIndex = endIndex + 1;
		} else this.onopentagend(endIndex);
	}
	closeCurrentTag(isOpenImplied) {
		var _a$1, _b;
		const name = this.tagname;
		this.endOpenTag(isOpenImplied);
		if (this.stack[0] === name) {
			(_b = (_a$1 = this.cbs).onclosetag) === null || _b === void 0 || _b.call(_a$1, name, !isOpenImplied);
			this.stack.shift();
		}
	}
	/** @internal */
	onattribname(start, endIndex) {
		this.startIndex = start;
		const name = this.getSlice(start, endIndex);
		this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
	}
	/** @internal */
	onattribdata(start, endIndex) {
		this.attribvalue += this.getSlice(start, endIndex);
	}
	/** @internal */
	onattribentity(cp) {
		this.attribvalue += fromCodePoint(cp);
	}
	/** @internal */
	onattribend(quote$1, endIndex) {
		var _a$1, _b;
		this.endIndex = endIndex;
		(_b = (_a$1 = this.cbs).onattribute) === null || _b === void 0 || _b.call(_a$1, this.attribname, this.attribvalue, quote$1 === QuoteType.Double ? "\"" : quote$1 === QuoteType.Single ? "'" : quote$1 === QuoteType.NoValue ? void 0 : null);
		if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) this.attribs[this.attribname] = this.attribvalue;
		this.attribvalue = "";
	}
	getInstructionName(value) {
		const index = value.search(reNameEnd);
		let name = index < 0 ? value : value.substr(0, index);
		if (this.lowerCaseTagNames) name = name.toLowerCase();
		return name;
	}
	/** @internal */
	ondeclaration(start, endIndex) {
		this.endIndex = endIndex;
		const value = this.getSlice(start, endIndex);
		if (this.cbs.onprocessinginstruction) {
			const name = this.getInstructionName(value);
			this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onprocessinginstruction(start, endIndex) {
		this.endIndex = endIndex;
		const value = this.getSlice(start, endIndex);
		if (this.cbs.onprocessinginstruction) {
			const name = this.getInstructionName(value);
			this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	oncomment(start, endIndex, offset) {
		var _a$1, _b, _c, _d;
		this.endIndex = endIndex;
		(_b = (_a$1 = this.cbs).oncomment) === null || _b === void 0 || _b.call(_a$1, this.getSlice(start, endIndex - offset));
		(_d = (_c = this.cbs).oncommentend) === null || _d === void 0 || _d.call(_c);
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	oncdata(start, endIndex, offset) {
		var _a$1, _b, _c, _d, _e, _f, _g, _h, _j, _k;
		this.endIndex = endIndex;
		const value = this.getSlice(start, endIndex - offset);
		if (!this.htmlMode || this.options.recognizeCDATA) {
			(_b = (_a$1 = this.cbs).oncdatastart) === null || _b === void 0 || _b.call(_a$1);
			(_d = (_c = this.cbs).ontext) === null || _d === void 0 || _d.call(_c, value);
			(_f = (_e = this.cbs).oncdataend) === null || _f === void 0 || _f.call(_e);
		} else {
			(_h = (_g = this.cbs).oncomment) === null || _h === void 0 || _h.call(_g, `[CDATA[${value}]]`);
			(_k = (_j = this.cbs).oncommentend) === null || _k === void 0 || _k.call(_j);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onend() {
		var _a$1, _b;
		if (this.cbs.onclosetag) {
			this.endIndex = this.startIndex;
			for (let index = 0; index < this.stack.length; index++) this.cbs.onclosetag(this.stack[index], true);
		}
		(_b = (_a$1 = this.cbs).onend) === null || _b === void 0 || _b.call(_a$1);
	}
	/**
	* Resets the parser to a blank state, ready to parse a new HTML document
	*/
	reset() {
		var _a$1, _b, _c, _d;
		(_b = (_a$1 = this.cbs).onreset) === null || _b === void 0 || _b.call(_a$1);
		this.tokenizer.reset();
		this.tagname = "";
		this.attribname = "";
		this.attribs = null;
		this.stack.length = 0;
		this.startIndex = 0;
		this.endIndex = 0;
		(_d = (_c = this.cbs).onparserinit) === null || _d === void 0 || _d.call(_c, this);
		this.buffers.length = 0;
		this.foreignContext.length = 0;
		this.foreignContext.unshift(!this.htmlMode);
		this.bufferOffset = 0;
		this.writeIndex = 0;
		this.ended = false;
	}
	/**
	* Resets the parser, then parses a complete document and
	* pushes it to the handler.
	*
	* @param data Document to parse.
	*/
	parseComplete(data$1) {
		this.reset();
		this.end(data$1);
	}
	getSlice(start, end) {
		while (start - this.bufferOffset >= this.buffers[0].length) this.shiftBuffer();
		let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
		while (end - this.bufferOffset > this.buffers[0].length) {
			this.shiftBuffer();
			slice += this.buffers[0].slice(0, end - this.bufferOffset);
		}
		return slice;
	}
	shiftBuffer() {
		this.bufferOffset += this.buffers[0].length;
		this.writeIndex--;
		this.buffers.shift();
	}
	/**
	* Parses a chunk of data and calls the corresponding callbacks.
	*
	* @param chunk Chunk to parse.
	*/
	write(chunk) {
		var _a$1, _b;
		if (this.ended) {
			(_b = (_a$1 = this.cbs).onerror) === null || _b === void 0 || _b.call(_a$1, /* @__PURE__ */ new Error(".write() after done!"));
			return;
		}
		this.buffers.push(chunk);
		if (this.tokenizer.running) {
			this.tokenizer.write(chunk);
			this.writeIndex++;
		}
	}
	/**
	* Parses the end of the buffer and clears the stack, calls onend.
	*
	* @param chunk Optional final chunk to parse.
	*/
	end(chunk) {
		var _a$1, _b;
		if (this.ended) {
			(_b = (_a$1 = this.cbs).onerror) === null || _b === void 0 || _b.call(_a$1, /* @__PURE__ */ new Error(".end() after done!"));
			return;
		}
		if (chunk) this.write(chunk);
		this.ended = true;
		this.tokenizer.end();
	}
	/**
	* Pauses parsing. The parser won't emit events until `resume` is called.
	*/
	pause() {
		this.tokenizer.pause();
	}
	/**
	* Resumes parsing after `pause` was called.
	*/
	resume() {
		this.tokenizer.resume();
		while (this.tokenizer.running && this.writeIndex < this.buffers.length) this.tokenizer.write(this.buffers[this.writeIndex++]);
		if (this.ended) this.tokenizer.end();
	}
	/**
	* Alias of `write`, for backwards compatibility.
	*
	* @param chunk Chunk to parse.
	* @deprecated
	*/
	parseChunk(chunk) {
		this.write(chunk);
	}
	/**
	* Alias of `end`, for backwards compatibility.
	*
	* @param chunk Optional final chunk to parse.
	* @deprecated
	*/
	done(chunk) {
		this.end(chunk);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/escape.js
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = new Map([
	[34, "&quot;"],
	[38, "&amp;"],
	[39, "&apos;"],
	[60, "&lt;"],
	[62, "&gt;"]
]);
const getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c$2, index) => (c$2.charCodeAt(index) & 64512) === 55296 ? (c$2.charCodeAt(index) - 55296) * 1024 + c$2.charCodeAt(index + 1) - 56320 + 65536 : c$2.charCodeAt(index);
/**
* Encodes all non-ASCII characters, as well as characters not valid in XML
* documents using XML entities.
*
* If a character has no equivalent entity, a
* numeric hexadecimal reference (eg. `&#xfc;`) will be used.
*/
function encodeXML(str) {
	let ret = "";
	let lastIdx = 0;
	let match;
	while ((match = xmlReplacer.exec(str)) !== null) {
		const i$1 = match.index;
		const char = str.charCodeAt(i$1);
		const next = xmlCodeMap.get(char);
		if (next !== void 0) {
			ret += str.substring(lastIdx, i$1) + next;
			lastIdx = i$1 + 1;
		} else {
			ret += `${str.substring(lastIdx, i$1)}&#x${getCodePoint(str, i$1).toString(16)};`;
			lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
		}
	}
	return ret + str.substr(lastIdx);
}
/**
* Creates a function that escapes all characters matched by the given regular
* expression using the given map of characters to escape to their entities.
*
* @param regex Regular expression to match characters to escape.
* @param map Map of characters to escape to their entities.
*
* @returns Function that escapes all characters matched by the given regular
* expression using the given map of characters to escape to their entities.
*/
function getEscaper(regex, map$6) {
	return function escape(data$1) {
		let match;
		let lastIdx = 0;
		let result = "";
		while (match = regex.exec(data$1)) {
			if (lastIdx !== match.index) result += data$1.substring(lastIdx, match.index);
			result += map$6.get(match[0].charCodeAt(0));
			lastIdx = match.index + 1;
		}
		return result + data$1.substring(lastIdx);
	};
}
/**
* Encodes all characters not valid in XML documents using XML entities.
*
* Note that the output will be character-set dependent.
*
* @param data String to escape.
*/
const escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
* Encodes all characters that have to be escaped in HTML attributes,
* following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
*
* @param data String to escape.
*/
const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
	[34, "&quot;"],
	[38, "&amp;"],
	[160, "&nbsp;"]
]));
/**
* Encodes all characters that have to be escaped in HTML text,
* following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
*
* @param data String to escape.
*/
const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
	[38, "&amp;"],
	[60, "&lt;"],
	[62, "&gt;"],
	[160, "&nbsp;"]
]));

//#endregion
//#region ../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/foreignNames.js
const elementNames = new Map([
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"clipPath",
	"feBlend",
	"feColorMatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feDropShadow",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"foreignObject",
	"glyphRef",
	"linearGradient",
	"radialGradient",
	"textPath"
].map((val) => [val.toLowerCase(), val]));
const attributeNames = new Map([
	"definitionURL",
	"attributeName",
	"attributeType",
	"baseFrequency",
	"baseProfile",
	"calcMode",
	"clipPathUnits",
	"diffuseConstant",
	"edgeMode",
	"filterUnits",
	"glyphRef",
	"gradientTransform",
	"gradientUnits",
	"kernelMatrix",
	"kernelUnitLength",
	"keyPoints",
	"keySplines",
	"keyTimes",
	"lengthAdjust",
	"limitingConeAngle",
	"markerHeight",
	"markerUnits",
	"markerWidth",
	"maskContentUnits",
	"maskUnits",
	"numOctaves",
	"pathLength",
	"patternContentUnits",
	"patternTransform",
	"patternUnits",
	"pointsAtX",
	"pointsAtY",
	"pointsAtZ",
	"preserveAlpha",
	"preserveAspectRatio",
	"primitiveUnits",
	"refX",
	"refY",
	"repeatCount",
	"repeatDur",
	"requiredExtensions",
	"requiredFeatures",
	"specularConstant",
	"specularExponent",
	"spreadMethod",
	"startOffset",
	"stdDeviation",
	"stitchTiles",
	"surfaceScale",
	"systemLanguage",
	"tableValues",
	"targetX",
	"targetY",
	"textLength",
	"viewBox",
	"viewTarget",
	"xChannelSelector",
	"yChannelSelector",
	"zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

//#endregion
//#region ../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/index.js
const unencodedElements = new Set([
	"style",
	"script",
	"xmp",
	"iframe",
	"noembed",
	"noframes",
	"plaintext",
	"noscript"
]);
function replaceQuotes(value) {
	return value.replace(/"/g, "&quot;");
}
/**
* Format attributes
*/
function formatAttributes(attributes, opts) {
	var _a$1;
	if (!attributes) return;
	const encode$1 = ((_a$1 = opts.encodeEntities) !== null && _a$1 !== void 0 ? _a$1 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
	return Object.keys(attributes).map((key) => {
		var _a$2, _b;
		const value = (_a$2 = attributes[key]) !== null && _a$2 !== void 0 ? _a$2 : "";
		if (opts.xmlMode === "foreign") key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
		if (!opts.emptyAttrs && !opts.xmlMode && value === "") return key;
		return `${key}="${encode$1(value)}"`;
	}).join(" ");
}
/**
* Self-enclosing tags
*/
const singleTag = new Set([
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
]);
/**
* Renders a DOM node or an array of DOM nodes to a string.
*
* Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
*
* @param node Node to be rendered.
* @param options Changes serialization behavior
*/
function render(node, options = {}) {
	const nodes = "length" in node ? node : [node];
	let output = "";
	for (let i$1 = 0; i$1 < nodes.length; i$1++) output += renderNode(nodes[i$1], options);
	return output;
}
var esm_default = render;
function renderNode(node, options) {
	switch (node.type) {
		case Root$8: return render(node.children, options);
		case Doctype:
		case Directive: return renderDirective(node);
		case Comment$7: return renderComment(node);
		case CDATA$1: return renderCdata(node);
		case Script:
		case Style:
		case Tag: return renderTag(node, options);
		case Text$1: return renderText(node, options);
	}
}
const foreignModeIntegrationPoints = new Set([
	"mi",
	"mo",
	"mn",
	"ms",
	"mtext",
	"annotation-xml",
	"foreignObject",
	"desc",
	"title"
]);
const foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
	var _a$1;
	if (opts.xmlMode === "foreign") {
		elem.name = (_a$1 = elementNames.get(elem.name)) !== null && _a$1 !== void 0 ? _a$1 : elem.name;
		if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) opts = {
			...opts,
			xmlMode: false
		};
	}
	if (!opts.xmlMode && foreignElements.has(elem.name)) opts = {
		...opts,
		xmlMode: "foreign"
	};
	let tag = `<${elem.name}`;
	const attribs = formatAttributes(elem.attribs, opts);
	if (attribs) tag += ` ${attribs}`;
	if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
		if (!opts.xmlMode) tag += " ";
		tag += "/>";
	} else {
		tag += ">";
		if (elem.children.length > 0) tag += render(elem.children, opts);
		if (opts.xmlMode || !singleTag.has(elem.name)) tag += `</${elem.name}>`;
	}
	return tag;
}
function renderDirective(elem) {
	return `<${elem.data}>`;
}
function renderText(elem, opts) {
	var _a$1;
	let data$1 = elem.data || "";
	if (((_a$1 = opts.encodeEntities) !== null && _a$1 !== void 0 ? _a$1 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) data$1 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data$1) : escapeText(data$1);
	return data$1;
}
function renderCdata(elem) {
	return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
	return `<!--${elem.data}-->`;
}

//#endregion
//#region ../../node_modules/.pnpm/htmlparser2@9.1.0/node_modules/htmlparser2/lib/esm/index.js
/**
* Parses the data, returns the resulting document.
*
* @param data The data that should be parsed.
* @param options Optional options for the parser and DOM handler.
*/
function parseDocument(data$1, options) {
	const handler = new DomHandler(void 0, options);
	new Parser$4(handler, options).end(data$1);
	return handler.root;
}

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/tokenize.js
var require_tokenize = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/tokenize.js": ((exports, module) => {
	const SINGLE_QUOTE = "'".charCodeAt(0);
	const DOUBLE_QUOTE = "\"".charCodeAt(0);
	const BACKSLASH = "\\".charCodeAt(0);
	const SLASH = "/".charCodeAt(0);
	const NEWLINE = "\n".charCodeAt(0);
	const SPACE = " ".charCodeAt(0);
	const FEED = "\f".charCodeAt(0);
	const TAB = "	".charCodeAt(0);
	const CR = "\r".charCodeAt(0);
	const OPEN_SQUARE = "[".charCodeAt(0);
	const CLOSE_SQUARE = "]".charCodeAt(0);
	const OPEN_PARENTHESES = "(".charCodeAt(0);
	const CLOSE_PARENTHESES = ")".charCodeAt(0);
	const OPEN_CURLY = "{".charCodeAt(0);
	const CLOSE_CURLY = "}".charCodeAt(0);
	const SEMICOLON = ";".charCodeAt(0);
	const ASTERISK = "*".charCodeAt(0);
	const COLON = ":".charCodeAt(0);
	const AT = "@".charCodeAt(0);
	const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
	const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
	const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
	const RE_HEX_ESCAPE = /[\da-f]/i;
	module.exports = function tokenizer$3(input, options = {}) {
		let css = input.css.valueOf();
		let ignore = options.ignoreErrors;
		let code, content, escape, next, quote$1;
		let currentToken, escaped, escapePos, n$1, prev;
		let length = css.length;
		let pos = 0;
		let buffer = [];
		let returned = [];
		function position() {
			return pos;
		}
		function unclosed(what) {
			throw input.error("Unclosed " + what, pos);
		}
		function endOfFile() {
			return returned.length === 0 && pos >= length;
		}
		function nextToken(opts) {
			if (returned.length) return returned.pop();
			if (pos >= length) return;
			let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
			code = css.charCodeAt(pos);
			switch (code) {
				case NEWLINE:
				case SPACE:
				case TAB:
				case CR:
				case FEED:
					next = pos;
					do {
						next += 1;
						code = css.charCodeAt(next);
					} while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
					currentToken = ["space", css.slice(pos, next)];
					pos = next - 1;
					break;
				case OPEN_SQUARE:
				case CLOSE_SQUARE:
				case OPEN_CURLY:
				case CLOSE_CURLY:
				case COLON:
				case SEMICOLON:
				case CLOSE_PARENTHESES: {
					let controlChar = String.fromCharCode(code);
					currentToken = [
						controlChar,
						controlChar,
						pos
					];
					break;
				}
				case OPEN_PARENTHESES:
					prev = buffer.length ? buffer.pop()[1] : "";
					n$1 = css.charCodeAt(pos + 1);
					if (prev === "url" && n$1 !== SINGLE_QUOTE && n$1 !== DOUBLE_QUOTE && n$1 !== SPACE && n$1 !== NEWLINE && n$1 !== TAB && n$1 !== FEED && n$1 !== CR) {
						next = pos;
						do {
							escaped = false;
							next = css.indexOf(")", next + 1);
							if (next === -1) if (ignore || ignoreUnclosed) {
								next = pos;
								break;
							} else unclosed("bracket");
							escapePos = next;
							while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
								escapePos -= 1;
								escaped = !escaped;
							}
						} while (escaped);
						currentToken = [
							"brackets",
							css.slice(pos, next + 1),
							pos,
							next
						];
						pos = next;
					} else {
						next = css.indexOf(")", pos + 1);
						content = css.slice(pos, next + 1);
						if (next === -1 || RE_BAD_BRACKET.test(content)) currentToken = [
							"(",
							"(",
							pos
						];
						else {
							currentToken = [
								"brackets",
								content,
								pos,
								next
							];
							pos = next;
						}
					}
					break;
				case SINGLE_QUOTE:
				case DOUBLE_QUOTE:
					quote$1 = code === SINGLE_QUOTE ? "'" : "\"";
					next = pos;
					do {
						escaped = false;
						next = css.indexOf(quote$1, next + 1);
						if (next === -1) if (ignore || ignoreUnclosed) {
							next = pos + 1;
							break;
						} else unclosed("string");
						escapePos = next;
						while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
							escapePos -= 1;
							escaped = !escaped;
						}
					} while (escaped);
					currentToken = [
						"string",
						css.slice(pos, next + 1),
						pos,
						next
					];
					pos = next;
					break;
				case AT:
					RE_AT_END.lastIndex = pos + 1;
					RE_AT_END.test(css);
					if (RE_AT_END.lastIndex === 0) next = css.length - 1;
					else next = RE_AT_END.lastIndex - 2;
					currentToken = [
						"at-word",
						css.slice(pos, next + 1),
						pos,
						next
					];
					pos = next;
					break;
				case BACKSLASH:
					next = pos;
					escape = true;
					while (css.charCodeAt(next + 1) === BACKSLASH) {
						next += 1;
						escape = !escape;
					}
					code = css.charCodeAt(next + 1);
					if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
						next += 1;
						if (RE_HEX_ESCAPE.test(css.charAt(next))) {
							while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) next += 1;
							if (css.charCodeAt(next + 1) === SPACE) next += 1;
						}
					}
					currentToken = [
						"word",
						css.slice(pos, next + 1),
						pos,
						next
					];
					pos = next;
					break;
				default:
					if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
						next = css.indexOf("*/", pos + 2) + 1;
						if (next === 0) if (ignore || ignoreUnclosed) next = css.length;
						else unclosed("comment");
						currentToken = [
							"comment",
							css.slice(pos, next + 1),
							pos,
							next
						];
						pos = next;
					} else {
						RE_WORD_END.lastIndex = pos + 1;
						RE_WORD_END.test(css);
						if (RE_WORD_END.lastIndex === 0) next = css.length - 1;
						else next = RE_WORD_END.lastIndex - 2;
						currentToken = [
							"word",
							css.slice(pos, next + 1),
							pos,
							next
						];
						buffer.push(currentToken);
						pos = next;
					}
					break;
			}
			pos++;
			return currentToken;
		}
		function back(token) {
			returned.push(token);
		}
		return {
			back,
			endOfFile,
			nextToken,
			position
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/terminal-highlight.js": ((exports, module) => {
	let pico$1 = require_picocolors();
	let tokenizer$2 = require_tokenize();
	let Input$6;
	function registerInput(dependant) {
		Input$6 = dependant;
	}
	const HIGHLIGHT_THEME = {
		";": pico$1.yellow,
		":": pico$1.yellow,
		"(": pico$1.cyan,
		")": pico$1.cyan,
		"[": pico$1.yellow,
		"]": pico$1.yellow,
		"{": pico$1.yellow,
		"}": pico$1.yellow,
		"at-word": pico$1.cyan,
		"brackets": pico$1.cyan,
		"call": pico$1.cyan,
		"class": pico$1.yellow,
		"comment": pico$1.gray,
		"hash": pico$1.magenta,
		"string": pico$1.green
	};
	function getTokenType([type, value], processor) {
		if (type === "word") {
			if (value[0] === ".") return "class";
			if (value[0] === "#") return "hash";
		}
		if (!processor.endOfFile()) {
			let next = processor.nextToken();
			processor.back(next);
			if (next[0] === "brackets" || next[0] === "(") return "call";
		}
		return type;
	}
	function terminalHighlight$2(css) {
		let processor = tokenizer$2(new Input$6(css), { ignoreErrors: true });
		let result = "";
		while (!processor.endOfFile()) {
			let token = processor.nextToken();
			let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
			if (color) result += token[1].split(/\r?\n/).map((i$1) => color(i$1)).join("\n");
			else result += token[1];
		}
		return result;
	}
	terminalHighlight$2.registerInput = registerInput;
	module.exports = terminalHighlight$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/css-syntax-error.js": ((exports, module) => {
	let pico = require_picocolors();
	let terminalHighlight$1 = require_terminal_highlight();
	var CssSyntaxError$4 = class CssSyntaxError$4 extends Error {
		constructor(message, line, column, source, file, plugin$1) {
			super(message);
			this.name = "CssSyntaxError";
			this.reason = message;
			if (file) this.file = file;
			if (source) this.source = source;
			if (plugin$1) this.plugin = plugin$1;
			if (typeof line !== "undefined" && typeof column !== "undefined") if (typeof line === "number") {
				this.line = line;
				this.column = column;
			} else {
				this.line = line.line;
				this.column = line.column;
				this.endLine = column.line;
				this.endColumn = column.column;
			}
			this.setMessage();
			if (Error.captureStackTrace) Error.captureStackTrace(this, CssSyntaxError$4);
		}
		setMessage() {
			this.message = this.plugin ? this.plugin + ": " : "";
			this.message += this.file ? this.file : "<css input>";
			if (typeof this.line !== "undefined") this.message += ":" + this.line + ":" + this.column;
			this.message += ": " + this.reason;
		}
		showSourceCode(color) {
			if (!this.source) return "";
			let css = this.source;
			if (color == null) color = pico.isColorSupported;
			let aside = (text) => text;
			let mark = (text) => text;
			let highlight = (text) => text;
			if (color) {
				let { bold, gray, red } = pico.createColors(true);
				mark = (text) => bold(red(text));
				aside = (text) => gray(text);
				if (terminalHighlight$1) highlight = (text) => terminalHighlight$1(text);
			}
			let lines = css.split(/\r?\n/);
			let start = Math.max(this.line - 3, 0);
			let end = Math.min(this.line + 2, lines.length);
			let maxWidth = String(end).length;
			return lines.slice(start, end).map((line, index) => {
				let number = start + 1 + index;
				let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
				if (number === this.line) {
					if (line.length > 160) {
						let padding = 20;
						let subLineStart = Math.max(0, this.column - padding);
						let subLineEnd = Math.max(this.column + padding, this.endColumn + padding);
						let subLine = line.slice(subLineStart, subLineEnd);
						let spacing$1 = aside(gutter.replace(/\d/g, " ")) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
						return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing$1 + mark("^");
					}
					let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
					return mark(">") + aside(gutter) + highlight(line) + "\n " + spacing + mark("^");
				}
				return " " + aside(gutter) + highlight(line);
			}).join("\n");
		}
		toString() {
			let code = this.showSourceCode();
			if (code) code = "\n\n" + code + "\n";
			return this.name + ": " + this.message + code;
		}
	};
	module.exports = CssSyntaxError$4;
	CssSyntaxError$4.default = CssSyntaxError$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/stringifier.js
var require_stringifier = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/stringifier.js": ((exports, module) => {
	const DEFAULT_RAW = {
		after: "\n",
		beforeClose: "\n",
		beforeComment: "\n",
		beforeDecl: "\n",
		beforeOpen: " ",
		beforeRule: "\n",
		colon: ": ",
		commentLeft: " ",
		commentRight: " ",
		emptyBody: "",
		indent: "    ",
		semicolon: false
	};
	function capitalize(str) {
		return str[0].toUpperCase() + str.slice(1);
	}
	var Stringifier$2 = class {
		constructor(builder) {
			this.builder = builder;
		}
		atrule(node, semicolon$1) {
			let name = "@" + node.name;
			let params = node.params ? this.rawValue(node, "params") : "";
			if (typeof node.raws.afterName !== "undefined") name += node.raws.afterName;
			else if (params) name += " ";
			if (node.nodes) this.block(node, name + params);
			else {
				let end = (node.raws.between || "") + (semicolon$1 ? ";" : "");
				this.builder(name + params + end, node);
			}
		}
		beforeAfter(node, detect$1) {
			let value;
			if (node.type === "decl") value = this.raw(node, null, "beforeDecl");
			else if (node.type === "comment") value = this.raw(node, null, "beforeComment");
			else if (detect$1 === "before") value = this.raw(node, null, "beforeRule");
			else value = this.raw(node, null, "beforeClose");
			let buf = node.parent;
			let depth = 0;
			while (buf && buf.type !== "root") {
				depth += 1;
				buf = buf.parent;
			}
			if (value.includes("\n")) {
				let indent$2 = this.raw(node, null, "indent");
				if (indent$2.length) for (let step = 0; step < depth; step++) value += indent$2;
			}
			return value;
		}
		block(node, start) {
			let between = this.raw(node, "between", "beforeOpen");
			this.builder(start + between + "{", node, "start");
			let after;
			if (node.nodes && node.nodes.length) {
				this.body(node);
				after = this.raw(node, "after");
			} else after = this.raw(node, "after", "emptyBody");
			if (after) this.builder(after);
			this.builder("}", node, "end");
		}
		body(node) {
			let last = node.nodes.length - 1;
			while (last > 0) {
				if (node.nodes[last].type !== "comment") break;
				last -= 1;
			}
			let semicolon$1 = this.raw(node, "semicolon");
			for (let i$1 = 0; i$1 < node.nodes.length; i$1++) {
				let child = node.nodes[i$1];
				let before = this.raw(child, "before");
				if (before) this.builder(before);
				this.stringify(child, last !== i$1 || semicolon$1);
			}
		}
		comment(node) {
			let left = this.raw(node, "left", "commentLeft");
			let right = this.raw(node, "right", "commentRight");
			this.builder("/*" + left + node.text + right + "*/", node);
		}
		decl(node, semicolon$1) {
			let between = this.raw(node, "between", "colon");
			let string$5 = node.prop + between + this.rawValue(node, "value");
			if (node.important) string$5 += node.raws.important || " !important";
			if (semicolon$1) string$5 += ";";
			this.builder(string$5, node);
		}
		document(node) {
			this.body(node);
		}
		raw(node, own, detect$1) {
			let value;
			if (!detect$1) detect$1 = own;
			if (own) {
				value = node.raws[own];
				if (typeof value !== "undefined") return value;
			}
			let parent = node.parent;
			if (detect$1 === "before") {
				if (!parent || parent.type === "root" && parent.first === node) return "";
				if (parent && parent.type === "document") return "";
			}
			if (!parent) return DEFAULT_RAW[detect$1];
			let root$1 = node.root();
			if (!root$1.rawCache) root$1.rawCache = {};
			if (typeof root$1.rawCache[detect$1] !== "undefined") return root$1.rawCache[detect$1];
			if (detect$1 === "before" || detect$1 === "after") return this.beforeAfter(node, detect$1);
			else {
				let method = "raw" + capitalize(detect$1);
				if (this[method]) value = this[method](root$1, node);
				else root$1.walk((i$1) => {
					value = i$1.raws[own];
					if (typeof value !== "undefined") return false;
				});
			}
			if (typeof value === "undefined") value = DEFAULT_RAW[detect$1];
			root$1.rawCache[detect$1] = value;
			return value;
		}
		rawBeforeClose(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && i$1.nodes.length > 0) {
					if (typeof i$1.raws.after !== "undefined") {
						value = i$1.raws.after;
						if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
						return false;
					}
				}
			});
			if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeComment(root$1, node) {
			let value;
			root$1.walkComments((i$1) => {
				if (typeof i$1.raws.before !== "undefined") {
					value = i$1.raws.before;
					if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
					return false;
				}
			});
			if (typeof value === "undefined") value = this.raw(node, null, "beforeDecl");
			else if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeDecl(root$1, node) {
			let value;
			root$1.walkDecls((i$1) => {
				if (typeof i$1.raws.before !== "undefined") {
					value = i$1.raws.before;
					if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
					return false;
				}
			});
			if (typeof value === "undefined") value = this.raw(node, null, "beforeRule");
			else if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeOpen(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.type !== "decl") {
					value = i$1.raws.between;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawBeforeRule(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && (i$1.parent !== root$1 || root$1.first !== i$1)) {
					if (typeof i$1.raws.before !== "undefined") {
						value = i$1.raws.before;
						if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
						return false;
					}
				}
			});
			if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawColon(root$1) {
			let value;
			root$1.walkDecls((i$1) => {
				if (typeof i$1.raws.between !== "undefined") {
					value = i$1.raws.between.replace(/[^\s:]/g, "");
					return false;
				}
			});
			return value;
		}
		rawEmptyBody(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && i$1.nodes.length === 0) {
					value = i$1.raws.after;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawIndent(root$1) {
			if (root$1.raws.indent) return root$1.raws.indent;
			let value;
			root$1.walk((i$1) => {
				let p$2 = i$1.parent;
				if (p$2 && p$2 !== root$1 && p$2.parent && p$2.parent === root$1) {
					if (typeof i$1.raws.before !== "undefined") {
						let parts = i$1.raws.before.split("\n");
						value = parts[parts.length - 1];
						value = value.replace(/\S/g, "");
						return false;
					}
				}
			});
			return value;
		}
		rawSemicolon(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && i$1.nodes.length && i$1.last.type === "decl") {
					value = i$1.raws.semicolon;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawValue(node, prop) {
			let value = node[prop];
			let raw = node.raws[prop];
			if (raw && raw.value === value) return raw.raw;
			return value;
		}
		root(node) {
			this.body(node);
			if (node.raws.after) this.builder(node.raws.after);
		}
		rule(node) {
			this.block(node, this.rawValue(node, "selector"));
			if (node.raws.ownSemicolon) this.builder(node.raws.ownSemicolon, node, "end");
		}
		stringify(node, semicolon$1) {
			/* c8 ignore start */
			if (!this[node.type]) throw new Error("Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier.");
			/* c8 ignore stop */
			this[node.type](node, semicolon$1);
		}
	};
	module.exports = Stringifier$2;
	Stringifier$2.default = Stringifier$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/stringify.js
var require_stringify$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/stringify.js": ((exports, module) => {
	let Stringifier$1 = require_stringifier();
	function stringify$12(node, builder) {
		new Stringifier$1(builder).stringify(node);
	}
	module.exports = stringify$12;
	stringify$12.default = stringify$12;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/symbols.js
var require_symbols = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/symbols.js": ((exports, module) => {
	module.exports.isClean = Symbol("isClean");
	module.exports.my = Symbol("my");
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/node.js
var require_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/node.js": ((exports, module) => {
	let CssSyntaxError$3 = require_css_syntax_error();
	let Stringifier = require_stringifier();
	let stringify$11 = require_stringify$1();
	let { isClean: isClean$2, my: my$2 } = require_symbols();
	function cloneNode(obj, parent) {
		let cloned = new obj.constructor();
		for (let i$1 in obj) {
			if (!Object.prototype.hasOwnProperty.call(obj, i$1))
 /* c8 ignore next 2 */
			continue;
			if (i$1 === "proxyCache") continue;
			let value = obj[i$1];
			let type = typeof value;
			if (i$1 === "parent" && type === "object") {
				if (parent) cloned[i$1] = parent;
			} else if (i$1 === "source") cloned[i$1] = value;
			else if (Array.isArray(value)) cloned[i$1] = value.map((j$2) => cloneNode(j$2, cloned));
			else {
				if (type === "object" && value !== null) value = cloneNode(value);
				cloned[i$1] = value;
			}
		}
		return cloned;
	}
	function sourceOffset(inputCSS, position) {
		if (position && typeof position.offset !== "undefined") return position.offset;
		let column = 1;
		let line = 1;
		let offset = 0;
		for (let i$1 = 0; i$1 < inputCSS.length; i$1++) {
			if (line === position.line && column === position.column) {
				offset = i$1;
				break;
			}
			if (inputCSS[i$1] === "\n") {
				column = 1;
				line += 1;
			} else column += 1;
		}
		return offset;
	}
	var Node$9 = class {
		get proxyOf() {
			return this;
		}
		constructor(defaults = {}) {
			this.raws = {};
			this[isClean$2] = false;
			this[my$2] = true;
			for (let name in defaults) if (name === "nodes") {
				this.nodes = [];
				for (let node of defaults[name]) if (typeof node.clone === "function") this.append(node.clone());
				else this.append(node);
			} else this[name] = defaults[name];
		}
		addToError(error) {
			error.postcssNode = this;
			if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
				let s = this.source;
				error.stack = error.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
			}
			return error;
		}
		after(add) {
			this.parent.insertAfter(this, add);
			return this;
		}
		assign(overrides = {}) {
			for (let name in overrides) this[name] = overrides[name];
			return this;
		}
		before(add) {
			this.parent.insertBefore(this, add);
			return this;
		}
		cleanRaws(keepBetween) {
			delete this.raws.before;
			delete this.raws.after;
			if (!keepBetween) delete this.raws.between;
		}
		clone(overrides = {}) {
			let cloned = cloneNode(this);
			for (let name in overrides) cloned[name] = overrides[name];
			return cloned;
		}
		cloneAfter(overrides = {}) {
			let cloned = this.clone(overrides);
			this.parent.insertAfter(this, cloned);
			return cloned;
		}
		cloneBefore(overrides = {}) {
			let cloned = this.clone(overrides);
			this.parent.insertBefore(this, cloned);
			return cloned;
		}
		error(message, opts = {}) {
			if (this.source) {
				let { end, start } = this.rangeBy(opts);
				return this.source.input.error(message, {
					column: start.column,
					line: start.line
				}, {
					column: end.column,
					line: end.line
				}, opts);
			}
			return new CssSyntaxError$3(message);
		}
		getProxyProcessor() {
			return {
				get(node, prop) {
					if (prop === "proxyOf") return node;
					else if (prop === "root") return () => node.root().toProxy();
					else return node[prop];
				},
				set(node, prop, value) {
					if (node[prop] === value) return true;
					node[prop] = value;
					if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") node.markDirty();
					return true;
				}
			};
		}
		/* c8 ignore next 3 */
		markClean() {
			this[isClean$2] = true;
		}
		markDirty() {
			if (this[isClean$2]) {
				this[isClean$2] = false;
				let next = this;
				while (next = next.parent) next[isClean$2] = false;
			}
		}
		next() {
			if (!this.parent) return void 0;
			let index = this.parent.index(this);
			return this.parent.nodes[index + 1];
		}
		positionBy(opts = {}) {
			let pos = this.source.start;
			if (opts.index) pos = this.positionInside(opts.index);
			else if (opts.word) {
				let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
				let index = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end)).indexOf(opts.word);
				if (index !== -1) pos = this.positionInside(index);
			}
			return pos;
		}
		positionInside(index) {
			let column = this.source.start.column;
			let line = this.source.start.line;
			let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
			let offset = sourceOffset(inputString, this.source.start);
			let end = offset + index;
			for (let i$1 = offset; i$1 < end; i$1++) if (inputString[i$1] === "\n") {
				column = 1;
				line += 1;
			} else column += 1;
			return {
				column,
				line,
				offset: end
			};
		}
		prev() {
			if (!this.parent) return void 0;
			let index = this.parent.index(this);
			return this.parent.nodes[index - 1];
		}
		rangeBy(opts = {}) {
			let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
			let start = {
				column: this.source.start.column,
				line: this.source.start.line,
				offset: sourceOffset(inputString, this.source.start)
			};
			let end = this.source.end ? {
				column: this.source.end.column + 1,
				line: this.source.end.line,
				offset: typeof this.source.end.offset === "number" ? this.source.end.offset : sourceOffset(inputString, this.source.end) + 1
			} : {
				column: start.column + 1,
				line: start.line,
				offset: start.offset + 1
			};
			if (opts.word) {
				let index = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end)).indexOf(opts.word);
				if (index !== -1) {
					start = this.positionInside(index);
					end = this.positionInside(index + opts.word.length);
				}
			} else {
				if (opts.start) start = {
					column: opts.start.column,
					line: opts.start.line,
					offset: sourceOffset(inputString, opts.start)
				};
				else if (opts.index) start = this.positionInside(opts.index);
				if (opts.end) end = {
					column: opts.end.column,
					line: opts.end.line,
					offset: sourceOffset(inputString, opts.end)
				};
				else if (typeof opts.endIndex === "number") end = this.positionInside(opts.endIndex);
				else if (opts.index) end = this.positionInside(opts.index + 1);
			}
			if (end.line < start.line || end.line === start.line && end.column <= start.column) end = {
				column: start.column + 1,
				line: start.line,
				offset: start.offset + 1
			};
			return {
				end,
				start
			};
		}
		raw(prop, defaultType) {
			return new Stringifier().raw(this, prop, defaultType);
		}
		remove() {
			if (this.parent) this.parent.removeChild(this);
			this.parent = void 0;
			return this;
		}
		replaceWith(...nodes) {
			if (this.parent) {
				let bookmark = this;
				let foundSelf = false;
				for (let node of nodes) if (node === this) foundSelf = true;
				else if (foundSelf) {
					this.parent.insertAfter(bookmark, node);
					bookmark = node;
				} else this.parent.insertBefore(bookmark, node);
				if (!foundSelf) this.remove();
			}
			return this;
		}
		root() {
			let result = this;
			while (result.parent && result.parent.type !== "document") result = result.parent;
			return result;
		}
		toJSON(_$1, inputs) {
			let fixed = {};
			let emitInputs = inputs == null;
			inputs = inputs || /* @__PURE__ */ new Map();
			let inputsNextIndex = 0;
			for (let name in this) {
				if (!Object.prototype.hasOwnProperty.call(this, name))
 /* c8 ignore next 2 */
				continue;
				if (name === "parent" || name === "proxyCache") continue;
				let value = this[name];
				if (Array.isArray(value)) fixed[name] = value.map((i$1) => {
					if (typeof i$1 === "object" && i$1.toJSON) return i$1.toJSON(null, inputs);
					else return i$1;
				});
				else if (typeof value === "object" && value.toJSON) fixed[name] = value.toJSON(null, inputs);
				else if (name === "source") {
					if (value == null) continue;
					let inputId = inputs.get(value.input);
					if (inputId == null) {
						inputId = inputsNextIndex;
						inputs.set(value.input, inputsNextIndex);
						inputsNextIndex++;
					}
					fixed[name] = {
						end: value.end,
						inputId,
						start: value.start
					};
				} else fixed[name] = value;
			}
			if (emitInputs) fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
			return fixed;
		}
		toProxy() {
			if (!this.proxyCache) this.proxyCache = new Proxy(this, this.getProxyProcessor());
			return this.proxyCache;
		}
		toString(stringifier = stringify$11) {
			if (stringifier.stringify) stringifier = stringifier.stringify;
			let result = "";
			stringifier(this, (i$1) => {
				result += i$1;
			});
			return result;
		}
		warn(result, text, opts = {}) {
			let data$1 = { node: this };
			for (let i$1 in opts) data$1[i$1] = opts[i$1];
			return result.warn(text, data$1);
		}
	};
	module.exports = Node$9;
	Node$9.default = Node$9;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/comment.js
var require_comment = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/comment.js": ((exports, module) => {
	let Node$8 = require_node();
	var Comment$5 = class extends Node$8 {
		constructor(defaults) {
			super(defaults);
			this.type = "comment";
		}
	};
	module.exports = Comment$5;
	Comment$5.default = Comment$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/declaration.js
var require_declaration = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/declaration.js": ((exports, module) => {
	let Node$7 = require_node();
	var Declaration$5 = class extends Node$7 {
		get variable() {
			return this.prop.startsWith("--") || this.prop[0] === "$";
		}
		constructor(defaults) {
			if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") defaults = {
				...defaults,
				value: String(defaults.value)
			};
			super(defaults);
			this.type = "decl";
		}
	};
	module.exports = Declaration$5;
	Declaration$5.default = Declaration$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/container.js
var require_container = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/container.js": ((exports, module) => {
	let Comment$4 = require_comment();
	let Declaration$4 = require_declaration();
	let Node$6 = require_node();
	let { isClean: isClean$1, my: my$1 } = require_symbols();
	let AtRule$5, parse$7, Root$7, Rule$5;
	function cleanSource(nodes) {
		return nodes.map((i$1) => {
			if (i$1.nodes) i$1.nodes = cleanSource(i$1.nodes);
			delete i$1.source;
			return i$1;
		});
	}
	function markTreeDirty(node) {
		node[isClean$1] = false;
		if (node.proxyOf.nodes) for (let i$1 of node.proxyOf.nodes) markTreeDirty(i$1);
	}
	var Container$8 = class Container$8 extends Node$6 {
		get first() {
			if (!this.proxyOf.nodes) return void 0;
			return this.proxyOf.nodes[0];
		}
		get last() {
			if (!this.proxyOf.nodes) return void 0;
			return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
		}
		append(...children) {
			for (let child of children) {
				let nodes = this.normalize(child, this.last);
				for (let node of nodes) this.proxyOf.nodes.push(node);
			}
			this.markDirty();
			return this;
		}
		cleanRaws(keepBetween) {
			super.cleanRaws(keepBetween);
			if (this.nodes) for (let node of this.nodes) node.cleanRaws(keepBetween);
		}
		each(callback) {
			if (!this.proxyOf.nodes) return void 0;
			let iterator = this.getIterator();
			let index, result;
			while (this.indexes[iterator] < this.proxyOf.nodes.length) {
				index = this.indexes[iterator];
				result = callback(this.proxyOf.nodes[index], index);
				if (result === false) break;
				this.indexes[iterator] += 1;
			}
			delete this.indexes[iterator];
			return result;
		}
		every(condition) {
			return this.nodes.every(condition);
		}
		getIterator() {
			if (!this.lastEach) this.lastEach = 0;
			if (!this.indexes) this.indexes = {};
			this.lastEach += 1;
			let iterator = this.lastEach;
			this.indexes[iterator] = 0;
			return iterator;
		}
		getProxyProcessor() {
			return {
				get(node, prop) {
					if (prop === "proxyOf") return node;
					else if (!node[prop]) return node[prop];
					else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) return (...args) => {
						return node[prop](...args.map((i$1) => {
							if (typeof i$1 === "function") return (child, index) => i$1(child.toProxy(), index);
							else return i$1;
						}));
					};
					else if (prop === "every" || prop === "some") return (cb) => {
						return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
					};
					else if (prop === "root") return () => node.root().toProxy();
					else if (prop === "nodes") return node.nodes.map((i$1) => i$1.toProxy());
					else if (prop === "first" || prop === "last") return node[prop].toProxy();
					else return node[prop];
				},
				set(node, prop, value) {
					if (node[prop] === value) return true;
					node[prop] = value;
					if (prop === "name" || prop === "params" || prop === "selector") node.markDirty();
					return true;
				}
			};
		}
		index(child) {
			if (typeof child === "number") return child;
			if (child.proxyOf) child = child.proxyOf;
			return this.proxyOf.nodes.indexOf(child);
		}
		insertAfter(exist, add) {
			let existIndex = this.index(exist);
			let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
			existIndex = this.index(exist);
			for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (existIndex < index) this.indexes[id] = index + nodes.length;
			}
			this.markDirty();
			return this;
		}
		insertBefore(exist, add) {
			let existIndex = this.index(exist);
			let type = existIndex === 0 ? "prepend" : false;
			let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
			existIndex = this.index(exist);
			for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (existIndex <= index) this.indexes[id] = index + nodes.length;
			}
			this.markDirty();
			return this;
		}
		normalize(nodes, sample) {
			if (typeof nodes === "string") nodes = cleanSource(parse$7(nodes).nodes);
			else if (typeof nodes === "undefined") nodes = [];
			else if (Array.isArray(nodes)) {
				nodes = nodes.slice(0);
				for (let i$1 of nodes) if (i$1.parent) i$1.parent.removeChild(i$1, "ignore");
			} else if (nodes.type === "root" && this.type !== "document") {
				nodes = nodes.nodes.slice(0);
				for (let i$1 of nodes) if (i$1.parent) i$1.parent.removeChild(i$1, "ignore");
			} else if (nodes.type) nodes = [nodes];
			else if (nodes.prop) {
				if (typeof nodes.value === "undefined") throw new Error("Value field is missed in node creation");
				else if (typeof nodes.value !== "string") nodes.value = String(nodes.value);
				nodes = [new Declaration$4(nodes)];
			} else if (nodes.selector || nodes.selectors) nodes = [new Rule$5(nodes)];
			else if (nodes.name) nodes = [new AtRule$5(nodes)];
			else if (nodes.text) nodes = [new Comment$4(nodes)];
			else throw new Error("Unknown node type in node creation");
			return nodes.map((i$1) => {
				/* c8 ignore next */
				if (!i$1[my$1]) Container$8.rebuild(i$1);
				i$1 = i$1.proxyOf;
				if (i$1.parent) i$1.parent.removeChild(i$1);
				if (i$1[isClean$1]) markTreeDirty(i$1);
				if (!i$1.raws) i$1.raws = {};
				if (typeof i$1.raws.before === "undefined") {
					if (sample && typeof sample.raws.before !== "undefined") i$1.raws.before = sample.raws.before.replace(/\S/g, "");
				}
				i$1.parent = this.proxyOf;
				return i$1;
			});
		}
		prepend(...children) {
			children = children.reverse();
			for (let child of children) {
				let nodes = this.normalize(child, this.first, "prepend").reverse();
				for (let node of nodes) this.proxyOf.nodes.unshift(node);
				for (let id in this.indexes) this.indexes[id] = this.indexes[id] + nodes.length;
			}
			this.markDirty();
			return this;
		}
		push(child) {
			child.parent = this;
			this.proxyOf.nodes.push(child);
			return this;
		}
		removeAll() {
			for (let node of this.proxyOf.nodes) node.parent = void 0;
			this.proxyOf.nodes = [];
			this.markDirty();
			return this;
		}
		removeChild(child) {
			child = this.index(child);
			this.proxyOf.nodes[child].parent = void 0;
			this.proxyOf.nodes.splice(child, 1);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (index >= child) this.indexes[id] = index - 1;
			}
			this.markDirty();
			return this;
		}
		replaceValues(pattern, opts, callback) {
			if (!callback) {
				callback = opts;
				opts = {};
			}
			this.walkDecls((decl$1) => {
				if (opts.props && !opts.props.includes(decl$1.prop)) return;
				if (opts.fast && !decl$1.value.includes(opts.fast)) return;
				decl$1.value = decl$1.value.replace(pattern, callback);
			});
			this.markDirty();
			return this;
		}
		some(condition) {
			return this.nodes.some(condition);
		}
		walk(callback) {
			return this.each((child, i$1) => {
				let result;
				try {
					result = callback(child, i$1);
				} catch (e$1) {
					throw child.addToError(e$1);
				}
				if (result !== false && child.walk) result = child.walk(callback);
				return result;
			});
		}
		walkAtRules(name, callback) {
			if (!callback) {
				callback = name;
				return this.walk((child, i$1) => {
					if (child.type === "atrule") return callback(child, i$1);
				});
			}
			if (name instanceof RegExp) return this.walk((child, i$1) => {
				if (child.type === "atrule" && name.test(child.name)) return callback(child, i$1);
			});
			return this.walk((child, i$1) => {
				if (child.type === "atrule" && child.name === name) return callback(child, i$1);
			});
		}
		walkComments(callback) {
			return this.walk((child, i$1) => {
				if (child.type === "comment") return callback(child, i$1);
			});
		}
		walkDecls(prop, callback) {
			if (!callback) {
				callback = prop;
				return this.walk((child, i$1) => {
					if (child.type === "decl") return callback(child, i$1);
				});
			}
			if (prop instanceof RegExp) return this.walk((child, i$1) => {
				if (child.type === "decl" && prop.test(child.prop)) return callback(child, i$1);
			});
			return this.walk((child, i$1) => {
				if (child.type === "decl" && child.prop === prop) return callback(child, i$1);
			});
		}
		walkRules(selector, callback) {
			if (!callback) {
				callback = selector;
				return this.walk((child, i$1) => {
					if (child.type === "rule") return callback(child, i$1);
				});
			}
			if (selector instanceof RegExp) return this.walk((child, i$1) => {
				if (child.type === "rule" && selector.test(child.selector)) return callback(child, i$1);
			});
			return this.walk((child, i$1) => {
				if (child.type === "rule" && child.selector === selector) return callback(child, i$1);
			});
		}
	};
	Container$8.registerParse = (dependant) => {
		parse$7 = dependant;
	};
	Container$8.registerRule = (dependant) => {
		Rule$5 = dependant;
	};
	Container$8.registerAtRule = (dependant) => {
		AtRule$5 = dependant;
	};
	Container$8.registerRoot = (dependant) => {
		Root$7 = dependant;
	};
	module.exports = Container$8;
	Container$8.default = Container$8;
	/* c8 ignore start */
	Container$8.rebuild = (node) => {
		if (node.type === "atrule") Object.setPrototypeOf(node, AtRule$5.prototype);
		else if (node.type === "rule") Object.setPrototypeOf(node, Rule$5.prototype);
		else if (node.type === "decl") Object.setPrototypeOf(node, Declaration$4.prototype);
		else if (node.type === "comment") Object.setPrototypeOf(node, Comment$4.prototype);
		else if (node.type === "root") Object.setPrototypeOf(node, Root$7.prototype);
		node[my$1] = true;
		if (node.nodes) node.nodes.forEach((child) => {
			Container$8.rebuild(child);
		});
	};
}) });
/* c8 ignore stop */

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/at-rule.js
var require_at_rule = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/at-rule.js": ((exports, module) => {
	let Container$7 = require_container();
	var AtRule$4 = class extends Container$7 {
		constructor(defaults) {
			super(defaults);
			this.type = "atrule";
		}
		append(...children) {
			if (!this.proxyOf.nodes) this.nodes = [];
			return super.append(...children);
		}
		prepend(...children) {
			if (!this.proxyOf.nodes) this.nodes = [];
			return super.prepend(...children);
		}
	};
	module.exports = AtRule$4;
	AtRule$4.default = AtRule$4;
	Container$7.registerAtRule(AtRule$4);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/document.js
var require_document = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/document.js": ((exports, module) => {
	let Container$6 = require_container();
	let LazyResult$4, Processor$4;
	var Document$10 = class extends Container$6 {
		constructor(defaults) {
			super({
				type: "document",
				...defaults
			});
			if (!this.nodes) this.nodes = [];
		}
		toResult(opts = {}) {
			return new LazyResult$4(new Processor$4(), this, opts).stringify();
		}
	};
	Document$10.registerLazyResult = (dependant) => {
		LazyResult$4 = dependant;
	};
	Document$10.registerProcessor = (dependant) => {
		Processor$4 = dependant;
	};
	module.exports = Document$10;
	Document$10.default = Document$10;
}) });

//#endregion
//#region ../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.cjs
var require_non_secure = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.cjs": ((exports, module) => {
	let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
	let customAlphabet = (alphabet, defaultSize = 21) => {
		return (size = defaultSize) => {
			let id = "";
			let i$1 = size | 0;
			while (i$1--) id += alphabet[Math.random() * alphabet.length | 0];
			return id;
		};
	};
	let nanoid$1 = (size = 21) => {
		let id = "";
		let i$1 = size | 0;
		while (i$1--) id += urlAlphabet[Math.random() * 64 | 0];
		return id;
	};
	module.exports = {
		nanoid: nanoid$1,
		customAlphabet
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js
var require_base64 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js": ((exports) => {
	var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
	/**
	* Encode an integer in the range of 0 to 63 to a single base 64 digit.
	*/
	exports.encode = function(number) {
		if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
		throw new TypeError("Must be between 0 and 63: " + number);
	};
	/**
	* Decode a single base 64 character code digit to an integer. Returns -1 on
	* failure.
	*/
	exports.decode = function(charCode) {
		var bigA = 65;
		var bigZ = 90;
		var littleA = 97;
		var littleZ = 122;
		var zero = 48;
		var nine = 57;
		var plus = 43;
		var slash = 47;
		var littleOffset = 26;
		var numberOffset = 52;
		if (bigA <= charCode && charCode <= bigZ) return charCode - bigA;
		if (littleA <= charCode && charCode <= littleZ) return charCode - littleA + littleOffset;
		if (zero <= charCode && charCode <= nine) return charCode - zero + numberOffset;
		if (charCode == plus) return 62;
		if (charCode == slash) return 63;
		return -1;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js": ((exports) => {
	var base64 = require_base64();
	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	/**
	* Converts from a two-complement value to a value where the sign bit is
	* placed in the least significant bit.  For example, as decimals:
	*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	*/
	function toVLQSigned(aValue) {
		return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}
	/**
	* Converts to a two-complement value from a value where the sign bit is
	* placed in the least significant bit.  For example, as decimals:
	*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	*/
	function fromVLQSigned(aValue) {
		var isNegative = (aValue & 1) === 1;
		var shifted = aValue >> 1;
		return isNegative ? -shifted : shifted;
	}
	/**
	* Returns the base 64 VLQ encoded value.
	*/
	exports.encode = function base64VLQ_encode(aValue) {
		var encoded = "";
		var digit;
		var vlq = toVLQSigned(aValue);
		do {
			digit = vlq & VLQ_BASE_MASK;
			vlq >>>= VLQ_BASE_SHIFT;
			if (vlq > 0) digit |= VLQ_CONTINUATION_BIT;
			encoded += base64.encode(digit);
		} while (vlq > 0);
		return encoded;
	};
	/**
	* Decodes the next base 64 VLQ value from the given string and returns the
	* value and the rest of the string via the out parameter.
	*/
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		var strLen = aStr.length;
		var result = 0;
		var shift = 0;
		var continuation, digit;
		do {
			if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
			digit = base64.decode(aStr.charCodeAt(aIndex++));
			if (digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			continuation = !!(digit & VLQ_CONTINUATION_BIT);
			digit &= VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += VLQ_BASE_SHIFT;
		} while (continuation);
		aOutParam.value = fromVLQSigned(result);
		aOutParam.rest = aIndex;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js
var require_util = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js": ((exports) => {
	/**
	* This is a helper function for getting values from parameter/options
	* objects.
	*
	* @param args The object we are extracting values from
	* @param name The name of the property we are getting.
	* @param defaultValue An optional value to return if the property is missing
	* from the object. If this is not specified and the property is missing, an
	* error will be thrown.
	*/
	function getArg(aArgs, aName, aDefaultValue) {
		if (aName in aArgs) return aArgs[aName];
		else if (arguments.length === 3) return aDefaultValue;
		else throw new Error("\"" + aName + "\" is a required argument.");
	}
	exports.getArg = getArg;
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	function urlParse(aUrl) {
		var match = aUrl.match(urlRegexp);
		if (!match) return null;
		return {
			scheme: match[1],
			auth: match[2],
			host: match[3],
			port: match[4],
			path: match[5]
		};
	}
	exports.urlParse = urlParse;
	function urlGenerate(aParsedUrl) {
		var url = "";
		if (aParsedUrl.scheme) url += aParsedUrl.scheme + ":";
		url += "//";
		if (aParsedUrl.auth) url += aParsedUrl.auth + "@";
		if (aParsedUrl.host) url += aParsedUrl.host;
		if (aParsedUrl.port) url += ":" + aParsedUrl.port;
		if (aParsedUrl.path) url += aParsedUrl.path;
		return url;
	}
	exports.urlGenerate = urlGenerate;
	var MAX_CACHED_INPUTS = 32;
	/**
	* Takes some function `f(input) -> result` and returns a memoized version of
	* `f`.
	*
	* We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
	* memoization is a dumb-simple, linear least-recently-used cache.
	*/
	function lruMemoize(f$2) {
		var cache = [];
		return function(input) {
			for (var i$1 = 0; i$1 < cache.length; i$1++) if (cache[i$1].input === input) {
				var temp = cache[0];
				cache[0] = cache[i$1];
				cache[i$1] = temp;
				return cache[0].result;
			}
			var result = f$2(input);
			cache.unshift({
				input,
				result
			});
			if (cache.length > MAX_CACHED_INPUTS) cache.pop();
			return result;
		};
	}
	/**
	* Normalizes a path, or the path portion of a URL:
	*
	* - Replaces consecutive slashes with one slash.
	* - Removes unnecessary '.' parts.
	* - Removes unnecessary '<dir>/..' parts.
	*
	* Based on code in the Node.js 'path' core module.
	*
	* @param aPath The path or url to normalize.
	*/
	var normalize$1 = lruMemoize(function normalize$2(aPath) {
		var path$2 = aPath;
		var url = urlParse(aPath);
		if (url) {
			if (!url.path) return aPath;
			path$2 = url.path;
		}
		var isAbsolute$2 = exports.isAbsolute(path$2);
		var parts = [];
		var start = 0;
		var i$1 = 0;
		while (true) {
			start = i$1;
			i$1 = path$2.indexOf("/", start);
			if (i$1 === -1) {
				parts.push(path$2.slice(start));
				break;
			} else {
				parts.push(path$2.slice(start, i$1));
				while (i$1 < path$2.length && path$2[i$1] === "/") i$1++;
			}
		}
		for (var part, up$2 = 0, i$1 = parts.length - 1; i$1 >= 0; i$1--) {
			part = parts[i$1];
			if (part === ".") parts.splice(i$1, 1);
			else if (part === "..") up$2++;
			else if (up$2 > 0) if (part === "") {
				parts.splice(i$1 + 1, up$2);
				up$2 = 0;
			} else {
				parts.splice(i$1, 2);
				up$2--;
			}
		}
		path$2 = parts.join("/");
		if (path$2 === "") path$2 = isAbsolute$2 ? "/" : ".";
		if (url) {
			url.path = path$2;
			return urlGenerate(url);
		}
		return path$2;
	});
	exports.normalize = normalize$1;
	/**
	* Joins two paths/URLs.
	*
	* @param aRoot The root path or URL.
	* @param aPath The path or URL to be joined with the root.
	*
	* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	*   first.
	* - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	*   is updated with the result and aRoot is returned. Otherwise the result
	*   is returned.
	*   - If aPath is absolute, the result is aPath.
	*   - Otherwise the two paths are joined with a slash.
	* - Joining for example 'http://' and 'www.example.com' is also supported.
	*/
	function join$2(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		if (aPath === "") aPath = ".";
		var aPathUrl = urlParse(aPath);
		var aRootUrl = urlParse(aRoot);
		if (aRootUrl) aRoot = aRootUrl.path || "/";
		if (aPathUrl && !aPathUrl.scheme) {
			if (aRootUrl) aPathUrl.scheme = aRootUrl.scheme;
			return urlGenerate(aPathUrl);
		}
		if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
		if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
			aRootUrl.host = aPath;
			return urlGenerate(aRootUrl);
		}
		var joined = aPath.charAt(0) === "/" ? aPath : normalize$1(aRoot.replace(/\/+$/, "") + "/" + aPath);
		if (aRootUrl) {
			aRootUrl.path = joined;
			return urlGenerate(aRootUrl);
		}
		return joined;
	}
	exports.join = join$2;
	exports.isAbsolute = function(aPath) {
		return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
	};
	/**
	* Make a path relative to a URL or another path.
	*
	* @param aRoot The root path or URL.
	* @param aPath The path or URL to be made relative to aRoot.
	*/
	function relative$1(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		aRoot = aRoot.replace(/\/$/, "");
		var level = 0;
		while (aPath.indexOf(aRoot + "/") !== 0) {
			var index = aRoot.lastIndexOf("/");
			if (index < 0) return aPath;
			aRoot = aRoot.slice(0, index);
			if (aRoot.match(/^([^\/]+:\/)?\/*$/)) return aPath;
			++level;
		}
		return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative$1;
	var supportsNullProto = function() {
		return !("__proto__" in Object.create(null));
	}();
	function identity$34(s) {
		return s;
	}
	/**
	* Because behavior goes wacky when you set `__proto__` on objects, we
	* have to prefix all the strings in our set with an arbitrary character.
	*
	* See https://github.com/mozilla/source-map/pull/31 and
	* https://github.com/mozilla/source-map/issues/30
	*
	* @param String aStr
	*/
	function toSetString(aStr) {
		if (isProtoString(aStr)) return "$" + aStr;
		return aStr;
	}
	exports.toSetString = supportsNullProto ? identity$34 : toSetString;
	function fromSetString(aStr) {
		if (isProtoString(aStr)) return aStr.slice(1);
		return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity$34 : fromSetString;
	function isProtoString(s) {
		if (!s) return false;
		var length = s.length;
		if (length < 9) return false;
		if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) return false;
		for (var i$1 = length - 10; i$1 >= 0; i$1--) if (s.charCodeAt(i$1) !== 36) return false;
		return true;
	}
	/**
	* Comparator between two mappings where the original positions are compared.
	*
	* Optionally pass in `true` as `onlyCompareGenerated` to consider two
	* mappings with the same original source/line/column, but different generated
	* line and column the same. Useful when searching for a mapping with a
	* stubbed out mapping.
	*/
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		var cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		var cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
	/**
	* Comparator between two mappings with deflated source and name indices where
	* the generated positions are compared.
	*
	* Optionally pass in `true` as `onlyCompareGenerated` to consider two
	* mappings with the same generated line and column, but different
	* source/name/original line and column the same. Useful when searching for a
	* mapping with a stubbed out mapping.
	*/
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
	function strcmp(aStr1, aStr2) {
		if (aStr1 === aStr2) return 0;
		if (aStr1 === null) return 1;
		if (aStr2 === null) return -1;
		if (aStr1 > aStr2) return 1;
		return -1;
	}
	/**
	* Comparator between two mappings with inflated source and name strings where
	* the generated positions are compared.
	*/
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	/**
	* Strip any JSON XSSI avoidance prefix from the string (as documented
	* in the source maps specification), and then parse the string as
	* JSON.
	*/
	function parseSourceMapInput(str) {
		return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
	}
	exports.parseSourceMapInput = parseSourceMapInput;
	/**
	* Compute the URL of a source given the the source root, the source's
	* URL, and the source map's URL.
	*/
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		sourceURL = sourceURL || "";
		if (sourceRoot) {
			if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") sourceRoot += "/";
			sourceURL = sourceRoot + sourceURL;
		}
		if (sourceMapURL) {
			var parsed = urlParse(sourceMapURL);
			if (!parsed) throw new Error("sourceMapURL could not be parsed");
			if (parsed.path) {
				var index = parsed.path.lastIndexOf("/");
				if (index >= 0) parsed.path = parsed.path.substring(0, index + 1);
			}
			sourceURL = join$2(urlGenerate(parsed), sourceURL);
		}
		return normalize$1(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js
var require_array_set = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js": ((exports) => {
	var util$4 = require_util();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	/**
	* A data structure which is a combination of an array and a set. Adding a new
	* member is O(1), testing for membership is O(1), and finding the index of an
	* element is O(1). Removing elements from the set is not supported. Only
	* strings are supported for membership.
	*/
	function ArraySet$2() {
		this._array = [];
		this._set = hasNativeMap ? /* @__PURE__ */ new Map() : Object.create(null);
	}
	/**
	* Static method for creating ArraySet instances from an existing array.
	*/
	ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		var set$3 = new ArraySet$2();
		for (var i$1 = 0, len = aArray.length; i$1 < len; i$1++) set$3.add(aArray[i$1], aAllowDuplicates);
		return set$3;
	};
	/**
	* Return how many unique items are in this ArraySet. If duplicates have been
	* added, than those do not count towards the size.
	*
	* @returns Number
	*/
	ArraySet$2.prototype.size = function ArraySet_size() {
		return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	/**
	* Add the given string to this set.
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
		var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
		var idx = this._array.length;
		if (!isDuplicate || aAllowDuplicates) this._array.push(aStr);
		if (!isDuplicate) if (hasNativeMap) this._set.set(aStr, idx);
		else this._set[sStr] = idx;
	};
	/**
	* Is the given string a member of this set?
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.has = function ArraySet_has(aStr) {
		if (hasNativeMap) return this._set.has(aStr);
		else {
			var sStr = util$4.toSetString(aStr);
			return has.call(this._set, sStr);
		}
	};
	/**
	* What is the index of the given string in the array?
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
		if (hasNativeMap) {
			var idx = this._set.get(aStr);
			if (idx >= 0) return idx;
		} else {
			var sStr = util$4.toSetString(aStr);
			if (has.call(this._set, sStr)) return this._set[sStr];
		}
		throw new Error("\"" + aStr + "\" is not in the set.");
	};
	/**
	* What is the element at the given index?
	*
	* @param Number aIdx
	*/
	ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
		if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
		throw new Error("No element indexed by " + aIdx);
	};
	/**
	* Returns the array representation of this set (which has the proper indices
	* indicated by indexOf). Note that this is a copy of the internal array used
	* for storing the members so that no one can mess with internal state.
	*/
	ArraySet$2.prototype.toArray = function ArraySet_toArray() {
		return this._array.slice();
	};
	exports.ArraySet = ArraySet$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js": ((exports) => {
	var util$3 = require_util();
	/**
	* Determine whether mappingB is after mappingA with respect to generated
	* position.
	*/
	function generatedPositionAfter(mappingA, mappingB) {
		var lineA = mappingA.generatedLine;
		var lineB = mappingB.generatedLine;
		var columnA = mappingA.generatedColumn;
		var columnB = mappingB.generatedColumn;
		return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	/**
	* A data structure to provide a sorted view of accumulated mappings in a
	* performance conscious manner. It trades a neglibable overhead in general
	* case for a large speedup in case of mappings being added in order.
	*/
	function MappingList$1() {
		this._array = [];
		this._sorted = true;
		this._last = {
			generatedLine: -1,
			generatedColumn: 0
		};
	}
	/**
	* Iterate through internal items. This method takes the same arguments that
	* `Array.prototype.forEach` takes.
	*
	* NOTE: The order of the mappings is NOT guaranteed.
	*/
	MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
		this._array.forEach(aCallback, aThisArg);
	};
	/**
	* Add the given source mapping.
	*
	* @param Object aMapping
	*/
	MappingList$1.prototype.add = function MappingList_add(aMapping) {
		if (generatedPositionAfter(this._last, aMapping)) {
			this._last = aMapping;
			this._array.push(aMapping);
		} else {
			this._sorted = false;
			this._array.push(aMapping);
		}
	};
	/**
	* Returns the flat, sorted array of mappings. The mappings are sorted by
	* generated position.
	*
	* WARNING: This method returns internal data without copying, for
	* performance. The return value must NOT be mutated, and should be treated as
	* an immutable borrow. If you want to take ownership, you must make your own
	* copy.
	*/
	MappingList$1.prototype.toArray = function MappingList_toArray() {
		if (!this._sorted) {
			this._array.sort(util$3.compareByGeneratedPositionsInflated);
			this._sorted = true;
		}
		return this._array;
	};
	exports.MappingList = MappingList$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js": ((exports) => {
	var base64VLQ$1 = require_base64_vlq();
	var util$2 = require_util();
	var ArraySet$1 = require_array_set().ArraySet;
	var MappingList = require_mapping_list().MappingList;
	/**
	* An instance of the SourceMapGenerator represents a source map which is
	* being built incrementally. You may pass an object with the following
	* properties:
	*
	*   - file: The filename of the generated source.
	*   - sourceRoot: A root for all relative URLs in this source map.
	*/
	function SourceMapGenerator$4(aArgs) {
		if (!aArgs) aArgs = {};
		this._file = util$2.getArg(aArgs, "file", null);
		this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
		this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
		this._ignoreInvalidMapping = util$2.getArg(aArgs, "ignoreInvalidMapping", false);
		this._sources = new ArraySet$1();
		this._names = new ArraySet$1();
		this._mappings = new MappingList();
		this._sourcesContents = null;
	}
	SourceMapGenerator$4.prototype._version = 3;
	/**
	* Creates a new SourceMapGenerator based on a SourceMapConsumer
	*
	* @param aSourceMapConsumer The SourceMap.
	*/
	SourceMapGenerator$4.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
		var sourceRoot = aSourceMapConsumer.sourceRoot;
		var generator = new SourceMapGenerator$4(Object.assign(generatorOps || {}, {
			file: aSourceMapConsumer.file,
			sourceRoot
		}));
		aSourceMapConsumer.eachMapping(function(mapping) {
			var newMapping = { generated: {
				line: mapping.generatedLine,
				column: mapping.generatedColumn
			} };
			if (mapping.source != null) {
				newMapping.source = mapping.source;
				if (sourceRoot != null) newMapping.source = util$2.relative(sourceRoot, newMapping.source);
				newMapping.original = {
					line: mapping.originalLine,
					column: mapping.originalColumn
				};
				if (mapping.name != null) newMapping.name = mapping.name;
			}
			generator.addMapping(newMapping);
		});
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var sourceRelative = sourceFile;
			if (sourceRoot !== null) sourceRelative = util$2.relative(sourceRoot, sourceFile);
			if (!generator._sources.has(sourceRelative)) generator._sources.add(sourceRelative);
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) generator.setSourceContent(sourceFile, content);
		});
		return generator;
	};
	/**
	* Add a single mapping from original source line and column to the generated
	* source's line and column for this source map being created. The mapping
	* object should have the following properties:
	*
	*   - generated: An object with the generated line and column positions.
	*   - original: An object with the original line and column positions.
	*   - source: The original source file (relative to the sourceRoot).
	*   - name: An optional original token name for this mapping.
	*/
	SourceMapGenerator$4.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
		var generated = util$2.getArg(aArgs, "generated");
		var original = util$2.getArg(aArgs, "original", null);
		var source = util$2.getArg(aArgs, "source", null);
		var name = util$2.getArg(aArgs, "name", null);
		if (!this._skipValidation) {
			if (this._validateMapping(generated, original, source, name) === false) return;
		}
		if (source != null) {
			source = String(source);
			if (!this._sources.has(source)) this._sources.add(source);
		}
		if (name != null) {
			name = String(name);
			if (!this._names.has(name)) this._names.add(name);
		}
		this._mappings.add({
			generatedLine: generated.line,
			generatedColumn: generated.column,
			originalLine: original != null && original.line,
			originalColumn: original != null && original.column,
			source,
			name
		});
	};
	/**
	* Set the source content for a source file.
	*/
	SourceMapGenerator$4.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
		var source = aSourceFile;
		if (this._sourceRoot != null) source = util$2.relative(this._sourceRoot, source);
		if (aSourceContent != null) {
			if (!this._sourcesContents) this._sourcesContents = Object.create(null);
			this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
		} else if (this._sourcesContents) {
			delete this._sourcesContents[util$2.toSetString(source)];
			if (Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
		}
	};
	/**
	* Applies the mappings of a sub-source-map for a specific source file to the
	* source map being generated. Each mapping to the supplied source file is
	* rewritten using the supplied source map. Note: The resolution for the
	* resulting mappings is the minimium of this map and the supplied map.
	*
	* @param aSourceMapConsumer The source map to be applied.
	* @param aSourceFile Optional. The filename of the source file.
	*        If omitted, SourceMapConsumer's file property will be used.
	* @param aSourceMapPath Optional. The dirname of the path to the source map
	*        to be applied. If relative, it is relative to the SourceMapConsumer.
	*        This parameter is needed when the two source maps aren't in the same
	*        directory, and the source map to be applied contains relative source
	*        paths. If so, those relative source paths need to be rewritten
	*        relative to the SourceMapGenerator.
	*/
	SourceMapGenerator$4.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
		var sourceFile = aSourceFile;
		if (aSourceFile == null) {
			if (aSourceMapConsumer.file == null) throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's \"file\" property. Both were omitted.");
			sourceFile = aSourceMapConsumer.file;
		}
		var sourceRoot = this._sourceRoot;
		if (sourceRoot != null) sourceFile = util$2.relative(sourceRoot, sourceFile);
		var newSources = new ArraySet$1();
		var newNames = new ArraySet$1();
		this._mappings.unsortedForEach(function(mapping) {
			if (mapping.source === sourceFile && mapping.originalLine != null) {
				var original = aSourceMapConsumer.originalPositionFor({
					line: mapping.originalLine,
					column: mapping.originalColumn
				});
				if (original.source != null) {
					mapping.source = original.source;
					if (aSourceMapPath != null) mapping.source = util$2.join(aSourceMapPath, mapping.source);
					if (sourceRoot != null) mapping.source = util$2.relative(sourceRoot, mapping.source);
					mapping.originalLine = original.line;
					mapping.originalColumn = original.column;
					if (original.name != null) mapping.name = original.name;
				}
			}
			var source = mapping.source;
			if (source != null && !newSources.has(source)) newSources.add(source);
			var name = mapping.name;
			if (name != null && !newNames.has(name)) newNames.add(name);
		}, this);
		this._sources = newSources;
		this._names = newNames;
		aSourceMapConsumer.sources.forEach(function(sourceFile$1) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile$1);
			if (content != null) {
				if (aSourceMapPath != null) sourceFile$1 = util$2.join(aSourceMapPath, sourceFile$1);
				if (sourceRoot != null) sourceFile$1 = util$2.relative(sourceRoot, sourceFile$1);
				this.setSourceContent(sourceFile$1, content);
			}
		}, this);
	};
	/**
	* A mapping can have one of the three levels of data:
	*
	*   1. Just the generated position.
	*   2. The Generated position, original position, and original source.
	*   3. Generated and original position, original source, as well as a name
	*      token.
	*
	* To maintain consistency, we validate that any new mapping being added falls
	* in to one of these categories.
	*/
	SourceMapGenerator$4.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
		if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
			var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) console.warn(message);
				return false;
			} else throw new Error(message);
		}
		if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) return;
		else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
		else {
			var message = "Invalid mapping: " + JSON.stringify({
				generated: aGenerated,
				source: aSource,
				original: aOriginal,
				name: aName
			});
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) console.warn(message);
				return false;
			} else throw new Error(message);
		}
	};
	/**
	* Serialize the accumulated mappings in to the stream of base 64 VLQs
	* specified by the source map format.
	*/
	SourceMapGenerator$4.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
		var previousGeneratedColumn = 0;
		var previousGeneratedLine = 1;
		var previousOriginalColumn = 0;
		var previousOriginalLine = 0;
		var previousName = 0;
		var previousSource = 0;
		var result = "";
		var next;
		var mapping;
		var nameIdx;
		var sourceIdx;
		var mappings = this._mappings.toArray();
		for (var i$1 = 0, len = mappings.length; i$1 < len; i$1++) {
			mapping = mappings[i$1];
			next = "";
			if (mapping.generatedLine !== previousGeneratedLine) {
				previousGeneratedColumn = 0;
				while (mapping.generatedLine !== previousGeneratedLine) {
					next += ";";
					previousGeneratedLine++;
				}
			} else if (i$1 > 0) {
				if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i$1 - 1])) continue;
				next += ",";
			}
			next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
			previousGeneratedColumn = mapping.generatedColumn;
			if (mapping.source != null) {
				sourceIdx = this._sources.indexOf(mapping.source);
				next += base64VLQ$1.encode(sourceIdx - previousSource);
				previousSource = sourceIdx;
				next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
				previousOriginalLine = mapping.originalLine - 1;
				next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
				previousOriginalColumn = mapping.originalColumn;
				if (mapping.name != null) {
					nameIdx = this._names.indexOf(mapping.name);
					next += base64VLQ$1.encode(nameIdx - previousName);
					previousName = nameIdx;
				}
			}
			result += next;
		}
		return result;
	};
	SourceMapGenerator$4.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
		return aSources.map(function(source) {
			if (!this._sourcesContents) return null;
			if (aSourceRoot != null) source = util$2.relative(aSourceRoot, source);
			var key = util$2.toSetString(source);
			return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
		}, this);
	};
	/**
	* Externalize the source map.
	*/
	SourceMapGenerator$4.prototype.toJSON = function SourceMapGenerator_toJSON() {
		var map$6 = {
			version: this._version,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings()
		};
		if (this._file != null) map$6.file = this._file;
		if (this._sourceRoot != null) map$6.sourceRoot = this._sourceRoot;
		if (this._sourcesContents) map$6.sourcesContent = this._generateSourcesContent(map$6.sources, map$6.sourceRoot);
		return map$6;
	};
	/**
	* Render the source map being generated to a string.
	*/
	SourceMapGenerator$4.prototype.toString = function SourceMapGenerator_toString() {
		return JSON.stringify(this.toJSON());
	};
	exports.SourceMapGenerator = SourceMapGenerator$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js
var require_binary_search = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js": ((exports) => {
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	/**
	* Recursive implementation of binary search.
	*
	* @param aLow Indices here and lower do not contain the needle.
	* @param aHigh Indices here and higher do not contain the needle.
	* @param aNeedle The element being searched for.
	* @param aHaystack The non-empty array being searched.
	* @param aCompare Function which takes two elements and returns -1, 0, or 1.
	* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*/
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		var cmp = aCompare(aNeedle, aHaystack[mid], true);
		if (cmp === 0) return mid;
		else if (cmp > 0) {
			if (aHigh - mid > 1) return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports.LEAST_UPPER_BOUND) return aHigh < aHaystack.length ? aHigh : -1;
			else return mid;
		} else {
			if (mid - aLow > 1) return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports.LEAST_UPPER_BOUND) return mid;
			else return aLow < 0 ? -1 : aLow;
		}
	}
	/**
	* This is an implementation of binary search which will always try and return
	* the index of the closest element if there is no exact hit. This is because
	* mappings between original and generated line/col pairs are single points,
	* and there is an implicit region between each of them, so a miss just means
	* that you aren't on the very start of a region.
	*
	* @param aNeedle The element you are looking for.
	* @param aHaystack The array that is being searched.
	* @param aCompare A function which takes the needle and an element in the
	*     array and returns -1, 0, or 1 depending on whether the needle is less
	*     than, equal to, or greater than the element, respectively.
	* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	*/
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		if (aHaystack.length === 0) return -1;
		var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		if (index < 0) return -1;
		while (index - 1 >= 0) {
			if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) break;
			--index;
		}
		return index;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js": ((exports) => {
	function SortTemplate(comparator) {
		/**
		* Swap the elements indexed by `x` and `y` in the array `ary`.
		*
		* @param {Array} ary
		*        The array.
		* @param {Number} x
		*        The index of the first item.
		* @param {Number} y
		*        The index of the second item.
		*/
		function swap(ary, x$3, y) {
			var temp = ary[x$3];
			ary[x$3] = ary[y];
			ary[y] = temp;
		}
		/**
		* Returns a random integer within the range `low .. high` inclusive.
		*
		* @param {Number} low
		*        The lower bound on the range.
		* @param {Number} high
		*        The upper bound on the range.
		*/
		function randomIntInRange(low, high) {
			return Math.round(low + Math.random() * (high - low));
		}
		/**
		* The Quick Sort algorithm.
		*
		* @param {Array} ary
		*        An array to sort.
		* @param {function} comparator
		*        Function to use to compare two items.
		* @param {Number} p
		*        Start index of the array
		* @param {Number} r
		*        End index of the array
		*/
		function doQuickSort(ary, comparator$1, p$2, r) {
			if (p$2 < r) {
				var pivotIndex = randomIntInRange(p$2, r);
				var i$1 = p$2 - 1;
				swap(ary, pivotIndex, r);
				var pivot = ary[r];
				for (var j$2 = p$2; j$2 < r; j$2++) if (comparator$1(ary[j$2], pivot, false) <= 0) {
					i$1 += 1;
					swap(ary, i$1, j$2);
				}
				swap(ary, i$1 + 1, j$2);
				var q$3 = i$1 + 1;
				doQuickSort(ary, comparator$1, p$2, q$3 - 1);
				doQuickSort(ary, comparator$1, q$3 + 1, r);
			}
		}
		return doQuickSort;
	}
	function cloneSort(comparator) {
		let template = SortTemplate.toString();
		return new Function(`return ${template}`)()(comparator);
	}
	/**
	* Sort the given array in-place with the given comparator function.
	*
	* @param {Array} ary
	*        An array to sort.
	* @param {function} comparator
	*        Function to use to compare two items.
	*/
	let sortCache = /* @__PURE__ */ new WeakMap();
	exports.quickSort = function(ary, comparator, start = 0) {
		let doQuickSort = sortCache.get(comparator);
		if (doQuickSort === void 0) {
			doQuickSort = cloneSort(comparator);
			sortCache.set(comparator, doQuickSort);
		}
		doQuickSort(ary, comparator, start, ary.length - 1);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js": ((exports) => {
	var util$1 = require_util();
	var binarySearch = require_binary_search();
	var ArraySet = require_array_set().ArraySet;
	var base64VLQ = require_base64_vlq();
	var quickSort = require_quick_sort().quickSort;
	function SourceMapConsumer$3(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	SourceMapConsumer$3.fromSourceMap = function(aSourceMap, aSourceMapURL) {
		return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	SourceMapConsumer$3.prototype._version = 3;
	SourceMapConsumer$3.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer$3.prototype, "_generatedMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__generatedMappings;
		}
	});
	SourceMapConsumer$3.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer$3.prototype, "_originalMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__originalMappings;
		}
	});
	SourceMapConsumer$3.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		var c$2 = aStr.charAt(index);
		return c$2 === ";" || c$2 === ",";
	};
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	SourceMapConsumer$3.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		throw new Error("Subclasses must implement _parseMappings");
	};
	SourceMapConsumer$3.GENERATED_ORDER = 1;
	SourceMapConsumer$3.ORIGINAL_ORDER = 2;
	SourceMapConsumer$3.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer$3.LEAST_UPPER_BOUND = 2;
	/**
	* Iterate over each mapping between an original source/line/column and a
	* generated line/column in this source map.
	*
	* @param Function aCallback
	*        The function that is called with each mapping.
	* @param Object aContext
	*        Optional. If specified, this object will be the value of `this` every
	*        time that `aCallback` is called.
	* @param aOrder
	*        Either `SourceMapConsumer.GENERATED_ORDER` or
	*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	*        iterate over the mappings sorted by the generated file's line/column
	*        order or the original's source/line/column order, respectively. Defaults to
	*        `SourceMapConsumer.GENERATED_ORDER`.
	*/
	SourceMapConsumer$3.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		var context = aContext || null;
		var order = aOrder || SourceMapConsumer$3.GENERATED_ORDER;
		var mappings;
		switch (order) {
			case SourceMapConsumer$3.GENERATED_ORDER:
				mappings = this._generatedMappings;
				break;
			case SourceMapConsumer$3.ORIGINAL_ORDER:
				mappings = this._originalMappings;
				break;
			default: throw new Error("Unknown order of iteration.");
		}
		var sourceRoot = this.sourceRoot;
		var boundCallback = aCallback.bind(context);
		var names = this._names;
		var sources = this._sources;
		var sourceMapURL = this._sourceMapURL;
		for (var i$1 = 0, n$1 = mappings.length; i$1 < n$1; i$1++) {
			var mapping = mappings[i$1];
			var source = mapping.source === null ? null : sources.at(mapping.source);
			if (source !== null) source = util$1.computeSourceURL(sourceRoot, source, sourceMapURL);
			boundCallback({
				source,
				generatedLine: mapping.generatedLine,
				generatedColumn: mapping.generatedColumn,
				originalLine: mapping.originalLine,
				originalColumn: mapping.originalColumn,
				name: mapping.name === null ? null : names.at(mapping.name)
			});
		}
	};
	/**
	* Returns all generated line and column information for the original source,
	* line, and column provided. If no column is provided, returns all mappings
	* corresponding to a either the line we are searching for or the next
	* closest line that has any mappings. Otherwise, returns all mappings
	* corresponding to the given line and either the column we are searching for
	* or the next closest column that has any offsets.
	*
	* The only argument is an object with the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number is 1-based.
	*   - column: Optional. the column number in the original source.
	*    The column number is 0-based.
	*
	* and an array of objects is returned, each with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*    line number is 1-based.
	*   - column: The column number in the generated source, or null.
	*    The column number is 0-based.
	*/
	SourceMapConsumer$3.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		var line = util$1.getArg(aArgs, "line");
		var needle = {
			source: util$1.getArg(aArgs, "source"),
			originalLine: line,
			originalColumn: util$1.getArg(aArgs, "column", 0)
		};
		needle.source = this._findSourceIndex(needle.source);
		if (needle.source < 0) return [];
		var mappings = [];
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (aArgs.column === void 0) {
				var originalLine = mapping.originalLine;
				while (mapping && mapping.originalLine === originalLine) {
					mappings.push({
						line: util$1.getArg(mapping, "generatedLine", null),
						column: util$1.getArg(mapping, "generatedColumn", null),
						lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			} else {
				var originalColumn = mapping.originalColumn;
				while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
					mappings.push({
						line: util$1.getArg(mapping, "generatedLine", null),
						column: util$1.getArg(mapping, "generatedColumn", null),
						lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			}
		}
		return mappings;
	};
	exports.SourceMapConsumer = SourceMapConsumer$3;
	/**
	* A BasicSourceMapConsumer instance represents a parsed source map which we can
	* query for information about the original file positions by giving it a file
	* position in the generated source.
	*
	* The first parameter is the raw source map (either as a JSON string, or
	* already parsed to an object). According to the spec, source maps have the
	* following attributes:
	*
	*   - version: Which version of the source map spec this map is following.
	*   - sources: An array of URLs to the original source files.
	*   - names: An array of identifiers which can be referrenced by individual mappings.
	*   - sourceRoot: Optional. The URL root from which all sources are relative.
	*   - sourcesContent: Optional. An array of contents of the original source files.
	*   - mappings: A string of base64 VLQs which contain the actual mappings.
	*   - file: Optional. The generated file this source map is associated with.
	*
	* Here is an example source map, taken from the source map spec[0]:
	*
	*     {
	*       version : 3,
	*       file: "out.js",
	*       sourceRoot : "",
	*       sources: ["foo.js", "bar.js"],
	*       names: ["src", "maps", "are", "fun"],
	*       mappings: "AA,AB;;ABCDE;"
	*     }
	*
	* The second parameter, if given, is a string whose value is the URL
	* at which the source map was found.  This URL is used to compute the
	* sources array.
	*
	* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	*/
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		var version$1 = util$1.getArg(sourceMap, "version");
		var sources = util$1.getArg(sourceMap, "sources");
		var names = util$1.getArg(sourceMap, "names", []);
		var sourceRoot = util$1.getArg(sourceMap, "sourceRoot", null);
		var sourcesContent = util$1.getArg(sourceMap, "sourcesContent", null);
		var mappings = util$1.getArg(sourceMap, "mappings");
		var file = util$1.getArg(sourceMap, "file", null);
		if (version$1 != this._version) throw new Error("Unsupported version: " + version$1);
		if (sourceRoot) sourceRoot = util$1.normalize(sourceRoot);
		sources = sources.map(String).map(util$1.normalize).map(function(source) {
			return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source) ? util$1.relative(sourceRoot, source) : source;
		});
		this._names = ArraySet.fromArray(names.map(String), true);
		this._sources = ArraySet.fromArray(sources, true);
		this._absoluteSources = this._sources.toArray().map(function(s) {
			return util$1.computeSourceURL(sourceRoot, s, aSourceMapURL);
		});
		this.sourceRoot = sourceRoot;
		this.sourcesContent = sourcesContent;
		this._mappings = mappings;
		this._sourceMapURL = aSourceMapURL;
		this.file = file;
	}
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$3.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$3;
	/**
	* Utility function to find the index of a source.  Returns -1 if not
	* found.
	*/
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
		if (this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
		var i$1;
		for (i$1 = 0; i$1 < this._absoluteSources.length; ++i$1) if (this._absoluteSources[i$1] == aSource) return i$1;
		return -1;
	};
	/**
	* Create a BasicSourceMapConsumer from a SourceMapGenerator.
	*
	* @param SourceMapGenerator aSourceMap
	*        The source map that will be consumed.
	* @param String aSourceMapURL
	*        The URL at which the source map can be found (optional)
	* @returns BasicSourceMapConsumer
	*/
	BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
		var smc = Object.create(BasicSourceMapConsumer.prototype);
		var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		smc.sourceRoot = aSourceMap._sourceRoot;
		smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
		smc.file = aSourceMap._file;
		smc._sourceMapURL = aSourceMapURL;
		smc._absoluteSources = smc._sources.toArray().map(function(s) {
			return util$1.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
		});
		var generatedMappings = aSourceMap._mappings.toArray().slice();
		var destGeneratedMappings = smc.__generatedMappings = [];
		var destOriginalMappings = smc.__originalMappings = [];
		for (var i$1 = 0, length = generatedMappings.length; i$1 < length; i$1++) {
			var srcMapping = generatedMappings[i$1];
			var destMapping = new Mapping();
			destMapping.generatedLine = srcMapping.generatedLine;
			destMapping.generatedColumn = srcMapping.generatedColumn;
			if (srcMapping.source) {
				destMapping.source = sources.indexOf(srcMapping.source);
				destMapping.originalLine = srcMapping.originalLine;
				destMapping.originalColumn = srcMapping.originalColumn;
				if (srcMapping.name) destMapping.name = names.indexOf(srcMapping.name);
				destOriginalMappings.push(destMapping);
			}
			destGeneratedMappings.push(destMapping);
		}
		quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
		return smc;
	};
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	BasicSourceMapConsumer.prototype._version = 3;
	/**
	* The list of original sources.
	*/
	Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
		return this._absoluteSources.slice();
	} });
	/**
	* Provide the JIT with a nice shape / hidden class.
	*/
	function Mapping() {
		this.generatedLine = 0;
		this.generatedColumn = 0;
		this.source = null;
		this.originalLine = null;
		this.originalColumn = null;
		this.name = null;
	}
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	const compareGenerated = util$1.compareByGeneratedPositionsDeflatedNoLine;
	function sortGenerated(array, start) {
		let l$2 = array.length;
		let n$1 = array.length - start;
		if (n$1 <= 1) return;
		else if (n$1 == 2) {
			let a = array[start];
			let b$1 = array[start + 1];
			if (compareGenerated(a, b$1) > 0) {
				array[start] = b$1;
				array[start + 1] = a;
			}
		} else if (n$1 < 20) for (let i$1 = start; i$1 < l$2; i$1++) for (let j$2 = i$1; j$2 > start; j$2--) {
			let a = array[j$2 - 1];
			let b$1 = array[j$2];
			if (compareGenerated(a, b$1) <= 0) break;
			array[j$2 - 1] = b$1;
			array[j$2] = a;
		}
		else quickSort(array, compareGenerated, start);
	}
	BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		var generatedLine = 1;
		var previousGeneratedColumn = 0;
		var previousOriginalLine = 0;
		var previousOriginalColumn = 0;
		var previousSource = 0;
		var previousName = 0;
		var length = aStr.length;
		var index = 0;
		var temp = {};
		var originalMappings = [];
		var generatedMappings = [], mapping, segment, end, value;
		let subarrayStart = 0;
		while (index < length) if (aStr.charAt(index) === ";") {
			generatedLine++;
			index++;
			previousGeneratedColumn = 0;
			sortGenerated(generatedMappings, subarrayStart);
			subarrayStart = generatedMappings.length;
		} else if (aStr.charAt(index) === ",") index++;
		else {
			mapping = new Mapping();
			mapping.generatedLine = generatedLine;
			for (end = index; end < length; end++) if (this._charIsMappingSeparator(aStr, end)) break;
			aStr.slice(index, end);
			segment = [];
			while (index < end) {
				base64VLQ.decode(aStr, index, temp);
				value = temp.value;
				index = temp.rest;
				segment.push(value);
			}
			if (segment.length === 2) throw new Error("Found a source, but no line and column");
			if (segment.length === 3) throw new Error("Found a source and line, but no column");
			mapping.generatedColumn = previousGeneratedColumn + segment[0];
			previousGeneratedColumn = mapping.generatedColumn;
			if (segment.length > 1) {
				mapping.source = previousSource + segment[1];
				previousSource += segment[1];
				mapping.originalLine = previousOriginalLine + segment[2];
				previousOriginalLine = mapping.originalLine;
				mapping.originalLine += 1;
				mapping.originalColumn = previousOriginalColumn + segment[3];
				previousOriginalColumn = mapping.originalColumn;
				if (segment.length > 4) {
					mapping.name = previousName + segment[4];
					previousName += segment[4];
				}
			}
			generatedMappings.push(mapping);
			if (typeof mapping.originalLine === "number") {
				let currentSource = mapping.source;
				while (originalMappings.length <= currentSource) originalMappings.push(null);
				if (originalMappings[currentSource] === null) originalMappings[currentSource] = [];
				originalMappings[currentSource].push(mapping);
			}
		}
		sortGenerated(generatedMappings, subarrayStart);
		this.__generatedMappings = generatedMappings;
		for (var i$1 = 0; i$1 < originalMappings.length; i$1++) if (originalMappings[i$1] != null) quickSort(originalMappings[i$1], util$1.compareByOriginalPositionsNoSource);
		this.__originalMappings = [].concat(...originalMappings);
	};
	/**
	* Find the mapping that best matches the hypothetical "needle" mapping that
	* we are searching for in the given "haystack" of mappings.
	*/
	BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
		if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
		if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
		return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	};
	/**
	* Compute the last column for each generated mapping. The last column is
	* inclusive.
	*/
	BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
		for (var index = 0; index < this._generatedMappings.length; ++index) {
			var mapping = this._generatedMappings[index];
			if (index + 1 < this._generatedMappings.length) {
				var nextMapping = this._generatedMappings[index + 1];
				if (mapping.generatedLine === nextMapping.generatedLine) {
					mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
					continue;
				}
			}
			mapping.lastGeneratedColumn = Infinity;
		}
	};
	/**
	* Returns the original source, line, and column information for the generated
	* source's line and column positions provided. The only argument is an object
	* with the following properties:
	*
	*   - line: The line number in the generated source.  The line number
	*     is 1-based.
	*   - column: The column number in the generated source.  The column
	*     number is 0-based.
	*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	*
	* and an object is returned with the following properties:
	*
	*   - source: The original source file, or null.
	*   - line: The line number in the original source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the original source, or null.  The
	*     column number is 0-based.
	*   - name: The original identifier, or null.
	*/
	BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$1.getArg(aArgs, "line"),
			generatedColumn: util$1.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, "bias", SourceMapConsumer$3.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._generatedMappings[index];
			if (mapping.generatedLine === needle.generatedLine) {
				var source = util$1.getArg(mapping, "source", null);
				if (source !== null) {
					source = this._sources.at(source);
					source = util$1.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
				}
				var name = util$1.getArg(mapping, "name", null);
				if (name !== null) name = this._names.at(name);
				return {
					source,
					line: util$1.getArg(mapping, "originalLine", null),
					column: util$1.getArg(mapping, "originalColumn", null),
					name
				};
			}
		}
		return {
			source: null,
			line: null,
			column: null,
			name: null
		};
	};
	/**
	* Return true if we have the source content for every source in the source
	* map, false otherwise.
	*/
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
		if (!this.sourcesContent) return false;
		return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
			return sc == null;
		});
	};
	/**
	* Returns the original source content. The only argument is the url of the
	* original source file. Returns null if no original source content is
	* available.
	*/
	BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		if (!this.sourcesContent) return null;
		var index = this._findSourceIndex(aSource);
		if (index >= 0) return this.sourcesContent[index];
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
		var url;
		if (this.sourceRoot != null && (url = util$1.urlParse(this.sourceRoot))) {
			var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
			if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
			if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
		}
		if (nullOnMissing) return null;
		else throw new Error("\"" + relativeSource + "\" is not in the SourceMap.");
	};
	/**
	* Returns the generated line and column information for the original source,
	* line, and column positions provided. The only argument is an object with
	* the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number
	*     is 1-based.
	*   - column: The column number in the original source.  The column
	*     number is 0-based.
	*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	*
	* and an object is returned with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the generated source, or null.
	*     The column number is 0-based.
	*/
	BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
		var source = util$1.getArg(aArgs, "source");
		source = this._findSourceIndex(source);
		if (source < 0) return {
			line: null,
			column: null,
			lastColumn: null
		};
		var needle = {
			source,
			originalLine: util$1.getArg(aArgs, "line"),
			originalColumn: util$1.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, "bias", SourceMapConsumer$3.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (mapping.source === needle.source) return {
				line: util$1.getArg(mapping, "generatedLine", null),
				column: util$1.getArg(mapping, "generatedColumn", null),
				lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
			};
		}
		return {
			line: null,
			column: null,
			lastColumn: null
		};
	};
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	/**
	* An IndexedSourceMapConsumer instance represents a parsed source map which
	* we can query for information. It differs from BasicSourceMapConsumer in
	* that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	* input.
	*
	* The first parameter is a raw source map (either as a JSON string, or already
	* parsed to an object). According to the spec for indexed source maps, they
	* have the following attributes:
	*
	*   - version: Which version of the source map spec this map is following.
	*   - file: Optional. The generated file this source map is associated with.
	*   - sections: A list of section definitions.
	*
	* Each value under the "sections" field has two fields:
	*   - offset: The offset into the original specified at which this section
	*       begins to apply, defined as an object with a "line" and "column"
	*       field.
	*   - map: A source map definition. This source map could also be indexed,
	*       but doesn't have to be.
	*
	* Instead of the "map" field, it's also possible to have a "url" field
	* specifying a URL to retrieve a source map from, but that's currently
	* unsupported.
	*
	* Here's an example source map, taken from the source map spec[0], but
	* modified to omit a section which uses the "url" field.
	*
	*  {
	*    version : 3,
	*    file: "app.js",
	*    sections: [{
	*      offset: {line:100, column:10},
	*      map: {
	*        version : 3,
	*        file: "section.js",
	*        sources: ["foo.js", "bar.js"],
	*        names: ["src", "maps", "are", "fun"],
	*        mappings: "AAAA,E;;ABCDE;"
	*      }
	*    }],
	*  }
	*
	* The second parameter, if given, is a string whose value is the URL
	* at which the source map was found.  This URL is used to compute the
	* sources array.
	*
	* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	*/
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		var version$1 = util$1.getArg(sourceMap, "version");
		var sections = util$1.getArg(sourceMap, "sections");
		if (version$1 != this._version) throw new Error("Unsupported version: " + version$1);
		this._sources = new ArraySet();
		this._names = new ArraySet();
		var lastOffset = {
			line: -1,
			column: 0
		};
		this._sections = sections.map(function(s) {
			if (s.url) throw new Error("Support for url field in sections not implemented.");
			var offset = util$1.getArg(s, "offset");
			var offsetLine = util$1.getArg(offset, "line");
			var offsetColumn = util$1.getArg(offset, "column");
			if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
			lastOffset = offset;
			return {
				generatedOffset: {
					generatedLine: offsetLine + 1,
					generatedColumn: offsetColumn + 1
				},
				consumer: new SourceMapConsumer$3(util$1.getArg(s, "map"), aSourceMapURL)
			};
		});
	}
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$3.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$3;
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	IndexedSourceMapConsumer.prototype._version = 3;
	/**
	* The list of original sources.
	*/
	Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
		var sources = [];
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) for (var j$2 = 0; j$2 < this._sections[i$1].consumer.sources.length; j$2++) sources.push(this._sections[i$1].consumer.sources[j$2]);
		return sources;
	} });
	/**
	* Returns the original source, line, and column information for the generated
	* source's line and column positions provided. The only argument is an object
	* with the following properties:
	*
	*   - line: The line number in the generated source.  The line number
	*     is 1-based.
	*   - column: The column number in the generated source.  The column
	*     number is 0-based.
	*
	* and an object is returned with the following properties:
	*
	*   - source: The original source file, or null.
	*   - line: The line number in the original source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the original source, or null.  The
	*     column number is 0-based.
	*   - name: The original identifier, or null.
	*/
	IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$1.getArg(aArgs, "line"),
			generatedColumn: util$1.getArg(aArgs, "column")
		};
		var sectionIndex = binarySearch.search(needle, this._sections, function(needle$1, section$1) {
			var cmp = needle$1.generatedLine - section$1.generatedOffset.generatedLine;
			if (cmp) return cmp;
			return needle$1.generatedColumn - section$1.generatedOffset.generatedColumn;
		});
		var section = this._sections[sectionIndex];
		if (!section) return {
			source: null,
			line: null,
			column: null,
			name: null
		};
		return section.consumer.originalPositionFor({
			line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
			column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
			bias: aArgs.bias
		});
	};
	/**
	* Return true if we have the source content for every source in the source
	* map, false otherwise.
	*/
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		return this._sections.every(function(s) {
			return s.consumer.hasContentsOfAllSources();
		});
	};
	/**
	* Returns the original source content. The only argument is the url of the
	* original source file. Returns null if no original source content is
	* available.
	*/
	IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
			var content = this._sections[i$1].consumer.sourceContentFor(aSource, true);
			if (content || content === "") return content;
		}
		if (nullOnMissing) return null;
		else throw new Error("\"" + aSource + "\" is not in the SourceMap.");
	};
	/**
	* Returns the generated line and column information for the original source,
	* line, and column positions provided. The only argument is an object with
	* the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number
	*     is 1-based.
	*   - column: The column number in the original source.  The column
	*     number is 0-based.
	*
	* and an object is returned with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*     line number is 1-based. 
	*   - column: The column number in the generated source, or null.
	*     The column number is 0-based.
	*/
	IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
			var section = this._sections[i$1];
			if (section.consumer._findSourceIndex(util$1.getArg(aArgs, "source")) === -1) continue;
			var generatedPosition = section.consumer.generatedPositionFor(aArgs);
			if (generatedPosition) return {
				line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
				column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
			};
		}
		return {
			line: null,
			column: null
		};
	};
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		this.__generatedMappings = [];
		this.__originalMappings = [];
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
			var section = this._sections[i$1];
			var sectionMappings = section.consumer._generatedMappings;
			for (var j$2 = 0; j$2 < sectionMappings.length; j$2++) {
				var mapping = sectionMappings[j$2];
				var source = section.consumer._sources.at(mapping.source);
				if (source !== null) source = util$1.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
				this._sources.add(source);
				source = this._sources.indexOf(source);
				var name = null;
				if (mapping.name) {
					name = section.consumer._names.at(mapping.name);
					this._names.add(name);
					name = this._names.indexOf(name);
				}
				var adjustedMapping = {
					source,
					generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
					generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
					originalLine: mapping.originalLine,
					originalColumn: mapping.originalColumn,
					name
				};
				this.__generatedMappings.push(adjustedMapping);
				if (typeof adjustedMapping.originalLine === "number") this.__originalMappings.push(adjustedMapping);
			}
		}
		quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
		quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
	};
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js
var require_source_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js": ((exports) => {
	var SourceMapGenerator$3 = require_source_map_generator().SourceMapGenerator;
	var util = require_util();
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";
	/**
	* SourceNodes provide a way to abstract over interpolating/concatenating
	* snippets of generated JavaScript source code while maintaining the line and
	* column information associated with the original source code.
	*
	* @param aLine The original line number.
	* @param aColumn The original column number.
	* @param aSource The original source's filename.
	* @param aChunks Optional. An array of strings which are snippets of
	*        generated JS, or other SourceNodes.
	* @param aName The original identifier.
	*/
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
		this.children = [];
		this.sourceContents = {};
		this.line = aLine == null ? null : aLine;
		this.column = aColumn == null ? null : aColumn;
		this.source = aSource == null ? null : aSource;
		this.name = aName == null ? null : aName;
		this[isSourceNode] = true;
		if (aChunks != null) this.add(aChunks);
	}
	/**
	* Creates a SourceNode from generated code and a SourceMapConsumer.
	*
	* @param aGeneratedCode The generated code
	* @param aSourceMapConsumer The SourceMap for the generated code
	* @param aRelativePath Optional. The path that relative sources in the
	*        SourceMapConsumer should be relative to.
	*/
	SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
		var node = new SourceNode();
		var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		var remainingLinesIndex = 0;
		var shiftNextLine = function() {
			var lineContents = getNextLine();
			var newLine = getNextLine() || "";
			return lineContents + newLine;
			function getNextLine() {
				return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
			}
		};
		var lastGeneratedLine = 1, lastGeneratedColumn = 0;
		var lastMapping = null;
		aSourceMapConsumer.eachMapping(function(mapping) {
			if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) {
				addMappingWithCode(lastMapping, shiftNextLine());
				lastGeneratedLine++;
				lastGeneratedColumn = 0;
			} else {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
				addMappingWithCode(lastMapping, code);
				lastMapping = mapping;
				return;
			}
			while (lastGeneratedLine < mapping.generatedLine) {
				node.add(shiftNextLine());
				lastGeneratedLine++;
			}
			if (lastGeneratedColumn < mapping.generatedColumn) {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				node.add(nextLine.substr(0, mapping.generatedColumn));
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
			}
			lastMapping = mapping;
		}, this);
		if (remainingLinesIndex < remainingLines.length) {
			if (lastMapping) addMappingWithCode(lastMapping, shiftNextLine());
			node.add(remainingLines.splice(remainingLinesIndex).join(""));
		}
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aRelativePath != null) sourceFile = util.join(aRelativePath, sourceFile);
				node.setSourceContent(sourceFile, content);
			}
		});
		return node;
		function addMappingWithCode(mapping, code) {
			if (mapping === null || mapping.source === void 0) node.add(code);
			else {
				var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
				node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
			}
		}
	};
	/**
	* Add a chunk of generated JS to this source node.
	*
	* @param aChunk A string snippet of generated JS code, another instance of
	*        SourceNode, or an array where each member is one of those things.
	*/
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
		if (Array.isArray(aChunk)) aChunk.forEach(function(chunk) {
			this.add(chunk);
		}, this);
		else if (aChunk[isSourceNode] || typeof aChunk === "string") {
			if (aChunk) this.children.push(aChunk);
		} else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	/**
	* Add a chunk of generated JS to the beginning of this source node.
	*
	* @param aChunk A string snippet of generated JS code, another instance of
	*        SourceNode, or an array where each member is one of those things.
	*/
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
		if (Array.isArray(aChunk)) for (var i$1 = aChunk.length - 1; i$1 >= 0; i$1--) this.prepend(aChunk[i$1]);
		else if (aChunk[isSourceNode] || typeof aChunk === "string") this.children.unshift(aChunk);
		else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	/**
	* Walk over the tree of JS snippets in this node and its children. The
	* walking function is called once for each snippet of JS and is passed that
	* snippet and the its original associated source's line/column location.
	*
	* @param aFn The traversal function.
	*/
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
		var chunk;
		for (var i$1 = 0, len = this.children.length; i$1 < len; i$1++) {
			chunk = this.children[i$1];
			if (chunk[isSourceNode]) chunk.walk(aFn);
			else if (chunk !== "") aFn(chunk, {
				source: this.source,
				line: this.line,
				column: this.column,
				name: this.name
			});
		}
	};
	/**
	* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	* each of `this.children`.
	*
	* @param aSep The separator.
	*/
	SourceNode.prototype.join = function SourceNode_join(aSep) {
		var newChildren;
		var i$1;
		var len = this.children.length;
		if (len > 0) {
			newChildren = [];
			for (i$1 = 0; i$1 < len - 1; i$1++) {
				newChildren.push(this.children[i$1]);
				newChildren.push(aSep);
			}
			newChildren.push(this.children[i$1]);
			this.children = newChildren;
		}
		return this;
	};
	/**
	* Call String.prototype.replace on the very right-most source snippet. Useful
	* for trimming whitespace from the end of a source node, etc.
	*
	* @param aPattern The pattern to replace.
	* @param aReplacement The thing to replace the pattern with.
	*/
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
		var lastChild = this.children[this.children.length - 1];
		if (lastChild[isSourceNode]) lastChild.replaceRight(aPattern, aReplacement);
		else if (typeof lastChild === "string") this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
		else this.children.push("".replace(aPattern, aReplacement));
		return this;
	};
	/**
	* Set the source content for a source file. This will be added to the SourceMapGenerator
	* in the sourcesContent field.
	*
	* @param aSourceFile The filename of the source file
	* @param aSourceContent The content of the source file
	*/
	SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
		this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	};
	/**
	* Walk over the tree of SourceNodes. The walking function is called for each
	* source file content and is passed the filename and source content.
	*
	* @param aFn The traversal function.
	*/
	SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
		for (var i$1 = 0, len = this.children.length; i$1 < len; i$1++) if (this.children[i$1][isSourceNode]) this.children[i$1].walkSourceContents(aFn);
		var sources = Object.keys(this.sourceContents);
		for (var i$1 = 0, len = sources.length; i$1 < len; i$1++) aFn(util.fromSetString(sources[i$1]), this.sourceContents[sources[i$1]]);
	};
	/**
	* Return the string representation of this source node. Walks over the tree
	* and concatenates all the various snippets together to one string.
	*/
	SourceNode.prototype.toString = function SourceNode_toString() {
		var str = "";
		this.walk(function(chunk) {
			str += chunk;
		});
		return str;
	};
	/**
	* Returns the string representation of this source node along with a source
	* map.
	*/
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
		var generated = {
			code: "",
			line: 1,
			column: 0
		};
		var map$6 = new SourceMapGenerator$3(aArgs);
		var sourceMappingActive = false;
		var lastOriginalSource = null;
		var lastOriginalLine = null;
		var lastOriginalColumn = null;
		var lastOriginalName = null;
		this.walk(function(chunk, original) {
			generated.code += chunk;
			if (original.source !== null && original.line !== null && original.column !== null) {
				if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) map$6.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
				lastOriginalSource = original.source;
				lastOriginalLine = original.line;
				lastOriginalColumn = original.column;
				lastOriginalName = original.name;
				sourceMappingActive = true;
			} else if (sourceMappingActive) {
				map$6.addMapping({ generated: {
					line: generated.line,
					column: generated.column
				} });
				lastOriginalSource = null;
				sourceMappingActive = false;
			}
			for (var idx = 0, length = chunk.length; idx < length; idx++) if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
				generated.line++;
				generated.column = 0;
				if (idx + 1 === length) {
					lastOriginalSource = null;
					sourceMappingActive = false;
				} else if (sourceMappingActive) map$6.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
			} else generated.column++;
		});
		this.walkSourceContents(function(sourceFile, sourceContent) {
			map$6.setSourceContent(sourceFile, sourceContent);
		});
		return {
			code: generated.code,
			map: map$6
		};
	};
	exports.SourceNode = SourceNode;
}) });

//#endregion
//#region ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js
var require_source_map = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js": ((exports) => {
	exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
	exports.SourceNode = require_source_node().SourceNode;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/previous-map.js
var require_previous_map = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/previous-map.js": ((exports, module) => {
	let { existsSync: existsSync$1, readFileSync } = __require("fs");
	let { dirname: dirname$3, join: join$1 } = __require("path");
	let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require_source_map();
	function fromBase64(str) {
		if (Buffer) return Buffer.from(str, "base64").toString();
		else
 /* c8 ignore next 2 */
		return window.atob(str);
	}
	var PreviousMap$2 = class {
		constructor(css, opts) {
			if (opts.map === false) return;
			this.loadAnnotation(css);
			this.inline = this.startWith(this.annotation, "data:");
			let prev = opts.map ? opts.map.prev : void 0;
			let text = this.loadMap(opts.from, prev);
			if (!this.mapFile && opts.from) this.mapFile = opts.from;
			if (this.mapFile) this.root = dirname$3(this.mapFile);
			if (text) this.text = text;
		}
		consumer() {
			if (!this.consumerCache) this.consumerCache = new SourceMapConsumer$2(this.text);
			return this.consumerCache;
		}
		decodeInline(text) {
			let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
			let baseUri = /^data:application\/json;base64,/;
			let uriMatch = text.match(/^data:application\/json;charset=utf-?8,/) || text.match(/^data:application\/json,/);
			if (uriMatch) return decodeURIComponent(text.substr(uriMatch[0].length));
			let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);
			if (baseUriMatch) return fromBase64(text.substr(baseUriMatch[0].length));
			let encoding = text.match(/data:application\/json;([^,]+),/)[1];
			throw new Error("Unsupported source map encoding " + encoding);
		}
		getAnnotationURL(sourceMapString) {
			return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
		}
		isMap(map$6) {
			if (typeof map$6 !== "object") return false;
			return typeof map$6.mappings === "string" || typeof map$6._mappings === "string" || Array.isArray(map$6.sections);
		}
		loadAnnotation(css) {
			let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
			if (!comments) return;
			let start = css.lastIndexOf(comments.pop());
			let end = css.indexOf("*/", start);
			if (start > -1 && end > -1) this.annotation = this.getAnnotationURL(css.substring(start, end));
		}
		loadFile(path$2) {
			this.root = dirname$3(path$2);
			if (existsSync$1(path$2)) {
				this.mapFile = path$2;
				return readFileSync(path$2, "utf-8").toString().trim();
			}
		}
		loadMap(file, prev) {
			if (prev === false) return false;
			if (prev) if (typeof prev === "string") return prev;
			else if (typeof prev === "function") {
				let prevPath = prev(file);
				if (prevPath) {
					let map$6 = this.loadFile(prevPath);
					if (!map$6) throw new Error("Unable to load previous source map: " + prevPath.toString());
					return map$6;
				}
			} else if (prev instanceof SourceMapConsumer$2) return SourceMapGenerator$2.fromSourceMap(prev).toString();
			else if (prev instanceof SourceMapGenerator$2) return prev.toString();
			else if (this.isMap(prev)) return JSON.stringify(prev);
			else throw new Error("Unsupported previous source map format: " + prev.toString());
			else if (this.inline) return this.decodeInline(this.annotation);
			else if (this.annotation) {
				let map$6 = this.annotation;
				if (file) map$6 = join$1(dirname$3(file), map$6);
				return this.loadFile(map$6);
			}
		}
		startWith(string$5, start) {
			if (!string$5) return false;
			return string$5.substr(0, start.length) === start;
		}
		withContent() {
			return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
		}
	};
	module.exports = PreviousMap$2;
	PreviousMap$2.default = PreviousMap$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/input.js
var require_input = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/input.js": ((exports, module) => {
	let { nanoid } = require_non_secure();
	let { isAbsolute: isAbsolute$1, resolve: resolve$3 } = __require("path");
	let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require_source_map();
	let { fileURLToPath: fileURLToPath$1, pathToFileURL: pathToFileURL$1 } = __require("url");
	let CssSyntaxError$2 = require_css_syntax_error();
	let PreviousMap$1 = require_previous_map();
	let terminalHighlight = require_terminal_highlight();
	let lineToIndexCache = Symbol("lineToIndexCache");
	let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
	let pathAvailable$1 = Boolean(resolve$3 && isAbsolute$1);
	function getLineToIndex(input) {
		if (input[lineToIndexCache]) return input[lineToIndexCache];
		let lines = input.css.split("\n");
		let lineToIndex = new Array(lines.length);
		let prevIndex = 0;
		for (let i$1 = 0, l$2 = lines.length; i$1 < l$2; i$1++) {
			lineToIndex[i$1] = prevIndex;
			prevIndex += lines[i$1].length + 1;
		}
		input[lineToIndexCache] = lineToIndex;
		return lineToIndex;
	}
	var Input$5 = class {
		get from() {
			return this.file || this.id;
		}
		constructor(css, opts = {}) {
			if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) throw new Error(`PostCSS received ${css} instead of CSS string`);
			this.css = css.toString();
			if (this.css[0] === "" || this.css[0] === "") {
				this.hasBOM = true;
				this.css = this.css.slice(1);
			} else this.hasBOM = false;
			this.document = this.css;
			if (opts.document) this.document = opts.document.toString();
			if (opts.from) if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute$1(opts.from)) this.file = opts.from;
			else this.file = resolve$3(opts.from);
			if (pathAvailable$1 && sourceMapAvailable$1) {
				let map$6 = new PreviousMap$1(this.css, opts);
				if (map$6.text) {
					this.map = map$6;
					let file = map$6.consumer().file;
					if (!this.file && file) this.file = this.mapResolve(file);
				}
			}
			if (!this.file) this.id = "<input css " + nanoid(6) + ">";
			if (this.map) this.map.file = this.from;
		}
		error(message, line, column, opts = {}) {
			let endColumn, endLine, endOffset, offset, result;
			if (line && typeof line === "object") {
				let start = line;
				let end = column;
				if (typeof start.offset === "number") {
					offset = start.offset;
					let pos = this.fromOffset(offset);
					line = pos.line;
					column = pos.col;
				} else {
					line = start.line;
					column = start.column;
					offset = this.fromLineAndColumn(line, column);
				}
				if (typeof end.offset === "number") {
					endOffset = end.offset;
					let pos = this.fromOffset(endOffset);
					endLine = pos.line;
					endColumn = pos.col;
				} else {
					endLine = end.line;
					endColumn = end.column;
					endOffset = this.fromLineAndColumn(end.line, end.column);
				}
			} else if (!column) {
				offset = line;
				let pos = this.fromOffset(offset);
				line = pos.line;
				column = pos.col;
			} else offset = this.fromLineAndColumn(line, column);
			let origin = this.origin(line, column, endLine, endColumn);
			if (origin) result = new CssSyntaxError$2(message, origin.endLine === void 0 ? origin.line : {
				column: origin.column,
				line: origin.line
			}, origin.endLine === void 0 ? origin.column : {
				column: origin.endColumn,
				line: origin.endLine
			}, origin.source, origin.file, opts.plugin);
			else result = new CssSyntaxError$2(message, endLine === void 0 ? line : {
				column,
				line
			}, endLine === void 0 ? column : {
				column: endColumn,
				line: endLine
			}, this.css, this.file, opts.plugin);
			result.input = {
				column,
				endColumn,
				endLine,
				endOffset,
				line,
				offset,
				source: this.css
			};
			if (this.file) {
				if (pathToFileURL$1) result.input.url = pathToFileURL$1(this.file).toString();
				result.input.file = this.file;
			}
			return result;
		}
		fromLineAndColumn(line, column) {
			return getLineToIndex(this)[line - 1] + column - 1;
		}
		fromOffset(offset) {
			let lineToIndex = getLineToIndex(this);
			let lastLine = lineToIndex[lineToIndex.length - 1];
			let min = 0;
			if (offset >= lastLine) min = lineToIndex.length - 1;
			else {
				let max = lineToIndex.length - 2;
				let mid;
				while (min < max) {
					mid = min + (max - min >> 1);
					if (offset < lineToIndex[mid]) max = mid - 1;
					else if (offset >= lineToIndex[mid + 1]) min = mid + 1;
					else {
						min = mid;
						break;
					}
				}
			}
			return {
				col: offset - lineToIndex[min] + 1,
				line: min + 1
			};
		}
		mapResolve(file) {
			if (/^\w+:\/\//.test(file)) return file;
			return resolve$3(this.map.consumer().sourceRoot || this.map.root || ".", file);
		}
		origin(line, column, endLine, endColumn) {
			if (!this.map) return false;
			let consumer = this.map.consumer();
			let from$1 = consumer.originalPositionFor({
				column,
				line
			});
			if (!from$1.source) return false;
			let to;
			if (typeof endLine === "number") to = consumer.originalPositionFor({
				column: endColumn,
				line: endLine
			});
			let fromUrl;
			if (isAbsolute$1(from$1.source)) fromUrl = pathToFileURL$1(from$1.source);
			else fromUrl = new URL(from$1.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));
			let result = {
				column: from$1.column,
				endColumn: to && to.column,
				endLine: to && to.line,
				line: from$1.line,
				url: fromUrl.toString()
			};
			if (fromUrl.protocol === "file:") if (fileURLToPath$1) result.file = fileURLToPath$1(fromUrl);
			else
 /* c8 ignore next 2 */
			throw new Error(`file: protocol is not available in this PostCSS build`);
			let source = consumer.sourceContentFor(from$1.source);
			if (source) result.source = source;
			return result;
		}
		toJSON() {
			let json = {};
			for (let name of [
				"hasBOM",
				"css",
				"file",
				"id"
			]) if (this[name] != null) json[name] = this[name];
			if (this.map) {
				json.map = { ...this.map };
				if (json.map.consumerCache) json.map.consumerCache = void 0;
			}
			return json;
		}
	};
	module.exports = Input$5;
	Input$5.default = Input$5;
	if (terminalHighlight && terminalHighlight.registerInput) terminalHighlight.registerInput(Input$5);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/root.js
var require_root = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/root.js": ((exports, module) => {
	let Container$5 = require_container();
	let LazyResult$3, Processor$3;
	var Root$6 = class extends Container$5 {
		constructor(defaults) {
			super(defaults);
			this.type = "root";
			if (!this.nodes) this.nodes = [];
		}
		normalize(child, sample, type) {
			let nodes = super.normalize(child);
			if (sample) {
				if (type === "prepend") if (this.nodes.length > 1) sample.raws.before = this.nodes[1].raws.before;
				else delete sample.raws.before;
				else if (this.first !== sample) for (let node of nodes) node.raws.before = sample.raws.before;
			}
			return nodes;
		}
		removeChild(child, ignore) {
			let index = this.index(child);
			if (!ignore && index === 0 && this.nodes.length > 1) this.nodes[1].raws.before = this.nodes[index].raws.before;
			return super.removeChild(child);
		}
		toResult(opts = {}) {
			return new LazyResult$3(new Processor$3(), this, opts).stringify();
		}
	};
	Root$6.registerLazyResult = (dependant) => {
		LazyResult$3 = dependant;
	};
	Root$6.registerProcessor = (dependant) => {
		Processor$3 = dependant;
	};
	module.exports = Root$6;
	Root$6.default = Root$6;
	Container$5.registerRoot(Root$6);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/list.js
var require_list = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/list.js": ((exports, module) => {
	let list$4 = {
		comma(string$5) {
			return list$4.split(string$5, [","], true);
		},
		space(string$5) {
			return list$4.split(string$5, [
				" ",
				"\n",
				"	"
			]);
		},
		split(string$5, separators, last) {
			let array = [];
			let current = "";
			let split = false;
			let func = 0;
			let inQuote = false;
			let prevQuote = "";
			let escape = false;
			for (let letter of string$5) {
				if (escape) escape = false;
				else if (letter === "\\") escape = true;
				else if (inQuote) {
					if (letter === prevQuote) inQuote = false;
				} else if (letter === "\"" || letter === "'") {
					inQuote = true;
					prevQuote = letter;
				} else if (letter === "(") func += 1;
				else if (letter === ")") {
					if (func > 0) func -= 1;
				} else if (func === 0) {
					if (separators.includes(letter)) split = true;
				}
				if (split) {
					if (current !== "") array.push(current.trim());
					current = "";
					split = false;
				} else current += letter;
			}
			if (last || current !== "") array.push(current.trim());
			return array;
		}
	};
	module.exports = list$4;
	list$4.default = list$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/rule.js
var require_rule = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/rule.js": ((exports, module) => {
	let Container$4 = require_container();
	let list$3 = require_list();
	var Rule$4 = class extends Container$4 {
		get selectors() {
			return list$3.comma(this.selector);
		}
		set selectors(values) {
			let match = this.selector ? this.selector.match(/,\s*/) : null;
			let sep$1 = match ? match[0] : "," + this.raw("between", "beforeOpen");
			this.selector = values.join(sep$1);
		}
		constructor(defaults) {
			super(defaults);
			this.type = "rule";
			if (!this.nodes) this.nodes = [];
		}
	};
	module.exports = Rule$4;
	Rule$4.default = Rule$4;
	Container$4.registerRule(Rule$4);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/fromJSON.js
var require_fromJSON = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/fromJSON.js": ((exports, module) => {
	let AtRule$3 = require_at_rule();
	let Comment$3 = require_comment();
	let Declaration$3 = require_declaration();
	let Input$4 = require_input();
	let PreviousMap = require_previous_map();
	let Root$5 = require_root();
	let Rule$3 = require_rule();
	function fromJSON$2(json, inputs) {
		if (Array.isArray(json)) return json.map((n$1) => fromJSON$2(n$1));
		let { inputs: ownInputs,...defaults } = json;
		if (ownInputs) {
			inputs = [];
			for (let input of ownInputs) {
				let inputHydrated = {
					...input,
					__proto__: Input$4.prototype
				};
				if (inputHydrated.map) inputHydrated.map = {
					...inputHydrated.map,
					__proto__: PreviousMap.prototype
				};
				inputs.push(inputHydrated);
			}
		}
		if (defaults.nodes) defaults.nodes = json.nodes.map((n$1) => fromJSON$2(n$1, inputs));
		if (defaults.source) {
			let { inputId,...source } = defaults.source;
			defaults.source = source;
			if (inputId != null) defaults.source.input = inputs[inputId];
		}
		if (defaults.type === "root") return new Root$5(defaults);
		else if (defaults.type === "decl") return new Declaration$3(defaults);
		else if (defaults.type === "rule") return new Rule$3(defaults);
		else if (defaults.type === "comment") return new Comment$3(defaults);
		else if (defaults.type === "atrule") return new AtRule$3(defaults);
		else throw new Error("Unknown node type: " + json.type);
	}
	module.exports = fromJSON$2;
	fromJSON$2.default = fromJSON$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/map-generator.js
var require_map_generator = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/map-generator.js": ((exports, module) => {
	let { dirname: dirname$2, relative, resolve: resolve$2, sep } = __require("path");
	let { SourceMapConsumer, SourceMapGenerator } = require_source_map();
	let { pathToFileURL } = __require("url");
	let Input$3 = require_input();
	let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	let pathAvailable = Boolean(dirname$2 && resolve$2 && relative && sep);
	var MapGenerator$2 = class {
		constructor(stringify$13, root$1, opts, cssString) {
			this.stringify = stringify$13;
			this.mapOpts = opts.map || {};
			this.root = root$1;
			this.opts = opts;
			this.css = cssString;
			this.originalCSS = cssString;
			this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
			this.memoizedFileURLs = /* @__PURE__ */ new Map();
			this.memoizedPaths = /* @__PURE__ */ new Map();
			this.memoizedURLs = /* @__PURE__ */ new Map();
		}
		addAnnotation() {
			let content;
			if (this.isInline()) content = "data:application/json;base64," + this.toBase64(this.map.toString());
			else if (typeof this.mapOpts.annotation === "string") content = this.mapOpts.annotation;
			else if (typeof this.mapOpts.annotation === "function") content = this.mapOpts.annotation(this.opts.to, this.root);
			else content = this.outputFile() + ".map";
			let eol = "\n";
			if (this.css.includes("\r\n")) eol = "\r\n";
			this.css += eol + "/*# sourceMappingURL=" + content + " */";
		}
		applyPrevMaps() {
			for (let prev of this.previous()) {
				let from$1 = this.toUrl(this.path(prev.file));
				let root$1 = prev.root || dirname$2(prev.file);
				let map$6;
				if (this.mapOpts.sourcesContent === false) {
					map$6 = new SourceMapConsumer(prev.text);
					if (map$6.sourcesContent) map$6.sourcesContent = null;
				} else map$6 = prev.consumer();
				this.map.applySourceMap(map$6, from$1, this.toUrl(this.path(root$1)));
			}
		}
		clearAnnotation() {
			if (this.mapOpts.annotation === false) return;
			if (this.root) {
				let node;
				for (let i$1 = this.root.nodes.length - 1; i$1 >= 0; i$1--) {
					node = this.root.nodes[i$1];
					if (node.type !== "comment") continue;
					if (node.text.startsWith("# sourceMappingURL=")) this.root.removeChild(i$1);
				}
			} else if (this.css) this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
		}
		generate() {
			this.clearAnnotation();
			if (pathAvailable && sourceMapAvailable && this.isMap()) return this.generateMap();
			else {
				let result = "";
				this.stringify(this.root, (i$1) => {
					result += i$1;
				});
				return [result];
			}
		}
		generateMap() {
			if (this.root) this.generateString();
			else if (this.previous().length === 1) {
				let prev = this.previous()[0].consumer();
				prev.file = this.outputFile();
				this.map = SourceMapGenerator.fromSourceMap(prev, { ignoreInvalidMapping: true });
			} else {
				this.map = new SourceMapGenerator({
					file: this.outputFile(),
					ignoreInvalidMapping: true
				});
				this.map.addMapping({
					generated: {
						column: 0,
						line: 1
					},
					original: {
						column: 0,
						line: 1
					},
					source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
				});
			}
			if (this.isSourcesContent()) this.setSourcesContent();
			if (this.root && this.previous().length > 0) this.applyPrevMaps();
			if (this.isAnnotation()) this.addAnnotation();
			if (this.isInline()) return [this.css];
			else return [this.css, this.map];
		}
		generateString() {
			this.css = "";
			this.map = new SourceMapGenerator({
				file: this.outputFile(),
				ignoreInvalidMapping: true
			});
			let line = 1;
			let column = 1;
			let noSource = "<no source>";
			let mapping = {
				generated: {
					column: 0,
					line: 0
				},
				original: {
					column: 0,
					line: 0
				},
				source: ""
			};
			let last, lines;
			this.stringify(this.root, (str, node, type) => {
				this.css += str;
				if (node && type !== "end") {
					mapping.generated.line = line;
					mapping.generated.column = column - 1;
					if (node.source && node.source.start) {
						mapping.source = this.sourcePath(node);
						mapping.original.line = node.source.start.line;
						mapping.original.column = node.source.start.column - 1;
						this.map.addMapping(mapping);
					} else {
						mapping.source = noSource;
						mapping.original.line = 1;
						mapping.original.column = 0;
						this.map.addMapping(mapping);
					}
				}
				lines = str.match(/\n/g);
				if (lines) {
					line += lines.length;
					last = str.lastIndexOf("\n");
					column = str.length - last;
				} else column += str.length;
				if (node && type !== "start") {
					let p$2 = node.parent || { raws: {} };
					if (!(node.type === "decl" || node.type === "atrule" && !node.nodes) || node !== p$2.last || p$2.raws.semicolon) if (node.source && node.source.end) {
						mapping.source = this.sourcePath(node);
						mapping.original.line = node.source.end.line;
						mapping.original.column = node.source.end.column - 1;
						mapping.generated.line = line;
						mapping.generated.column = column - 2;
						this.map.addMapping(mapping);
					} else {
						mapping.source = noSource;
						mapping.original.line = 1;
						mapping.original.column = 0;
						mapping.generated.line = line;
						mapping.generated.column = column - 1;
						this.map.addMapping(mapping);
					}
				}
			});
		}
		isAnnotation() {
			if (this.isInline()) return true;
			if (typeof this.mapOpts.annotation !== "undefined") return this.mapOpts.annotation;
			if (this.previous().length) return this.previous().some((i$1) => i$1.annotation);
			return true;
		}
		isInline() {
			if (typeof this.mapOpts.inline !== "undefined") return this.mapOpts.inline;
			let annotation = this.mapOpts.annotation;
			if (typeof annotation !== "undefined" && annotation !== true) return false;
			if (this.previous().length) return this.previous().some((i$1) => i$1.inline);
			return true;
		}
		isMap() {
			if (typeof this.opts.map !== "undefined") return !!this.opts.map;
			return this.previous().length > 0;
		}
		isSourcesContent() {
			if (typeof this.mapOpts.sourcesContent !== "undefined") return this.mapOpts.sourcesContent;
			if (this.previous().length) return this.previous().some((i$1) => i$1.withContent());
			return true;
		}
		outputFile() {
			if (this.opts.to) return this.path(this.opts.to);
			else if (this.opts.from) return this.path(this.opts.from);
			else return "to.css";
		}
		path(file) {
			if (this.mapOpts.absolute) return file;
			if (file.charCodeAt(0) === 60) return file;
			if (/^\w+:\/\//.test(file)) return file;
			let cached = this.memoizedPaths.get(file);
			if (cached) return cached;
			let from$1 = this.opts.to ? dirname$2(this.opts.to) : ".";
			if (typeof this.mapOpts.annotation === "string") from$1 = dirname$2(resolve$2(from$1, this.mapOpts.annotation));
			let path$2 = relative(from$1, file);
			this.memoizedPaths.set(file, path$2);
			return path$2;
		}
		previous() {
			if (!this.previousMaps) {
				this.previousMaps = [];
				if (this.root) this.root.walk((node) => {
					if (node.source && node.source.input.map) {
						let map$6 = node.source.input.map;
						if (!this.previousMaps.includes(map$6)) this.previousMaps.push(map$6);
					}
				});
				else {
					let input = new Input$3(this.originalCSS, this.opts);
					if (input.map) this.previousMaps.push(input.map);
				}
			}
			return this.previousMaps;
		}
		setSourcesContent() {
			let already = {};
			if (this.root) this.root.walk((node) => {
				if (node.source) {
					let from$1 = node.source.input.from;
					if (from$1 && !already[from$1]) {
						already[from$1] = true;
						let fromUrl = this.usesFileUrls ? this.toFileUrl(from$1) : this.toUrl(this.path(from$1));
						this.map.setSourceContent(fromUrl, node.source.input.css);
					}
				}
			});
			else if (this.css) {
				let from$1 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
				this.map.setSourceContent(from$1, this.css);
			}
		}
		sourcePath(node) {
			if (this.mapOpts.from) return this.toUrl(this.mapOpts.from);
			else if (this.usesFileUrls) return this.toFileUrl(node.source.input.from);
			else return this.toUrl(this.path(node.source.input.from));
		}
		toBase64(str) {
			if (Buffer) return Buffer.from(str).toString("base64");
			else return window.btoa(unescape(encodeURIComponent(str)));
		}
		toFileUrl(path$2) {
			let cached = this.memoizedFileURLs.get(path$2);
			if (cached) return cached;
			if (pathToFileURL) {
				let fileURL = pathToFileURL(path$2).toString();
				this.memoizedFileURLs.set(path$2, fileURL);
				return fileURL;
			} else throw new Error("`map.absolute` option is not available in this PostCSS build");
		}
		toUrl(path$2) {
			let cached = this.memoizedURLs.get(path$2);
			if (cached) return cached;
			if (sep === "\\") path$2 = path$2.replace(/\\/g, "/");
			let url = encodeURI(path$2).replace(/[#?]/g, encodeURIComponent);
			this.memoizedURLs.set(path$2, url);
			return url;
		}
	};
	module.exports = MapGenerator$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/parser.js
var require_parser$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/parser.js": ((exports, module) => {
	let AtRule$2 = require_at_rule();
	let Comment$2 = require_comment();
	let Declaration$2 = require_declaration();
	let Root$4 = require_root();
	let Rule$2 = require_rule();
	let tokenizer$1 = require_tokenize();
	const SAFE_COMMENT_NEIGHBOR = {
		empty: true,
		space: true
	};
	function findLastWithPosition(tokens) {
		for (let i$1 = tokens.length - 1; i$1 >= 0; i$1--) {
			let token = tokens[i$1];
			let pos = token[3] || token[2];
			if (pos) return pos;
		}
	}
	var Parser$3 = class {
		constructor(input) {
			this.input = input;
			this.root = new Root$4();
			this.current = this.root;
			this.spaces = "";
			this.semicolon = false;
			this.createTokenizer();
			this.root.source = {
				input,
				start: {
					column: 1,
					line: 1,
					offset: 0
				}
			};
		}
		atrule(token) {
			let node = new AtRule$2();
			node.name = token[1].slice(1);
			if (node.name === "") this.unnamedAtrule(node, token);
			this.init(node, token[2]);
			let type;
			let prev;
			let shift;
			let last = false;
			let open = false;
			let params = [];
			let brackets = [];
			while (!this.tokenizer.endOfFile()) {
				token = this.tokenizer.nextToken();
				type = token[0];
				if (type === "(" || type === "[") brackets.push(type === "(" ? ")" : "]");
				else if (type === "{" && brackets.length > 0) brackets.push("}");
				else if (type === brackets[brackets.length - 1]) brackets.pop();
				if (brackets.length === 0) if (type === ";") {
					node.source.end = this.getPosition(token[2]);
					node.source.end.offset++;
					this.semicolon = true;
					break;
				} else if (type === "{") {
					open = true;
					break;
				} else if (type === "}") {
					if (params.length > 0) {
						shift = params.length - 1;
						prev = params[shift];
						while (prev && prev[0] === "space") prev = params[--shift];
						if (prev) {
							node.source.end = this.getPosition(prev[3] || prev[2]);
							node.source.end.offset++;
						}
					}
					this.end(token);
					break;
				} else params.push(token);
				else params.push(token);
				if (this.tokenizer.endOfFile()) {
					last = true;
					break;
				}
			}
			node.raws.between = this.spacesAndCommentsFromEnd(params);
			if (params.length) {
				node.raws.afterName = this.spacesAndCommentsFromStart(params);
				this.raw(node, "params", params);
				if (last) {
					token = params[params.length - 1];
					node.source.end = this.getPosition(token[3] || token[2]);
					node.source.end.offset++;
					this.spaces = node.raws.between;
					node.raws.between = "";
				}
			} else {
				node.raws.afterName = "";
				node.params = "";
			}
			if (open) {
				node.nodes = [];
				this.current = node;
			}
		}
		checkMissedSemicolon(tokens) {
			let colon = this.colon(tokens);
			if (colon === false) return;
			let founded = 0;
			let token;
			for (let j$2 = colon - 1; j$2 >= 0; j$2--) {
				token = tokens[j$2];
				if (token[0] !== "space") {
					founded += 1;
					if (founded === 2) break;
				}
			}
			throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
		}
		colon(tokens) {
			let brackets = 0;
			let prev, token, type;
			for (let [i$1, element] of tokens.entries()) {
				token = element;
				type = token[0];
				if (type === "(") brackets += 1;
				if (type === ")") brackets -= 1;
				if (brackets === 0 && type === ":") if (!prev) this.doubleColon(token);
				else if (prev[0] === "word" && prev[1] === "progid") continue;
				else return i$1;
				prev = token;
			}
			return false;
		}
		comment(token) {
			let node = new Comment$2();
			this.init(node, token[2]);
			node.source.end = this.getPosition(token[3] || token[2]);
			node.source.end.offset++;
			let text = token[1].slice(2, -2);
			if (/^\s*$/.test(text)) {
				node.text = "";
				node.raws.left = text;
				node.raws.right = "";
			} else {
				let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
				node.text = match[2];
				node.raws.left = match[1];
				node.raws.right = match[3];
			}
		}
		createTokenizer() {
			this.tokenizer = tokenizer$1(this.input);
		}
		decl(tokens, customProperty) {
			let node = new Declaration$2();
			this.init(node, tokens[0][2]);
			let last = tokens[tokens.length - 1];
			if (last[0] === ";") {
				this.semicolon = true;
				tokens.pop();
			}
			node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
			node.source.end.offset++;
			while (tokens[0][0] !== "word") {
				if (tokens.length === 1) this.unknownWord(tokens);
				node.raws.before += tokens.shift()[1];
			}
			node.source.start = this.getPosition(tokens[0][2]);
			node.prop = "";
			while (tokens.length) {
				let type = tokens[0][0];
				if (type === ":" || type === "space" || type === "comment") break;
				node.prop += tokens.shift()[1];
			}
			node.raws.between = "";
			let token;
			while (tokens.length) {
				token = tokens.shift();
				if (token[0] === ":") {
					node.raws.between += token[1];
					break;
				} else {
					if (token[0] === "word" && /\w/.test(token[1])) this.unknownWord([token]);
					node.raws.between += token[1];
				}
			}
			if (node.prop[0] === "_" || node.prop[0] === "*") {
				node.raws.before += node.prop[0];
				node.prop = node.prop.slice(1);
			}
			let firstSpaces = [];
			let next;
			while (tokens.length) {
				next = tokens[0][0];
				if (next !== "space" && next !== "comment") break;
				firstSpaces.push(tokens.shift());
			}
			this.precheckMissedSemicolon(tokens);
			for (let i$1 = tokens.length - 1; i$1 >= 0; i$1--) {
				token = tokens[i$1];
				if (token[1].toLowerCase() === "!important") {
					node.important = true;
					let string$5 = this.stringFrom(tokens, i$1);
					string$5 = this.spacesFromEnd(tokens) + string$5;
					if (string$5 !== " !important") node.raws.important = string$5;
					break;
				} else if (token[1].toLowerCase() === "important") {
					let cache = tokens.slice(0);
					let str = "";
					for (let j$2 = i$1; j$2 > 0; j$2--) {
						let type = cache[j$2][0];
						if (str.trim().startsWith("!") && type !== "space") break;
						str = cache.pop()[1] + str;
					}
					if (str.trim().startsWith("!")) {
						node.important = true;
						node.raws.important = str;
						tokens = cache;
					}
				}
				if (token[0] !== "space" && token[0] !== "comment") break;
			}
			if (tokens.some((i$1) => i$1[0] !== "space" && i$1[0] !== "comment")) {
				node.raws.between += firstSpaces.map((i$1) => i$1[1]).join("");
				firstSpaces = [];
			}
			this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
			if (node.value.includes(":") && !customProperty) this.checkMissedSemicolon(tokens);
		}
		doubleColon(token) {
			throw this.input.error("Double colon", { offset: token[2] }, { offset: token[2] + token[1].length });
		}
		emptyRule(token) {
			let node = new Rule$2();
			this.init(node, token[2]);
			node.selector = "";
			node.raws.between = "";
			this.current = node;
		}
		end(token) {
			if (this.current.nodes && this.current.nodes.length) this.current.raws.semicolon = this.semicolon;
			this.semicolon = false;
			this.current.raws.after = (this.current.raws.after || "") + this.spaces;
			this.spaces = "";
			if (this.current.parent) {
				this.current.source.end = this.getPosition(token[2]);
				this.current.source.end.offset++;
				this.current = this.current.parent;
			} else this.unexpectedClose(token);
		}
		endFile() {
			if (this.current.parent) this.unclosedBlock();
			if (this.current.nodes && this.current.nodes.length) this.current.raws.semicolon = this.semicolon;
			this.current.raws.after = (this.current.raws.after || "") + this.spaces;
			this.root.source.end = this.getPosition(this.tokenizer.position());
		}
		freeSemicolon(token) {
			this.spaces += token[1];
			if (this.current.nodes) {
				let prev = this.current.nodes[this.current.nodes.length - 1];
				if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
					prev.raws.ownSemicolon = this.spaces;
					this.spaces = "";
					prev.source.end = this.getPosition(token[2]);
					prev.source.end.offset += prev.raws.ownSemicolon.length;
				}
			}
		}
		getPosition(offset) {
			let pos = this.input.fromOffset(offset);
			return {
				column: pos.col,
				line: pos.line,
				offset
			};
		}
		init(node, offset) {
			this.current.push(node);
			node.source = {
				input: this.input,
				start: this.getPosition(offset)
			};
			node.raws.before = this.spaces;
			this.spaces = "";
			if (node.type !== "comment") this.semicolon = false;
		}
		other(start) {
			let end = false;
			let type = null;
			let colon = false;
			let bracket = null;
			let brackets = [];
			let customProperty = start[1].startsWith("--");
			let tokens = [];
			let token = start;
			while (token) {
				type = token[0];
				tokens.push(token);
				if (type === "(" || type === "[") {
					if (!bracket) bracket = token;
					brackets.push(type === "(" ? ")" : "]");
				} else if (customProperty && colon && type === "{") {
					if (!bracket) bracket = token;
					brackets.push("}");
				} else if (brackets.length === 0) {
					if (type === ";") if (colon) {
						this.decl(tokens, customProperty);
						return;
					} else break;
					else if (type === "{") {
						this.rule(tokens);
						return;
					} else if (type === "}") {
						this.tokenizer.back(tokens.pop());
						end = true;
						break;
					} else if (type === ":") colon = true;
				} else if (type === brackets[brackets.length - 1]) {
					brackets.pop();
					if (brackets.length === 0) bracket = null;
				}
				token = this.tokenizer.nextToken();
			}
			if (this.tokenizer.endOfFile()) end = true;
			if (brackets.length > 0) this.unclosedBracket(bracket);
			if (end && colon) {
				if (!customProperty) while (tokens.length) {
					token = tokens[tokens.length - 1][0];
					if (token !== "space" && token !== "comment") break;
					this.tokenizer.back(tokens.pop());
				}
				this.decl(tokens, customProperty);
			} else this.unknownWord(tokens);
		}
		parse() {
			let token;
			while (!this.tokenizer.endOfFile()) {
				token = this.tokenizer.nextToken();
				switch (token[0]) {
					case "space":
						this.spaces += token[1];
						break;
					case ";":
						this.freeSemicolon(token);
						break;
					case "}":
						this.end(token);
						break;
					case "comment":
						this.comment(token);
						break;
					case "at-word":
						this.atrule(token);
						break;
					case "{":
						this.emptyRule(token);
						break;
					default:
						this.other(token);
						break;
				}
			}
			this.endFile();
		}
		precheckMissedSemicolon() {}
		raw(node, prop, tokens, customProperty) {
			let token, type;
			let length = tokens.length;
			let value = "";
			let clean = true;
			let next, prev;
			for (let i$1 = 0; i$1 < length; i$1 += 1) {
				token = tokens[i$1];
				type = token[0];
				if (type === "space" && i$1 === length - 1 && !customProperty) clean = false;
				else if (type === "comment") {
					prev = tokens[i$1 - 1] ? tokens[i$1 - 1][0] : "empty";
					next = tokens[i$1 + 1] ? tokens[i$1 + 1][0] : "empty";
					if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) if (value.slice(-1) === ",") clean = false;
					else value += token[1];
					else clean = false;
				} else value += token[1];
			}
			if (!clean) {
				let raw = tokens.reduce((all, i$1) => all + i$1[1], "");
				node.raws[prop] = {
					raw,
					value
				};
			}
			node[prop] = value;
		}
		rule(tokens) {
			tokens.pop();
			let node = new Rule$2();
			this.init(node, tokens[0][2]);
			node.raws.between = this.spacesAndCommentsFromEnd(tokens);
			this.raw(node, "selector", tokens);
			this.current = node;
		}
		spacesAndCommentsFromEnd(tokens) {
			let lastTokenType;
			let spaces = "";
			while (tokens.length) {
				lastTokenType = tokens[tokens.length - 1][0];
				if (lastTokenType !== "space" && lastTokenType !== "comment") break;
				spaces = tokens.pop()[1] + spaces;
			}
			return spaces;
		}
		spacesAndCommentsFromStart(tokens) {
			let next;
			let spaces = "";
			while (tokens.length) {
				next = tokens[0][0];
				if (next !== "space" && next !== "comment") break;
				spaces += tokens.shift()[1];
			}
			return spaces;
		}
		spacesFromEnd(tokens) {
			let lastTokenType;
			let spaces = "";
			while (tokens.length) {
				lastTokenType = tokens[tokens.length - 1][0];
				if (lastTokenType !== "space") break;
				spaces = tokens.pop()[1] + spaces;
			}
			return spaces;
		}
		stringFrom(tokens, from$1) {
			let result = "";
			for (let i$1 = from$1; i$1 < tokens.length; i$1++) result += tokens[i$1][1];
			tokens.splice(from$1, tokens.length - from$1);
			return result;
		}
		unclosedBlock() {
			let pos = this.current.source.start;
			throw this.input.error("Unclosed block", pos.line, pos.column);
		}
		unclosedBracket(bracket) {
			throw this.input.error("Unclosed bracket", { offset: bracket[2] }, { offset: bracket[2] + 1 });
		}
		unexpectedClose(token) {
			throw this.input.error("Unexpected }", { offset: token[2] }, { offset: token[2] + 1 });
		}
		unknownWord(tokens) {
			throw this.input.error("Unknown word " + tokens[0][1], { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });
		}
		unnamedAtrule(node, token) {
			throw this.input.error("At-rule without name", { offset: token[2] }, { offset: token[2] + token[1].length });
		}
	};
	module.exports = Parser$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/parse.js": ((exports, module) => {
	let Container$3 = require_container();
	let Input$2 = require_input();
	let Parser$2 = require_parser$1();
	function parse$6(css, opts) {
		let input = new Input$2(css, opts);
		let parser$2 = new Parser$2(input);
		try {
			parser$2.parse();
		} catch (e$1) {
			if (process.env.NODE_ENV !== "production") {
				if (e$1.name === "CssSyntaxError" && opts && opts.from) {
					if (/\.scss$/i.test(opts.from)) e$1.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
					else if (/\.sass/i.test(opts.from)) e$1.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
					else if (/\.less$/i.test(opts.from)) e$1.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
				}
			}
			throw e$1;
		}
		return parser$2.root;
	}
	module.exports = parse$6;
	parse$6.default = parse$6;
	Container$3.registerParse(parse$6);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/warning.js
var require_warning = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/warning.js": ((exports, module) => {
	var Warning$3 = class {
		constructor(text, opts = {}) {
			this.type = "warning";
			this.text = text;
			if (opts.node && opts.node.source) {
				let range = opts.node.rangeBy(opts);
				this.line = range.start.line;
				this.column = range.start.column;
				this.endLine = range.end.line;
				this.endColumn = range.end.column;
			}
			for (let opt in opts) this[opt] = opts[opt];
		}
		toString() {
			if (this.node) return this.node.error(this.text, {
				index: this.index,
				plugin: this.plugin,
				word: this.word
			}).message;
			if (this.plugin) return this.plugin + ": " + this.text;
			return this.text;
		}
	};
	module.exports = Warning$3;
	Warning$3.default = Warning$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/result.js
var require_result = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/result.js": ((exports, module) => {
	let Warning$2 = require_warning();
	var Result$4 = class {
		get content() {
			return this.css;
		}
		constructor(processor, root$1, opts) {
			this.processor = processor;
			this.messages = [];
			this.root = root$1;
			this.opts = opts;
			this.css = "";
			this.map = void 0;
		}
		toString() {
			return this.css;
		}
		warn(text, opts = {}) {
			if (!opts.plugin) {
				if (this.lastPlugin && this.lastPlugin.postcssPlugin) opts.plugin = this.lastPlugin.postcssPlugin;
			}
			let warning = new Warning$2(text, opts);
			this.messages.push(warning);
			return warning;
		}
		warnings() {
			return this.messages.filter((i$1) => i$1.type === "warning");
		}
	};
	module.exports = Result$4;
	Result$4.default = Result$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/warn-once.js
var require_warn_once = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/warn-once.js": ((exports, module) => {
	let printed = {};
	module.exports = function warnOnce$2(message) {
		if (printed[message]) return;
		printed[message] = true;
		if (typeof console !== "undefined" && console.warn) console.warn(message);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/lazy-result.js
var require_lazy_result = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/lazy-result.js": ((exports, module) => {
	let Container$2 = require_container();
	let Document$9 = require_document();
	let MapGenerator$1 = require_map_generator();
	let parse$5 = require_parse();
	let Result$3 = require_result();
	let Root$3 = require_root();
	let stringify$10 = require_stringify$1();
	let { isClean, my } = require_symbols();
	let warnOnce$1 = require_warn_once();
	const TYPE_TO_CLASS_NAME = {
		atrule: "AtRule",
		comment: "Comment",
		decl: "Declaration",
		document: "Document",
		root: "Root",
		rule: "Rule"
	};
	const PLUGIN_PROPS = {
		AtRule: true,
		AtRuleExit: true,
		Comment: true,
		CommentExit: true,
		Declaration: true,
		DeclarationExit: true,
		Document: true,
		DocumentExit: true,
		Once: true,
		OnceExit: true,
		postcssPlugin: true,
		prepare: true,
		Root: true,
		RootExit: true,
		Rule: true,
		RuleExit: true
	};
	const NOT_VISITORS = {
		Once: true,
		postcssPlugin: true,
		prepare: true
	};
	const CHILDREN = 0;
	function isPromise(obj) {
		return typeof obj === "object" && typeof obj.then === "function";
	}
	function getEvents(node) {
		let key = false;
		let type = TYPE_TO_CLASS_NAME[node.type];
		if (node.type === "decl") key = node.prop.toLowerCase();
		else if (node.type === "atrule") key = node.name.toLowerCase();
		if (key && node.append) return [
			type,
			type + "-" + key,
			CHILDREN,
			type + "Exit",
			type + "Exit-" + key
		];
		else if (key) return [
			type,
			type + "-" + key,
			type + "Exit",
			type + "Exit-" + key
		];
		else if (node.append) return [
			type,
			CHILDREN,
			type + "Exit"
		];
		else return [type, type + "Exit"];
	}
	function toStack(node) {
		let events;
		if (node.type === "document") events = [
			"Document",
			CHILDREN,
			"DocumentExit"
		];
		else if (node.type === "root") events = [
			"Root",
			CHILDREN,
			"RootExit"
		];
		else events = getEvents(node);
		return {
			eventIndex: 0,
			events,
			iterator: 0,
			node,
			visitorIndex: 0,
			visitors: []
		};
	}
	function cleanMarks(node) {
		node[isClean] = false;
		if (node.nodes) node.nodes.forEach((i$1) => cleanMarks(i$1));
		return node;
	}
	let postcss$2 = {};
	var LazyResult$2 = class LazyResult$2 {
		get content() {
			return this.stringify().content;
		}
		get css() {
			return this.stringify().css;
		}
		get map() {
			return this.stringify().map;
		}
		get messages() {
			return this.sync().messages;
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			return this.sync().root;
		}
		get [Symbol.toStringTag]() {
			return "LazyResult";
		}
		constructor(processor, css, opts) {
			this.stringified = false;
			this.processed = false;
			let root$1;
			if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) root$1 = cleanMarks(css);
			else if (css instanceof LazyResult$2 || css instanceof Result$3) {
				root$1 = cleanMarks(css.root);
				if (css.map) {
					if (typeof opts.map === "undefined") opts.map = {};
					if (!opts.map.inline) opts.map.inline = false;
					opts.map.prev = css.map;
				}
			} else {
				let parser$2 = parse$5;
				if (opts.syntax) parser$2 = opts.syntax.parse;
				if (opts.parser) parser$2 = opts.parser;
				if (parser$2.parse) parser$2 = parser$2.parse;
				try {
					root$1 = parser$2(css, opts);
				} catch (error) {
					this.processed = true;
					this.error = error;
				}
				if (root$1 && !root$1[my])
 /* c8 ignore next 2 */
				Container$2.rebuild(root$1);
			}
			this.result = new Result$3(processor, root$1, opts);
			this.helpers = {
				...postcss$2,
				postcss: postcss$2,
				result: this.result
			};
			this.plugins = this.processor.plugins.map((plugin$1) => {
				if (typeof plugin$1 === "object" && plugin$1.prepare) return {
					...plugin$1,
					...plugin$1.prepare(this.result)
				};
				else return plugin$1;
			});
		}
		async() {
			if (this.error) return Promise.reject(this.error);
			if (this.processed) return Promise.resolve(this.result);
			if (!this.processing) this.processing = this.runAsync();
			return this.processing;
		}
		catch(onRejected) {
			return this.async().catch(onRejected);
		}
		finally(onFinally) {
			return this.async().then(onFinally, onFinally);
		}
		getAsyncError() {
			throw new Error("Use process(css).then(cb) to work with async plugins");
		}
		handleError(error, node) {
			let plugin$1 = this.result.lastPlugin;
			try {
				if (node) node.addToError(error);
				this.error = error;
				if (error.name === "CssSyntaxError" && !error.plugin) {
					error.plugin = plugin$1.postcssPlugin;
					error.setMessage();
				} else if (plugin$1.postcssVersion) {
					if (process.env.NODE_ENV !== "production") {
						let pluginName = plugin$1.postcssPlugin;
						let pluginVer = plugin$1.postcssVersion;
						let runtimeVer = this.result.processor.version;
						let a = pluginVer.split(".");
						let b$1 = runtimeVer.split(".");
						if (a[0] !== b$1[0] || parseInt(a[1]) > parseInt(b$1[1])) console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
					}
				}
			} catch (err) {
				/* c8 ignore next 3 */
				if (console && console.error) console.error(err);
			}
			return error;
		}
		prepareVisitors() {
			this.listeners = {};
			let add = (plugin$1, type, cb) => {
				if (!this.listeners[type]) this.listeners[type] = [];
				this.listeners[type].push([plugin$1, cb]);
			};
			for (let plugin$1 of this.plugins) if (typeof plugin$1 === "object") for (let event in plugin$1) {
				if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) throw new Error(`Unknown event ${event} in ${plugin$1.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
				if (!NOT_VISITORS[event]) {
					if (typeof plugin$1[event] === "object") for (let filter in plugin$1[event]) if (filter === "*") add(plugin$1, event, plugin$1[event][filter]);
					else add(plugin$1, event + "-" + filter.toLowerCase(), plugin$1[event][filter]);
					else if (typeof plugin$1[event] === "function") add(plugin$1, event, plugin$1[event]);
				}
			}
			this.hasListener = Object.keys(this.listeners).length > 0;
		}
		async runAsync() {
			this.plugin = 0;
			for (let i$1 = 0; i$1 < this.plugins.length; i$1++) {
				let plugin$1 = this.plugins[i$1];
				let promise = this.runOnRoot(plugin$1);
				if (isPromise(promise)) try {
					await promise;
				} catch (error) {
					throw this.handleError(error);
				}
			}
			this.prepareVisitors();
			if (this.hasListener) {
				let root$1 = this.result.root;
				while (!root$1[isClean]) {
					root$1[isClean] = true;
					let stack = [toStack(root$1)];
					while (stack.length > 0) {
						let promise = this.visitTick(stack);
						if (isPromise(promise)) try {
							await promise;
						} catch (e$1) {
							let node = stack[stack.length - 1].node;
							throw this.handleError(e$1, node);
						}
					}
				}
				if (this.listeners.OnceExit) for (let [plugin$1, visitor] of this.listeners.OnceExit) {
					this.result.lastPlugin = plugin$1;
					try {
						if (root$1.type === "document") {
							let roots = root$1.nodes.map((subRoot) => visitor(subRoot, this.helpers));
							await Promise.all(roots);
						} else await visitor(root$1, this.helpers);
					} catch (e$1) {
						throw this.handleError(e$1);
					}
				}
			}
			this.processed = true;
			return this.stringify();
		}
		runOnRoot(plugin$1) {
			this.result.lastPlugin = plugin$1;
			try {
				if (typeof plugin$1 === "object" && plugin$1.Once) {
					if (this.result.root.type === "document") {
						let roots = this.result.root.nodes.map((root$1) => plugin$1.Once(root$1, this.helpers));
						if (isPromise(roots[0])) return Promise.all(roots);
						return roots;
					}
					return plugin$1.Once(this.result.root, this.helpers);
				} else if (typeof plugin$1 === "function") return plugin$1(this.result.root, this.result);
			} catch (error) {
				throw this.handleError(error);
			}
		}
		stringify() {
			if (this.error) throw this.error;
			if (this.stringified) return this.result;
			this.stringified = true;
			this.sync();
			let opts = this.result.opts;
			let str = stringify$10;
			if (opts.syntax) str = opts.syntax.stringify;
			if (opts.stringifier) str = opts.stringifier;
			if (str.stringify) str = str.stringify;
			let data$1 = new MapGenerator$1(str, this.result.root, this.result.opts).generate();
			this.result.css = data$1[0];
			this.result.map = data$1[1];
			return this.result;
		}
		sync() {
			if (this.error) throw this.error;
			if (this.processed) return this.result;
			this.processed = true;
			if (this.processing) throw this.getAsyncError();
			for (let plugin$1 of this.plugins) {
				let promise = this.runOnRoot(plugin$1);
				if (isPromise(promise)) throw this.getAsyncError();
			}
			this.prepareVisitors();
			if (this.hasListener) {
				let root$1 = this.result.root;
				while (!root$1[isClean]) {
					root$1[isClean] = true;
					this.walkSync(root$1);
				}
				if (this.listeners.OnceExit) if (root$1.type === "document") for (let subRoot of root$1.nodes) this.visitSync(this.listeners.OnceExit, subRoot);
				else this.visitSync(this.listeners.OnceExit, root$1);
			}
			return this.result;
		}
		then(onFulfilled, onRejected) {
			if (process.env.NODE_ENV !== "production") {
				if (!("from" in this.opts)) warnOnce$1("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
			}
			return this.async().then(onFulfilled, onRejected);
		}
		toString() {
			return this.css;
		}
		visitSync(visitors, node) {
			for (let [plugin$1, visitor] of visitors) {
				this.result.lastPlugin = plugin$1;
				let promise;
				try {
					promise = visitor(node, this.helpers);
				} catch (e$1) {
					throw this.handleError(e$1, node.proxyOf);
				}
				if (node.type !== "root" && node.type !== "document" && !node.parent) return true;
				if (isPromise(promise)) throw this.getAsyncError();
			}
		}
		visitTick(stack) {
			let visit$6 = stack[stack.length - 1];
			let { node, visitors } = visit$6;
			if (node.type !== "root" && node.type !== "document" && !node.parent) {
				stack.pop();
				return;
			}
			if (visitors.length > 0 && visit$6.visitorIndex < visitors.length) {
				let [plugin$1, visitor] = visitors[visit$6.visitorIndex];
				visit$6.visitorIndex += 1;
				if (visit$6.visitorIndex === visitors.length) {
					visit$6.visitors = [];
					visit$6.visitorIndex = 0;
				}
				this.result.lastPlugin = plugin$1;
				try {
					return visitor(node.toProxy(), this.helpers);
				} catch (e$1) {
					throw this.handleError(e$1, node);
				}
			}
			if (visit$6.iterator !== 0) {
				let iterator = visit$6.iterator;
				let child;
				while (child = node.nodes[node.indexes[iterator]]) {
					node.indexes[iterator] += 1;
					if (!child[isClean]) {
						child[isClean] = true;
						stack.push(toStack(child));
						return;
					}
				}
				visit$6.iterator = 0;
				delete node.indexes[iterator];
			}
			let events = visit$6.events;
			while (visit$6.eventIndex < events.length) {
				let event = events[visit$6.eventIndex];
				visit$6.eventIndex += 1;
				if (event === CHILDREN) {
					if (node.nodes && node.nodes.length) {
						node[isClean] = true;
						visit$6.iterator = node.getIterator();
					}
					return;
				} else if (this.listeners[event]) {
					visit$6.visitors = this.listeners[event];
					return;
				}
			}
			stack.pop();
		}
		walkSync(node) {
			node[isClean] = true;
			let events = getEvents(node);
			for (let event of events) if (event === CHILDREN) {
				if (node.nodes) node.each((child) => {
					if (!child[isClean]) this.walkSync(child);
				});
			} else {
				let visitors = this.listeners[event];
				if (visitors) {
					if (this.visitSync(visitors, node.toProxy())) return;
				}
			}
		}
		warnings() {
			return this.sync().warnings();
		}
	};
	LazyResult$2.registerPostcss = (dependant) => {
		postcss$2 = dependant;
	};
	module.exports = LazyResult$2;
	LazyResult$2.default = LazyResult$2;
	Root$3.registerLazyResult(LazyResult$2);
	Document$9.registerLazyResult(LazyResult$2);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/no-work-result.js
var require_no_work_result = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/no-work-result.js": ((exports, module) => {
	let MapGenerator = require_map_generator();
	let parse$4 = require_parse();
	const Result$2 = require_result();
	let stringify$9 = require_stringify$1();
	let warnOnce = require_warn_once();
	var NoWorkResult$1 = class {
		get content() {
			return this.result.css;
		}
		get css() {
			return this.result.css;
		}
		get map() {
			return this.result.map;
		}
		get messages() {
			return [];
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			if (this._root) return this._root;
			let root$1;
			let parser$2 = parse$4;
			try {
				root$1 = parser$2(this._css, this._opts);
			} catch (error) {
				this.error = error;
			}
			if (this.error) throw this.error;
			else {
				this._root = root$1;
				return root$1;
			}
		}
		get [Symbol.toStringTag]() {
			return "NoWorkResult";
		}
		constructor(processor, css, opts) {
			css = css.toString();
			this.stringified = false;
			this._processor = processor;
			this._css = css;
			this._opts = opts;
			this._map = void 0;
			let root$1;
			let str = stringify$9;
			this.result = new Result$2(this._processor, root$1, this._opts);
			this.result.css = css;
			let self$1 = this;
			Object.defineProperty(this.result, "root", { get() {
				return self$1.root;
			} });
			let map$6 = new MapGenerator(str, root$1, this._opts, css);
			if (map$6.isMap()) {
				let [generatedCSS, generatedMap] = map$6.generate();
				if (generatedCSS) this.result.css = generatedCSS;
				if (generatedMap) this.result.map = generatedMap;
			} else {
				map$6.clearAnnotation();
				this.result.css = map$6.css;
			}
		}
		async() {
			if (this.error) return Promise.reject(this.error);
			return Promise.resolve(this.result);
		}
		catch(onRejected) {
			return this.async().catch(onRejected);
		}
		finally(onFinally) {
			return this.async().then(onFinally, onFinally);
		}
		sync() {
			if (this.error) throw this.error;
			return this.result;
		}
		then(onFulfilled, onRejected) {
			if (process.env.NODE_ENV !== "production") {
				if (!("from" in this._opts)) warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
			}
			return this.async().then(onFulfilled, onRejected);
		}
		toString() {
			return this._css;
		}
		warnings() {
			return [];
		}
	};
	module.exports = NoWorkResult$1;
	NoWorkResult$1.default = NoWorkResult$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/processor.js
var require_processor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/processor.js": ((exports, module) => {
	let Document$8 = require_document();
	let LazyResult$1 = require_lazy_result();
	let NoWorkResult = require_no_work_result();
	let Root$2 = require_root();
	var Processor$2 = class {
		constructor(plugins = []) {
			this.version = "8.5.6";
			this.plugins = this.normalize(plugins);
		}
		normalize(plugins) {
			let normalized = [];
			for (let i$1 of plugins) {
				if (i$1.postcss === true) i$1 = i$1();
				else if (i$1.postcss) i$1 = i$1.postcss;
				if (typeof i$1 === "object" && Array.isArray(i$1.plugins)) normalized = normalized.concat(i$1.plugins);
				else if (typeof i$1 === "object" && i$1.postcssPlugin) normalized.push(i$1);
				else if (typeof i$1 === "function") normalized.push(i$1);
				else if (typeof i$1 === "object" && (i$1.parse || i$1.stringify)) {
					if (process.env.NODE_ENV !== "production") throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
				} else throw new Error(i$1 + " is not a PostCSS plugin");
			}
			return normalized;
		}
		process(css, opts = {}) {
			if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) return new NoWorkResult(this, css, opts);
			else return new LazyResult$1(this, css, opts);
		}
		use(plugin$1) {
			this.plugins = this.plugins.concat(this.normalize([plugin$1]));
			return this;
		}
	};
	module.exports = Processor$2;
	Processor$2.default = Processor$2;
	Root$2.registerProcessor(Processor$2);
	Document$8.registerProcessor(Processor$2);
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/postcss.js
var require_postcss = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/postcss.js": ((exports, module) => {
	let AtRule$1 = require_at_rule();
	let Comment$1 = require_comment();
	let Container$1 = require_container();
	let CssSyntaxError$1 = require_css_syntax_error();
	let Declaration$1 = require_declaration();
	let Document$7 = require_document();
	let fromJSON$1 = require_fromJSON();
	let Input$1 = require_input();
	let LazyResult = require_lazy_result();
	let list$2 = require_list();
	let Node$5 = require_node();
	let parse$3 = require_parse();
	let Processor$1 = require_processor();
	let Result$1 = require_result();
	let Root$1 = require_root();
	let Rule$1 = require_rule();
	let stringify$8 = require_stringify$1();
	let Warning$1 = require_warning();
	function postcss$1(...plugins) {
		if (plugins.length === 1 && Array.isArray(plugins[0])) plugins = plugins[0];
		return new Processor$1(plugins);
	}
	postcss$1.plugin = function plugin$1(name, initializer) {
		let warningPrinted = false;
		function creator(...args) {
			if (console && console.warn && !warningPrinted) {
				warningPrinted = true;
				console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
				if (process.env.LANG && process.env.LANG.startsWith("cn"))
 /* c8 ignore next 7 */
				console.warn(name + ":  postcss.plugin . :\nhttps://www.w3ctech.com/topic/2226");
			}
			let transformer = initializer(...args);
			transformer.postcssPlugin = name;
			transformer.postcssVersion = new Processor$1().version;
			return transformer;
		}
		let cache;
		Object.defineProperty(creator, "postcss", { get() {
			if (!cache) cache = creator();
			return cache;
		} });
		creator.process = function(css, processOpts, pluginOpts) {
			return postcss$1([creator(pluginOpts)]).process(css, processOpts);
		};
		return creator;
	};
	postcss$1.stringify = stringify$8;
	postcss$1.parse = parse$3;
	postcss$1.fromJSON = fromJSON$1;
	postcss$1.list = list$2;
	postcss$1.comment = (defaults) => new Comment$1(defaults);
	postcss$1.atRule = (defaults) => new AtRule$1(defaults);
	postcss$1.decl = (defaults) => new Declaration$1(defaults);
	postcss$1.rule = (defaults) => new Rule$1(defaults);
	postcss$1.root = (defaults) => new Root$1(defaults);
	postcss$1.document = (defaults) => new Document$7(defaults);
	postcss$1.CssSyntaxError = CssSyntaxError$1;
	postcss$1.Declaration = Declaration$1;
	postcss$1.Container = Container$1;
	postcss$1.Processor = Processor$1;
	postcss$1.Document = Document$7;
	postcss$1.Comment = Comment$1;
	postcss$1.Warning = Warning$1;
	postcss$1.AtRule = AtRule$1;
	postcss$1.Result = Result$1;
	postcss$1.Input = Input$1;
	postcss$1.Rule = Rule$1;
	postcss$1.Root = Root$1;
	postcss$1.Node = Node$5;
	LazyResult.registerPostcss(postcss$1);
	module.exports = postcss$1;
	postcss$1.default = postcss$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss@8.5.6/node_modules/postcss/lib/postcss.mjs
var import_postcss = /* @__PURE__ */ __toESM(require_postcss(), 1);
const stringify$7 = import_postcss.default.stringify;
const fromJSON = import_postcss.default.fromJSON;
const plugin = import_postcss.default.plugin;
const parse = import_postcss.default.parse;
const list$1 = import_postcss.default.list;
const document = import_postcss.default.document;
const comment = import_postcss.default.comment;
const atRule = import_postcss.default.atRule;
const rule = import_postcss.default.rule;
const decl = import_postcss.default.decl;
const root = import_postcss.default.root;
const CssSyntaxError = import_postcss.default.CssSyntaxError;
const Declaration = import_postcss.default.Declaration;
const Container = import_postcss.default.Container;
const Processor = import_postcss.default.Processor;
const Document$6 = import_postcss.default.Document;
const Comment = import_postcss.default.Comment;
const Warning = import_postcss.default.Warning;
const AtRule = import_postcss.default.AtRule;
const Result = import_postcss.default.Result;
const Input = import_postcss.default.Input;
const Rule = import_postcss.default.Rule;
const Root = import_postcss.default.Root;
const Node$4 = import_postcss.default.Node;

//#endregion
//#region ../../node_modules/.pnpm/silver-fleece@1.2.1/node_modules/silver-fleece/dist/silver-fleece.umd.js
var require_silver_fleece_umd = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/silver-fleece@1.2.1/node_modules/silver-fleece/dist/silver-fleece.umd.js": ((exports, module) => {
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global$1 = typeof globalThis !== "undefined" ? globalThis : global$1 || self, factory(global$1.fleece = {}));
	})(exports, (function(exports$1) {
		/******************************************************************************
		Copyright (c) Microsoft Corporation.
		
		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted.
		
		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		PERFORMANCE OF THIS SOFTWARE.
		***************************************************************************** */
		var extendStatics = function(d$1, b$1) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$2) {
				d$2.__proto__ = b$2;
			} || function(d$2, b$2) {
				for (var p$2 in b$2) if (Object.prototype.hasOwnProperty.call(b$2, p$2)) d$2[p$2] = b$2[p$2];
			};
			return extendStatics(d$1, b$1);
		};
		function __extends(d$1, b$1) {
			if (typeof b$1 !== "function" && b$1 !== null) throw new TypeError("Class extends value " + String(b$1) + " is not a constructor or null");
			extendStatics(d$1, b$1);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b$1 === null ? Object.create(b$1) : (__.prototype = b$1.prototype, new __());
		}
		var whitespace = /\s/;
		var number = /-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/;
		function spaces(n$1) {
			var result = "";
			while (n$1--) result += " ";
			return result;
		}
		function rangeContains(range, index) {
			return range.start <= index && index < range.end;
		}
		function getLocator$1(source, options) {
			if (options === void 0) options = {};
			var _a$1 = options.offsetLine, offsetLine = _a$1 === void 0 ? 0 : _a$1, _b = options.offsetColumn, offsetColumn = _b === void 0 ? 0 : _b;
			var start = 0;
			var ranges = source.split("\n").map(function(line, i$2) {
				var end = start + line.length + 1;
				var range = {
					start,
					end,
					line: i$2
				};
				start = end;
				return range;
			});
			var i$1 = 0;
			function locator(search, index) {
				if (typeof search === "string") search = source.indexOf(search, index !== null && index !== void 0 ? index : 0);
				if (search === -1) return void 0;
				var range = ranges[i$1];
				var d$1 = search >= range.end ? 1 : -1;
				while (range) {
					if (rangeContains(range, search)) return {
						line: offsetLine + range.line,
						column: offsetColumn + search - range.start,
						character: search
					};
					i$1 += d$1;
					range = ranges[i$1];
				}
			}
			return locator;
		}
		function locate(source, search, options) {
			return getLocator$1(source, options)(search, options && options.startIndex);
		}
		function parse$8(str, opts) {
			return new Parser$5(str, opts).value;
		}
		function noop() {}
		var ParseError = function(_super) {
			__extends(ParseError$1, _super);
			function ParseError$1(message, pos, loc) {
				var _this = _super.call(this, message) || this;
				_this.pos = pos;
				_this.loc = loc;
				return _this;
			}
			return ParseError$1;
		}(Error);
		var Parser$5 = function() {
			function Parser$6(str, opts) {
				this.str = str;
				this.index = 0;
				this.onComment = opts && opts.onComment || noop;
				this.onValue = opts && opts.onValue || noop;
				this.value = this.readValue();
				this.readWhitespaceOrComment();
				if (this.index < this.str.length) throw new Error("Unexpected character '".concat(this.peek(), "'"));
			}
			Parser$6.prototype.readWhitespaceOrComment = function() {
				while (this.index < this.str.length && whitespace.test(this.str[this.index])) this.index++;
				var start = this.index;
				if (this.eat("/")) {
					if (this.eat("/")) {
						var text = this.readUntil(/(?:\r\n|\n|\r)/);
						this.onComment({
							start,
							end: this.index,
							type: "Comment",
							text,
							block: false
						});
						this.eat("\n");
					} else if (this.eat("*")) {
						var text = this.readUntil(/\*\//);
						this.onComment({
							start,
							end: this.index,
							type: "Comment",
							text,
							block: true
						});
						this.eat("*/", true);
					}
				} else return;
				this.readWhitespaceOrComment();
			};
			Parser$6.prototype.error = function(message, index) {
				if (index === void 0) index = this.index;
				var loc = locate(this.str, index, { offsetLine: 1 });
				throw new ParseError(message, index, loc);
			};
			Parser$6.prototype.eat = function(str, required) {
				if (this.str.slice(this.index, this.index + str.length) === str) {
					this.index += str.length;
					return str;
				}
				if (required) this.error("Expected '".concat(str, "' instead of '").concat(this.str[this.index], "'"));
				return null;
			};
			Parser$6.prototype.peek = function() {
				return this.str[this.index];
			};
			Parser$6.prototype.read = function(pattern) {
				var match = pattern.exec(this.str.slice(this.index));
				if (!match || match.index !== 0) return null;
				this.index += match[0].length;
				return match[0];
			};
			Parser$6.prototype.readUntil = function(pattern) {
				if (this.index >= this.str.length) this.error("Unexpected end of input");
				var start = this.index;
				var match = pattern.exec(this.str.slice(start));
				if (match) {
					var start_1 = this.index;
					this.index = start_1 + match.index;
					return this.str.slice(start_1, this.index);
				}
				this.index = this.str.length;
				return this.str.slice(start);
			};
			Parser$6.prototype.readArray = function() {
				var start = this.index;
				if (!this.eat("[")) return null;
				var array = {
					start,
					end: null,
					type: "ArrayExpression",
					elements: []
				};
				this.readWhitespaceOrComment();
				while (this.peek() !== "]") {
					array.elements.push(this.readValue());
					this.readWhitespaceOrComment();
					if (!this.eat(",")) break;
					this.readWhitespaceOrComment();
				}
				if (!this.eat("]")) this.error("Expected ']' instead of '".concat(this.str[this.index], "'"));
				array.end = this.index;
				return array;
			};
			Parser$6.prototype.readBoolean = function() {
				var start = this.index;
				var raw = this.read(/^(true|false)/);
				if (raw) return {
					start,
					end: this.index,
					type: "Literal",
					raw,
					value: raw === "true"
				};
			};
			Parser$6.prototype.readNull = function() {
				var start = this.index;
				if (this.eat("null")) return {
					start,
					end: this.index,
					type: "Literal",
					raw: "null",
					value: null
				};
			};
			Parser$6.prototype.readLiteral = function() {
				return this.readBoolean() || this.readNumber() || this.readString() || this.readNull();
			};
			Parser$6.prototype.readNumber = function() {
				var start = this.index;
				var raw = this.read(number);
				if (raw) return {
					start,
					end: this.index,
					type: "Literal",
					raw,
					value: Number(raw)
				};
			};
			Parser$6.prototype.readObject = function() {
				var start = this.index;
				if (!this.eat("{")) return;
				var object = {
					start,
					end: null,
					type: "ObjectExpression",
					properties: []
				};
				this.readWhitespaceOrComment();
				while (this.peek() !== "}") {
					object.properties.push(this.readProperty());
					this.readWhitespaceOrComment();
					if (!this.eat(",")) break;
					this.readWhitespaceOrComment();
				}
				this.eat("}", true);
				object.end = this.index;
				return object;
			};
			Parser$6.prototype.readProperty = function() {
				this.readWhitespaceOrComment();
				var property = {
					start: this.index,
					end: null,
					type: "Property",
					key: this.readPropertyKey(),
					value: this.readValue()
				};
				property.end = this.index;
				return property;
			};
			Parser$6.prototype.readPropertyKey = function() {
				var key = this.readString();
				if (!key) this.error("Bad identifier");
				if (key.type === "Literal") key.name = String(key.value);
				this.readWhitespaceOrComment();
				this.eat(":", true);
				return key;
			};
			Parser$6.prototype.readString = function() {
				var start = this.index;
				if (!this.eat("\"")) return;
				var end = this.str.indexOf("\"", start + 1);
				while (end > 0 && this.str[end - 1] === "\\") end = this.str.indexOf("\"", end + 1);
				if (end === -1) this.error("Unexpected end of input");
				end++;
				this.index = end;
				var raw = this.str.slice(start, end);
				return {
					start,
					end,
					type: "Literal",
					raw,
					value: JSON.parse(raw)
				};
			};
			Parser$6.prototype.readValue = function() {
				this.readWhitespaceOrComment();
				var value = this.readArray() || this.readObject() || this.readLiteral();
				if (value) {
					this.onValue(value);
					return value;
				}
				this.error("Unexpected EOF");
			};
			return Parser$6;
		}();
		function evaluate(str, opts) {
			var ast = parse$8(str, opts);
			return getValue(ast);
		}
		function getValue(node) {
			if (node.type === "Literal") return node.value;
			if (node.type === "ArrayExpression") return node.elements.map(getValue);
			if (node.type === "ObjectExpression") {
				var obj_1 = {};
				node.properties.forEach(function(prop) {
					obj_1[prop.key.name] = getValue(prop.value);
				});
				return obj_1;
			}
		}
		function stringify$13(value, options) {
			var indentString = options && options.spaces ? spaces(options.spaces) : "	";
			return stringifyValue(value, "\n", indentString, true);
		}
		function stringifyProperty(key, value, indentation, indentString, newlines) {
			return JSON.stringify(key) + ": " + stringifyValue(value, indentation, indentString, newlines);
		}
		function stringifyValue(value, indentation, indentString, newlines) {
			var type = typeof value;
			if (type === "boolean" || type === "number" || type === "string" || type === null) return JSON.stringify(value);
			else if (Array.isArray(value)) {
				var elements = value.map(function(element) {
					return stringifyValue(element, indentation + indentString, indentString, true);
				});
				if (newlines) return "[".concat(indentation + indentString) + elements.join(",".concat(indentation + indentString)) + "".concat(indentation, "]");
				return "[ ".concat(elements.join(", "), " ]");
			} else if (type === "object") {
				var properties = Object.keys(value).map(function(key) {
					return stringifyProperty(key, value[key], indentation + indentString, indentString, newlines);
				});
				if (newlines) return "{".concat(indentation + indentString) + properties.join(",".concat(indentation + indentString)) + "".concat(indentation, "}");
				return "{ ".concat(properties.join(", "), " }");
			}
			throw new Error("Cannot stringify ".concat(type));
		}
		function patch(str, value) {
			var indentString = guessIndentString$1(str);
			var root$1 = parse$8(str);
			var newlines = /\n/.test(str.slice(root$1.start, root$1.end)) || root$1.type === "ArrayExpression" && root$1.elements.length === 0 || root$1.type === "ObjectExpression" && root$1.properties.length === 0;
			return str.slice(0, root$1.start) + patchValue(root$1, value, str, "\n", indentString, newlines) + str.slice(root$1.end);
		}
		function patchValue(node, value, str, indentation, indentString, newlines) {
			var type = typeof value;
			if (type === "string") return JSON.stringify(value);
			if (type === "number") return patchNumber(node.raw, value);
			if (type === "boolean" || value === null) return String(value);
			if (Array.isArray(value)) {
				if (node.type === "ArrayExpression") return patchArray(node, value, str, indentation, indentString);
				return stringifyValue(value, indentation, indentString, newlines);
			}
			if (type === "object") {
				if (node.type === "ObjectExpression") return patchObject(node, value, str, indentation, indentString);
				return stringifyValue(value, indentation, indentString, newlines);
			}
			throw new Error("Cannot stringify ".concat(type, "s"));
		}
		function patchNumber(raw, value) {
			return String(value);
		}
		function patchArray(node, value, str, indentation, indentString, newlines) {
			if (value.length === 0) return node.elements.length === 0 ? str.slice(node.start, node.end) : "[]";
			var precedingWhitespace = getPrecedingWhitespace(str, node.start);
			var newline$1 = precedingWhitespace === "" || /\n/.test(precedingWhitespace);
			if (node.elements.length === 0) return stringifyValue(value, indentation, indentString, newline$1);
			var i$1 = 0;
			var c$2 = node.start;
			var patched = "";
			var newlinesInsideValue = str.slice(node.start, node.end).split("\n").length > 1;
			for (; i$1 < value.length; i$1 += 1) {
				var element = node.elements[i$1];
				if (element) {
					patched += str.slice(c$2, element.start) + patchValue(element, value[i$1], str, indentation, indentString, newlinesInsideValue);
					c$2 = element.end;
				} else if (newlinesInsideValue) patched += ",".concat(indentation + indentString) + stringifyValue(value[i$1], indentation, indentString, true);
				else patched += ", " + stringifyValue(value[i$1], indentation, indentString, false);
			}
			if (i$1 < node.elements.length) c$2 = node.elements[node.elements.length - 1].end;
			patched += str.slice(c$2, node.end);
			return patched;
		}
		function patchObject(node, value, str, indentation, indentString, newlines) {
			var keys = Object.keys(value);
			if (keys.length === 0) return node.properties.length === 0 ? str.slice(node.start, node.end) : "{}";
			var existingProperties = {};
			node.properties.forEach(function(prop) {
				existingProperties[prop.key.name] = prop;
			});
			var precedingWhitespace = getPrecedingWhitespace(str, node.start);
			var newline$1 = precedingWhitespace === "" || /\n/.test(precedingWhitespace);
			if (node.properties.length === 0) return stringifyValue(value, indentation, indentString, newline$1);
			var i$1 = 0;
			var c$2 = node.start;
			var patched = "";
			var newlinesInsideValue = /\n/.test(str.slice(node.start, node.end));
			var started = false;
			var intro = str.slice(node.start, node.properties[0].start);
			for (; i$1 < node.properties.length; i$1 += 1) {
				var property = node.properties[i$1];
				var propertyValue = value[property.key.name];
				indentation = getIndentation(str, property.start);
				if (propertyValue !== void 0) {
					patched += started ? str.slice(c$2, property.value.start) : intro + str.slice(property.key.start, property.value.start);
					patched += patchValue(property.value, propertyValue, str, indentation, indentString, newlinesInsideValue);
					started = true;
				}
				c$2 = property.end;
			}
			keys.forEach(function(key) {
				if (key in existingProperties) return;
				var propertyValue$1 = value[key];
				patched += (started ? "," + (newlinesInsideValue ? indentation : " ") : intro) + stringifyProperty(key, propertyValue$1, indentation, indentString, newlinesInsideValue);
				started = true;
			});
			patched += str.slice(c$2, node.end);
			return patched;
		}
		function getIndentation(str, i$1) {
			while (i$1 > 0 && !whitespace.test(str[i$1 - 1])) i$1 -= 1;
			var end = i$1;
			while (i$1 > 0 && whitespace.test(str[i$1 - 1])) i$1 -= 1;
			return str.slice(i$1, end);
		}
		function getPrecedingWhitespace(str, i$1) {
			var end = i$1;
			while (i$1 > 0 && whitespace.test(str[i$1])) i$1 -= 1;
			return str.slice(i$1, end);
		}
		function guessIndentString$1(str) {
			var lines = str.split("\n");
			var tabs = 0;
			var spaces$1 = 0;
			var minSpaces = 8;
			lines.forEach(function(line) {
				var match = /^(?: +|\t+)/.exec(line);
				if (!match) return;
				var whitespace$1 = match[0];
				if (whitespace$1.length === line.length) return;
				if (whitespace$1[0] === "	") tabs += 1;
				else {
					spaces$1 += 1;
					if (whitespace$1.length > 1 && whitespace$1.length < minSpaces) minSpaces = whitespace$1.length;
				}
			});
			if (spaces$1 > tabs) {
				var result = "";
				while (minSpaces--) result += " ";
				return result;
			} else return "	";
		}
		exports$1.evaluate = evaluate;
		exports$1.parse = parse$8;
		exports$1.patch = patch;
		exports$1.stringify = stringify$13;
	}));
}) });

//#endregion
//#region ../../node_modules/.pnpm/esrap@1.4.9/node_modules/esrap/src/handlers.js
/** @import { TSESTree } from '@typescript-eslint/types' */
/** @import { Command, Dedent, Handlers, Location, Indent, Newline, NodeWithComments, State, TypeAnnotationNodes } from './types' */
/** @type {Newline} */
const newline = { type: "Newline" };
/** @type {Indent} */
const indent$1 = { type: "Indent" };
/** @type {Dedent} */
const dedent = { type: "Dedent" };
/**
* @returns {Command[]}
*/
function create_sequence() {
	return [];
}
/**
* Rough estimate of the combined width of a group of commands
* @param {Command[]} commands
* @param {number} from
* @param {number} to
*/
function measure(commands, from$1, to = commands.length) {
	let total = 0;
	for (let i$1 = from$1; i$1 < to; i$1 += 1) {
		const command = commands[i$1];
		if (typeof command === "string") total += command.length;
		else if (Array.isArray(command)) total += command.length === 0 ? 2 : measure(command, 0);
	}
	return total;
}
/**
* @param {TSESTree.Node} node
* @param {State} state
*/
function handle(node, state) {
	const node_with_comments = node;
	const handler = handlers[node.type];
	if (!handler) throw new Error(`Not implemented ${node.type}`);
	if (node_with_comments.leadingComments) prepend_comments(node_with_comments.leadingComments, state, false);
	handler(node, state);
	if (node_with_comments.trailingComments) state.comments.push(node_with_comments.trailingComments[0]);
}
/**
* @param {number} line
* @param {number} column
* @returns {Location}
*/
function l$1(line, column) {
	return {
		type: "Location",
		line,
		column
	};
}
/**
* @param {string} content
* @param {TSESTree.Node} node
* @returns {string | Command[]}
*/
function c(content, node) {
	return node.loc ? [
		l$1(node.loc.start.line, node.loc.start.column),
		content,
		l$1(node.loc.end.line, node.loc.end.column)
	] : content;
}
/**
* @param {TSESTree.Comment[]} comments
* @param {State} state
* @param {boolean} newlines
*/
function prepend_comments(comments, state, newlines) {
	for (const comment$1 of comments) {
		state.commands.push({
			type: "Comment",
			comment: comment$1
		});
		if (newlines || comment$1.type === "Line" || /\n/.test(comment$1.value)) state.commands.push(newline);
		else state.commands.push(" ");
	}
}
/**
* @param {string} string
* @param {'\'' | '"'} char
*/
function quote(string$5, char) {
	let out = char;
	for (const c$2 of string$5) if (c$2 === "\\") out += "\\\\";
	else if (c$2 === char) out += "\\" + c$2;
	else if (c$2 === "\n") out += "\\n";
	else if (c$2 === "\r") out += "\\r";
	else out += c$2;
	return out + char;
}
const OPERATOR_PRECEDENCE = {
	"||": 2,
	"&&": 3,
	"??": 4,
	"|": 5,
	"^": 6,
	"&": 7,
	"==": 8,
	"!=": 8,
	"===": 8,
	"!==": 8,
	"<": 9,
	">": 9,
	"<=": 9,
	">=": 9,
	in: 9,
	instanceof: 9,
	"<<": 10,
	">>": 10,
	">>>": 10,
	"+": 11,
	"-": 11,
	"*": 12,
	"%": 12,
	"/": 12,
	"**": 13
};
/** @type {Record<TSESTree.Expression['type'] | 'Super' | 'RestElement', number>} */
const EXPRESSIONS_PRECEDENCE = {
	JSXFragment: 20,
	JSXElement: 20,
	ArrayPattern: 20,
	ObjectPattern: 20,
	ArrayExpression: 20,
	TaggedTemplateExpression: 20,
	ThisExpression: 20,
	Identifier: 20,
	TemplateLiteral: 20,
	Super: 20,
	SequenceExpression: 20,
	MemberExpression: 19,
	MetaProperty: 19,
	CallExpression: 19,
	ChainExpression: 19,
	ImportExpression: 19,
	NewExpression: 19,
	Literal: 18,
	TSSatisfiesExpression: 18,
	TSInstantiationExpression: 18,
	TSNonNullExpression: 18,
	TSTypeAssertion: 18,
	AwaitExpression: 17,
	ClassExpression: 17,
	FunctionExpression: 17,
	ObjectExpression: 17,
	TSAsExpression: 16,
	UpdateExpression: 16,
	UnaryExpression: 15,
	BinaryExpression: 14,
	LogicalExpression: 13,
	ConditionalExpression: 4,
	ArrowFunctionExpression: 3,
	AssignmentExpression: 3,
	YieldExpression: 2,
	RestElement: 1
};
/**
*
* @param {TSESTree.Expression | TSESTree.PrivateIdentifier} node
* @param {TSESTree.BinaryExpression | TSESTree.LogicalExpression} parent
* @param {boolean} is_right
* @returns
*/
function needs_parens(node, parent, is_right) {
	if (node.type === "PrivateIdentifier") return false;
	if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) return true;
	const precedence = EXPRESSIONS_PRECEDENCE[node.type];
	const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
	if (precedence !== parent_precedence) return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
	if (precedence !== 13 && precedence !== 14) return false;
	if (node.operator === "**" && parent.operator === "**") return !is_right;
	if (is_right) return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parent.operator];
	return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parent.operator];
}
/** @param {TSESTree.Node} node */
function has_call_expression(node) {
	while (node) if (node.type === "CallExpression") return true;
	else if (node.type === "MemberExpression") node = node.object;
	else return false;
}
const grouped_expression_types = [
	"ImportDeclaration",
	"VariableDeclaration",
	"ExportDefaultDeclaration",
	"ExportNamedDeclaration"
];
/**
* @param {TSESTree.Node[]} nodes
* @param {State} state
*/
const handle_body = (nodes, state) => {
	let last_statement = { type: "EmptyStatement" };
	let first = true;
	let needs_margin = false;
	for (const statement of nodes) {
		if (statement.type === "EmptyStatement") continue;
		const margin = create_sequence();
		if (!first) state.commands.push(margin, newline);
		first = false;
		const statement_with_comments = statement;
		const leading_comments = statement_with_comments.leadingComments;
		delete statement_with_comments.leadingComments;
		if (leading_comments && leading_comments.length > 0) prepend_comments(leading_comments, state, true);
		const child_state = {
			...state,
			multiline: false
		};
		handle(statement, child_state);
		if (child_state.multiline || needs_margin || (grouped_expression_types.includes(statement.type) || grouped_expression_types.includes(last_statement.type)) && last_statement.type !== statement.type) margin.push("\n");
		let add_newline = false;
		while (state.comments.length) {
			const comment$1 = state.comments.shift();
			state.commands.push(add_newline ? newline : " ", {
				type: "Comment",
				comment: comment$1
			});
			add_newline = comment$1.type === "Line";
		}
		needs_margin = child_state.multiline;
		last_statement = statement;
	}
};
/**
* @param {TSESTree.VariableDeclaration} node
* @param {State} state
*/
const handle_var_declaration = (node, state) => {
	const index = state.commands.length;
	const open = create_sequence();
	const join$3 = create_sequence();
	const child_state = {
		...state,
		multiline: false
	};
	state.commands.push(`${node.kind} `, open);
	let first = true;
	for (const d$1 of node.declarations) {
		if (!first) state.commands.push(join$3);
		first = false;
		handle(d$1, child_state);
	}
	if (child_state.multiline || node.declarations.length > 1 && measure(state.commands, index) > 50) {
		state.multiline = true;
		if (node.declarations.length > 1) open.push(indent$1);
		join$3.push(",", newline);
		if (node.declarations.length > 1) state.commands.push(dedent);
	} else join$3.push(", ");
};
/**
* @template {TSESTree.Node} T
* @param {Array<T | null>} nodes
* @param {State} state
* @param {boolean} spaces
* @param {(node: T, state: State) => void} fn
*/
function sequence(nodes, state, spaces, fn, separator = ",") {
	if (nodes.length === 0) return;
	const index = state.commands.length;
	const open = create_sequence();
	const join$3 = create_sequence();
	const close = create_sequence();
	state.commands.push(open);
	const child_state = {
		...state,
		multiline: false
	};
	let prev;
	for (let i$1 = 0; i$1 < nodes.length; i$1 += 1) {
		const node = nodes[i$1];
		const is_first = i$1 === 0;
		const is_last = i$1 === nodes.length - 1;
		if (node) {
			if (!is_first && !prev) state.commands.push(join$3);
			fn(node, child_state);
			if (!is_last) state.commands.push(separator);
			if (state.comments.length > 0) {
				state.commands.push(" ");
				while (state.comments.length) {
					const comment$1 = state.comments.shift();
					state.commands.push({
						type: "Comment",
						comment: comment$1
					});
					if (!is_last) state.commands.push(join$3);
				}
				child_state.multiline = true;
			} else if (!is_last) state.commands.push(join$3);
		} else state.commands.push(separator);
		prev = node;
	}
	state.commands.push(close);
	if (child_state.multiline || measure(state.commands, index) > 50) {
		state.multiline = true;
		open.push(indent$1, newline);
		join$3.push(newline);
		close.push(dedent, newline);
	} else {
		if (spaces) open.push(" ");
		join$3.push(" ");
		if (spaces) close.push(" ");
	}
}
/**
* @param {TypeAnnotationNodes} node
* @param {State} state
*/
function handle_type_annotation(node, state) {
	switch (node.type) {
		case "TSNumberKeyword":
			state.commands.push("number");
			break;
		case "TSStringKeyword":
			state.commands.push("string");
			break;
		case "TSBooleanKeyword":
			state.commands.push("boolean");
			break;
		case "TSAnyKeyword":
			state.commands.push("any");
			break;
		case "TSVoidKeyword":
			state.commands.push("void");
			break;
		case "TSUnknownKeyword":
			state.commands.push("unknown");
			break;
		case "TSNeverKeyword":
			state.commands.push("never");
			break;
		case "TSSymbolKeyword":
			state.commands.push("symbol");
			break;
		case "TSNullKeyword":
			state.commands.push("null");
			break;
		case "TSUndefinedKeyword":
			state.commands.push("undefined");
			break;
		case "TSArrayType":
			handle_type_annotation(node.elementType, state);
			state.commands.push("[]");
			break;
		case "TSTypeAnnotation":
			state.commands.push(": ");
			handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSTypeLiteral":
			state.commands.push("{ ");
			sequence(node.members, state, false, handle_type_annotation, ";");
			state.commands.push(" }");
			break;
		case "TSPropertySignature":
			handle(node.key, state);
			if (node.optional) state.commands.push("?");
			if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSTypeReference":
			handle(node.typeName, state);
			if (node.typeArguments) handle_type_annotation(node.typeArguments, state);
			break;
		case "TSTypeParameterInstantiation":
		case "TSTypeParameterDeclaration":
			state.commands.push("<");
			for (let i$1 = 0; i$1 < node.params.length; i$1++) {
				handle_type_annotation(node.params[i$1], state);
				if (i$1 != node.params.length - 1) state.commands.push(", ");
			}
			state.commands.push(">");
			break;
		case "TSTypeParameter":
			state.commands.push(node.name);
			if (node.constraint) {
				state.commands.push(" extends ");
				handle_type_annotation(node.constraint, state);
			}
			break;
		case "TSTypeQuery":
			state.commands.push("typeof ");
			handle(node.exprName, state);
			break;
		case "TSEnumMember":
			handle(node.id, state);
			if (node.initializer) {
				state.commands.push(" = ");
				handle(node.initializer, state);
			}
			break;
		case "TSFunctionType":
			if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
			const parameters = node.parameters;
			state.commands.push("(");
			sequence(parameters, state, false, handle);
			state.commands.push(") => ");
			handle_type_annotation(node.typeAnnotation.typeAnnotation, state);
			break;
		case "TSIndexSignature":
			const indexParameters = node.parameters;
			state.commands.push("[");
			sequence(indexParameters, state, false, handle);
			state.commands.push("]");
			handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSMethodSignature":
			handle(node.key, state);
			const parametersSignature = node.parameters;
			state.commands.push("(");
			sequence(parametersSignature, state, false, handle);
			state.commands.push(")");
			handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSExpressionWithTypeArguments":
			handle(node.expression, state);
			break;
		case "TSTupleType":
			state.commands.push("[");
			sequence(node.elementTypes, state, false, handle_type_annotation);
			state.commands.push("]");
			break;
		case "TSNamedTupleMember":
			handle(node.label, state);
			state.commands.push(": ");
			handle_type_annotation(node.elementType, state);
			break;
		case "TSUnionType":
			sequence(node.types, state, false, handle_type_annotation, " |");
			break;
		case "TSIntersectionType":
			sequence(node.types, state, false, handle_type_annotation, " &");
			break;
		case "TSLiteralType":
			handle(node.literal, state);
			break;
		case "TSConditionalType":
			handle_type_annotation(node.checkType, state);
			state.commands.push(" extends ");
			handle_type_annotation(node.extendsType, state);
			state.commands.push(" ? ");
			handle_type_annotation(node.trueType, state);
			state.commands.push(" : ");
			handle_type_annotation(node.falseType, state);
			break;
		case "TSIndexedAccessType":
			handle_type_annotation(node.objectType, state);
			state.commands.push("[");
			handle_type_annotation(node.indexType, state);
			state.commands.push("]");
			break;
		case "TSImportType":
			state.commands.push("import(");
			handle(node.argument, state);
			state.commands.push(")");
			if (node.qualifier) {
				state.commands.push(".");
				handle(node.qualifier, state);
			}
			break;
		default: throw new Error(`Not implemented type annotation ${node.type}`);
	}
}
/** @satisfies {Record<string, (node: any, state: State) => undefined>} */
const shared = {
	"ArrayExpression|ArrayPattern": (node, state) => {
		state.commands.push("[");
		sequence(node.elements, state, false, handle);
		state.commands.push("]");
	},
	"BinaryExpression|LogicalExpression": (node, state) => {
		if (needs_parens(node.left, node, false)) {
			state.commands.push("(");
			handle(node.left, state);
			state.commands.push(")");
		} else handle(node.left, state);
		state.commands.push(` ${node.operator} `);
		if (needs_parens(node.right, node, true)) {
			state.commands.push("(");
			handle(node.right, state);
			state.commands.push(")");
		} else handle(node.right, state);
	},
	"BlockStatement|ClassBody": (node, state) => {
		if (node.loc) {
			const { line, column } = node.loc.start;
			state.commands.push(l$1(line, column), "{", l$1(line, column + 1));
		} else state.commands.push("{");
		if (node.body.length > 0) {
			state.multiline = true;
			state.commands.push(indent$1, newline);
			handle_body(node.body, state);
			state.commands.push(dedent, newline);
		}
		if (node.loc) {
			const { line, column } = node.loc.end;
			state.commands.push(l$1(line, column - 1), "}", l$1(line, column));
		} else state.commands.push("}");
	},
	"CallExpression|NewExpression": (node, state) => {
		if (node.type === "NewExpression") state.commands.push("new ");
		if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || node.type === "NewExpression" && has_call_expression(node.callee)) {
			state.commands.push("(");
			handle(node.callee, state);
			state.commands.push(")");
		} else handle(node.callee, state);
		if (node.optional) state.commands.push("?.");
		if (node.typeArguments) handle_type_annotation(node.typeArguments, state);
		const open = create_sequence();
		const join$3 = create_sequence();
		const close = create_sequence();
		state.commands.push("(", open);
		const child_state = {
			...state,
			multiline: false
		};
		const final_state = {
			...state,
			multiline: false
		};
		for (let i$1 = 0; i$1 < node.arguments.length; i$1 += 1) {
			if (i$1 > 0) if (state.comments.length > 0) {
				state.commands.push(", ");
				while (state.comments.length) {
					const comment$1 = state.comments.shift();
					state.commands.push({
						type: "Comment",
						comment: comment$1
					});
					if (comment$1.type === "Line") {
						child_state.multiline = true;
						state.commands.push(newline);
					} else state.commands.push(" ");
				}
			} else state.commands.push(join$3);
			const p$2 = node.arguments[i$1];
			handle(p$2, i$1 === node.arguments.length - 1 ? final_state : child_state);
		}
		state.commands.push(close, ")");
		const multiline = child_state.multiline;
		if (multiline || final_state.multiline) state.multiline = true;
		if (multiline) {
			open.push(indent$1, newline);
			join$3.push(",", newline);
			close.push(dedent, newline);
		} else join$3.push(", ");
	},
	"ClassDeclaration|ClassExpression": (node, state) => {
		state.commands.push("class ");
		if (node.id) {
			handle(node.id, state);
			state.commands.push(" ");
		}
		if (node.superClass) {
			state.commands.push("extends ");
			handle(node.superClass, state);
			state.commands.push(" ");
		}
		if (node.implements) {
			state.commands.push("implements ");
			sequence(node.implements, state, false, handle_type_annotation);
		}
		handle(node.body, state);
	},
	"ForInStatement|ForOfStatement": (node, state) => {
		state.commands.push("for ");
		if (node.type === "ForOfStatement" && node.await) state.commands.push("await ");
		state.commands.push("(");
		if (node.left.type === "VariableDeclaration") handle_var_declaration(node.left, state);
		else handle(node.left, state);
		state.commands.push(node.type === "ForInStatement" ? ` in ` : ` of `);
		handle(node.right, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	"FunctionDeclaration|FunctionExpression": (node, state) => {
		if (node.async) state.commands.push("async ");
		state.commands.push(node.generator ? "function* " : "function ");
		if (node.id) handle(node.id, state);
		if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
		state.commands.push("(");
		sequence(node.params, state, false, handle);
		state.commands.push(")");
		if (node.returnType) handle_type_annotation(node.returnType, state);
		state.commands.push(" ");
		handle(node.body, state);
	},
	"RestElement|SpreadElement": (node, state) => {
		state.commands.push("...");
		handle(node.argument, state);
		if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
	}
};
/** @type {Handlers} */
const handlers = {
	ArrayExpression: shared["ArrayExpression|ArrayPattern"],
	ArrayPattern: shared["ArrayExpression|ArrayPattern"],
	ArrowFunctionExpression: (node, state) => {
		if (node.async) state.commands.push("async ");
		state.commands.push("(");
		sequence(node.params, state, false, handle);
		state.commands.push(") => ");
		if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern" || node.body.type === "LogicalExpression" && node.body.left.type === "ObjectExpression" || node.body.type === "ConditionalExpression" && node.body.test.type === "ObjectExpression") {
			state.commands.push("(");
			handle(node.body, state);
			state.commands.push(")");
		} else handle(node.body, state);
	},
	AssignmentExpression(node, state) {
		handle(node.left, state);
		state.commands.push(` ${node.operator} `);
		handle(node.right, state);
	},
	AssignmentPattern(node, state) {
		handle(node.left, state);
		state.commands.push(" = ");
		handle(node.right, state);
	},
	AwaitExpression(node, state) {
		if (node.argument) {
			const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
			if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
				state.commands.push("await (");
				handle(node.argument, state);
				state.commands.push(")");
			} else {
				state.commands.push("await ");
				handle(node.argument, state);
			}
		} else state.commands.push("await");
	},
	BinaryExpression: shared["BinaryExpression|LogicalExpression"],
	BlockStatement: shared["BlockStatement|ClassBody"],
	BreakStatement(node, state) {
		if (node.label) {
			state.commands.push("break ");
			handle(node.label, state);
			state.commands.push(";");
		} else state.commands.push("break;");
	},
	CallExpression: shared["CallExpression|NewExpression"],
	ChainExpression(node, state) {
		handle(node.expression, state);
	},
	ClassBody: shared["BlockStatement|ClassBody"],
	ClassDeclaration: shared["ClassDeclaration|ClassExpression"],
	ClassExpression: shared["ClassDeclaration|ClassExpression"],
	ConditionalExpression(node, state) {
		if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) handle(node.test, state);
		else {
			state.commands.push("(");
			handle(node.test, state);
			state.commands.push(")");
		}
		const if_true = create_sequence();
		const if_false = create_sequence();
		const child_state = {
			...state,
			multiline: false
		};
		state.commands.push(if_true);
		handle(node.consequent, child_state);
		state.commands.push(if_false);
		handle(node.alternate, child_state);
		if (child_state.multiline) {
			if_true.push(indent$1, newline, "? ");
			if_false.push(newline, ": ");
			state.commands.push(dedent);
		} else {
			if_true.push(" ? ");
			if_false.push(" : ");
		}
	},
	ContinueStatement(node, state) {
		if (node.label) {
			state.commands.push("continue ");
			handle(node.label, state);
			state.commands.push(";");
		} else state.commands.push("continue;");
	},
	DebuggerStatement(node, state) {
		state.commands.push(c("debugger", node), ";");
	},
	Decorator(node, state) {
		state.commands.push("@");
		handle(node.expression, state);
		state.commands.push(newline);
	},
	DoWhileStatement(node, state) {
		state.commands.push("do ");
		handle(node.body, state);
		state.commands.push(" while (");
		handle(node.test, state);
		state.commands.push(");");
	},
	EmptyStatement(node, state) {
		state.commands.push(";");
	},
	ExportAllDeclaration(node, state) {
		state.commands.push("export * ");
		if (node.exported) {
			state.commands.push("as ");
			handle(node.exported, state);
		}
		state.commands.push(" from ");
		handle(node.source, state);
		state.commands.push(";");
	},
	ExportDefaultDeclaration(node, state) {
		state.commands.push("export default ");
		handle(node.declaration, state);
		if (node.declaration.type !== "FunctionDeclaration") state.commands.push(";");
	},
	ExportNamedDeclaration(node, state) {
		state.commands.push("export ");
		if (node.declaration) {
			handle(node.declaration, state);
			return;
		}
		state.commands.push("{");
		sequence(node.specifiers, state, true, (s, state$1) => {
			handle(s.local, state$1);
			if (s.local.name !== s.exported.name) {
				state$1.commands.push(" as ");
				handle(s.exported, state$1);
			}
		});
		state.commands.push("}");
		if (node.source) {
			state.commands.push(" from ");
			handle(node.source, state);
		}
		state.commands.push(";");
	},
	ExpressionStatement(node, state) {
		if (node.expression.type === "ObjectExpression" || node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern" || node.expression.type === "FunctionExpression") {
			state.commands.push("(");
			handle(node.expression, state);
			state.commands.push(");");
			return;
		}
		handle(node.expression, state);
		state.commands.push(";");
	},
	ForStatement: (node, state) => {
		state.commands.push("for (");
		if (node.init) if (node.init.type === "VariableDeclaration") handle_var_declaration(node.init, state);
		else handle(node.init, state);
		state.commands.push("; ");
		if (node.test) handle(node.test, state);
		state.commands.push("; ");
		if (node.update) handle(node.update, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	ForInStatement: shared["ForInStatement|ForOfStatement"],
	ForOfStatement: shared["ForInStatement|ForOfStatement"],
	FunctionDeclaration: shared["FunctionDeclaration|FunctionExpression"],
	FunctionExpression: shared["FunctionDeclaration|FunctionExpression"],
	Identifier(node, state) {
		let name = node.name;
		state.commands.push(c(name, node));
		if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
	},
	IfStatement(node, state) {
		state.commands.push("if (");
		handle(node.test, state);
		state.commands.push(") ");
		handle(node.consequent, state);
		if (node.alternate) {
			state.commands.push(" else ");
			handle(node.alternate, state);
		}
	},
	ImportDeclaration(node, state) {
		if (node.specifiers.length === 0) {
			state.commands.push("import ");
			handle(node.source, state);
			state.commands.push(";");
			return;
		}
		/** @type {TSESTree.ImportNamespaceSpecifier | null} */
		let namespace_specifier = null;
		/** @type {TSESTree.ImportDefaultSpecifier | null} */
		let default_specifier = null;
		/** @type {TSESTree.ImportSpecifier[]} */
		const named_specifiers = [];
		for (const s of node.specifiers) if (s.type === "ImportNamespaceSpecifier") namespace_specifier = s;
		else if (s.type === "ImportDefaultSpecifier") default_specifier = s;
		else named_specifiers.push(s);
		state.commands.push("import ");
		if (node.importKind == "type") state.commands.push("type ");
		if (default_specifier) {
			state.commands.push(c(default_specifier.local.name, default_specifier));
			if (namespace_specifier || named_specifiers.length > 0) state.commands.push(", ");
		}
		if (namespace_specifier) state.commands.push(c("* as " + namespace_specifier.local.name, namespace_specifier));
		if (named_specifiers.length > 0) {
			state.commands.push("{");
			sequence(named_specifiers, state, true, (s, state$1) => {
				if (s.local.name !== s.imported.name) {
					handle(s.imported, state$1);
					state$1.commands.push(" as ");
				}
				if (s.importKind == "type") state$1.commands.push("type ");
				handle(s.local, state$1);
			});
			state.commands.push("}");
		}
		state.commands.push(" from ");
		handle(node.source, state);
		if (node.attributes && node.attributes.length > 0) {
			state.commands.push(" with { ");
			for (let index = 0; index < node.attributes.length; index++) {
				const { key, value } = node.attributes[index];
				handle(key, state);
				state.commands.push(": ");
				handle(value, state);
				if (index + 1 !== node.attributes.length) state.commands.push(", ");
			}
			state.commands.push(" }");
		}
		state.commands.push(";");
	},
	ImportExpression(node, state) {
		state.commands.push("import(");
		handle(node.source, state);
		if (node.arguments) for (let index = 0; index < node.arguments.length; index++) {
			state.commands.push(", ");
			handle(node.arguments[index], state);
		}
		state.commands.push(")");
	},
	LabeledStatement(node, state) {
		handle(node.label, state);
		state.commands.push(": ");
		handle(node.body, state);
	},
	Literal(node, state) {
		const value = node.raw || (typeof node.value === "string" ? quote(node.value, state.quote) : String(node.value));
		state.commands.push(c(value, node));
	},
	LogicalExpression: shared["BinaryExpression|LogicalExpression"],
	MemberExpression(node, state) {
		if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
			state.commands.push("(");
			handle(node.object, state);
			state.commands.push(")");
		} else handle(node.object, state);
		if (node.computed) {
			if (node.optional) state.commands.push("?.");
			state.commands.push("[");
			handle(node.property, state);
			state.commands.push("]");
		} else {
			state.commands.push(node.optional ? "?." : ".");
			handle(node.property, state);
		}
	},
	MetaProperty(node, state) {
		handle(node.meta, state);
		state.commands.push(".");
		handle(node.property, state);
	},
	MethodDefinition(node, state) {
		if (node.decorators) for (const decorator of node.decorators) handle(decorator, state);
		if (node.static) state.commands.push("static ");
		if (node.kind === "get" || node.kind === "set") state.commands.push(node.kind + " ");
		if (node.value.async) state.commands.push("async ");
		if (node.value.generator) state.commands.push("*");
		if (node.computed) state.commands.push("[");
		handle(node.key, state);
		if (node.computed) state.commands.push("]");
		state.commands.push("(");
		sequence(node.value.params, state, false, handle);
		state.commands.push(")");
		if (node.value.returnType) handle_type_annotation(node.value.returnType, state);
		state.commands.push(" ");
		if (node.value.body) handle(node.value.body, state);
	},
	NewExpression: shared["CallExpression|NewExpression"],
	ObjectExpression(node, state) {
		state.commands.push("{");
		sequence(node.properties, state, true, (p$2, state$1) => {
			if (p$2.type === "Property" && p$2.value.type === "FunctionExpression") {
				const fn = p$2.value;
				if (p$2.kind === "get" || p$2.kind === "set") state$1.commands.push(p$2.kind + " ");
				else {
					if (fn.async) state$1.commands.push("async ");
					if (fn.generator) state$1.commands.push("*");
				}
				if (p$2.computed) state$1.commands.push("[");
				handle(p$2.key, state$1);
				if (p$2.computed) state$1.commands.push("]");
				state$1.commands.push("(");
				sequence(fn.params, state$1, false, handle);
				state$1.commands.push(") ");
				handle(fn.body, state$1);
			} else handle(p$2, state$1);
		});
		state.commands.push("}");
	},
	ObjectPattern(node, state) {
		state.commands.push("{");
		sequence(node.properties, state, true, handle);
		state.commands.push("}");
		if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
	},
	ParenthesizedExpression(node, state) {
		return handle(node.expression, state);
	},
	PrivateIdentifier(node, state) {
		state.commands.push("#", c(node.name, node));
	},
	Program(node, state) {
		handle_body(node.body, state);
	},
	Property(node, state) {
		const value = node.value.type === "AssignmentPattern" ? node.value.left : node.value;
		if (!node.computed && node.kind === "init" && node.key.type === "Identifier" && value.type === "Identifier" && node.key.name === value.name) {
			handle(node.value, state);
			return;
		}
		if (node.computed) state.commands.push("[");
		handle(node.key, state);
		state.commands.push(node.computed ? "]: " : ": ");
		handle(node.value, state);
	},
	PropertyDefinition(node, state) {
		if (node.decorators) for (const decorator of node.decorators) handle(decorator, state);
		if (node.accessibility) state.commands.push(node.accessibility, " ");
		if (node.static) state.commands.push("static ");
		if (node.computed) {
			state.commands.push("[");
			handle(node.key, state);
			state.commands.push("]");
		} else handle(node.key, state);
		if (node.typeAnnotation) {
			state.commands.push(": ");
			handle_type_annotation(node.typeAnnotation.typeAnnotation, state);
		}
		if (node.value) {
			state.commands.push(" = ");
			handle(node.value, state);
		}
		state.commands.push(";");
	},
	RestElement: shared["RestElement|SpreadElement"],
	ReturnStatement(node, state) {
		if (node.argument) {
			const argumentWithComment = node.argument;
			const contains_comment = argumentWithComment.leadingComments && argumentWithComment.leadingComments.some((comment$1) => comment$1.type === "Line");
			state.commands.push(contains_comment ? "return (" : "return ");
			handle(node.argument, state);
			state.commands.push(contains_comment ? ");" : ";");
		} else state.commands.push("return;");
	},
	SequenceExpression(node, state) {
		state.commands.push("(");
		sequence(node.expressions, state, false, handle);
		state.commands.push(")");
	},
	SpreadElement: shared["RestElement|SpreadElement"],
	StaticBlock(node, state) {
		state.commands.push(indent$1, "static {", newline);
		handle_body(node.body, state);
		state.commands.push(dedent, newline, "}");
	},
	Super(node, state) {
		state.commands.push(c("super", node));
	},
	SwitchStatement(node, state) {
		state.commands.push("switch (");
		handle(node.discriminant, state);
		state.commands.push(") {", indent$1);
		let first = true;
		for (const block of node.cases) {
			if (!first) state.commands.push("\n");
			first = false;
			if (block.test) {
				state.commands.push(newline, `case `);
				handle(block.test, state);
				state.commands.push(":");
			} else state.commands.push(newline, `default:`);
			state.commands.push(indent$1);
			for (const statement of block.consequent) {
				state.commands.push(newline);
				handle(statement, state);
			}
			state.commands.push(dedent);
		}
		state.commands.push(dedent, newline, `}`);
	},
	TaggedTemplateExpression(node, state) {
		handle(node.tag, state);
		handle(node.quasi, state);
	},
	TemplateLiteral(node, state) {
		state.commands.push("`");
		const { quasis, expressions } = node;
		for (let i$1 = 0; i$1 < expressions.length; i$1++) {
			const raw$1 = quasis[i$1].value.raw;
			state.commands.push(raw$1, "${");
			handle(expressions[i$1], state);
			state.commands.push("}");
			if (/\n/.test(raw$1)) state.multiline = true;
		}
		const raw = quasis[quasis.length - 1].value.raw;
		state.commands.push(raw, "`");
		if (/\n/.test(raw)) state.multiline = true;
	},
	ThisExpression(node, state) {
		state.commands.push(c("this", node));
	},
	ThrowStatement(node, state) {
		state.commands.push("throw ");
		if (node.argument) handle(node.argument, state);
		state.commands.push(";");
	},
	TryStatement(node, state) {
		state.commands.push("try ");
		handle(node.block, state);
		if (node.handler) {
			if (node.handler.param) {
				state.commands.push(" catch(");
				handle(node.handler.param, state);
				state.commands.push(") ");
			} else state.commands.push(" catch ");
			handle(node.handler.body, state);
		}
		if (node.finalizer) {
			state.commands.push(" finally ");
			handle(node.finalizer, state);
		}
	},
	TSAsExpression(node, state) {
		if (node.expression) if (EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSAsExpression) {
			state.commands.push("(");
			handle(node.expression, state);
			state.commands.push(")");
		} else handle(node.expression, state);
		state.commands.push(" as ");
		handle_type_annotation(node.typeAnnotation, state);
	},
	TSEnumDeclaration(node, state) {
		state.commands.push("enum ");
		handle(node.id, state);
		state.commands.push(" {", indent$1, newline);
		sequence(node.members, state, false, handle_type_annotation);
		state.commands.push(dedent, newline, "}", newline);
	},
	TSModuleBlock(node, state) {
		state.commands.push(" {", indent$1, newline);
		handle_body(node.body, state);
		state.commands.push(dedent, newline, "}");
	},
	TSModuleDeclaration(node, state) {
		if (node.declare) state.commands.push("declare ");
		else state.commands.push("namespace ");
		handle(node.id, state);
		if (!node.body) return;
		handle(node.body, state);
	},
	TSNonNullExpression(node, state) {
		handle(node.expression, state);
		state.commands.push("!");
	},
	TSInterfaceBody(node, state) {
		sequence(node.body, state, true, handle_type_annotation, ";");
	},
	TSInterfaceDeclaration(node, state) {
		state.commands.push("interface ");
		handle(node.id, state);
		if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
		if (node.extends) {
			state.commands.push(" extends ");
			sequence(node.extends, state, false, handle_type_annotation);
		}
		state.commands.push(" {");
		handle(node.body, state);
		state.commands.push("}");
	},
	TSSatisfiesExpression(node, state) {
		if (node.expression) if (EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSSatisfiesExpression) {
			state.commands.push("(");
			handle(node.expression, state);
			state.commands.push(")");
		} else handle(node.expression, state);
		state.commands.push(" satisfies ");
		handle_type_annotation(node.typeAnnotation, state);
	},
	TSTypeAliasDeclaration(node, state) {
		state.commands.push("type ");
		handle(node.id, state);
		if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
		state.commands.push(" = ");
		handle_type_annotation(node.typeAnnotation, state);
		state.commands.push(";");
	},
	TSQualifiedName(node, state) {
		handle(node.left, state);
		state.commands.push(".");
		handle(node.right, state);
	},
	UnaryExpression(node, state) {
		state.commands.push(node.operator);
		if (node.operator.length > 1) state.commands.push(" ");
		if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
			state.commands.push("(");
			handle(node.argument, state);
			state.commands.push(")");
		} else handle(node.argument, state);
	},
	UpdateExpression(node, state) {
		if (node.prefix) {
			state.commands.push(node.operator);
			handle(node.argument, state);
		} else {
			handle(node.argument, state);
			state.commands.push(node.operator);
		}
	},
	VariableDeclaration(node, state) {
		handle_var_declaration(node, state);
		state.commands.push(";");
	},
	VariableDeclarator(node, state) {
		handle(node.id, state);
		if (node.init) {
			state.commands.push(" = ");
			handle(node.init, state);
		}
	},
	WhileStatement(node, state) {
		state.commands.push("while (");
		handle(node.test, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	WithStatement(node, state) {
		state.commands.push("with (");
		handle(node.object, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	YieldExpression(node, state) {
		if (node.argument) {
			state.commands.push(node.delegate ? `yield* ` : `yield `);
			handle(node.argument, state);
		} else state.commands.push(node.delegate ? `yield*` : `yield`);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i$1 = 0; i$1 < chars.length; i$1++) {
	const c$2 = chars.charCodeAt(i$1);
	intToChar[i$1] = c$2;
	charToInt[c$2] = i$1;
}
function encodeInteger(builder, num, relative$2) {
	let delta = num - relative$2;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString();
} } : { decode(buf) {
	let out = "";
	for (let i$1 = 0; i$1 < buf.length; i$1++) out += String.fromCharCode(buf[i$1]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v$2) {
		const { buffer } = this;
		buffer[this.pos++] = v$2;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
function encode(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i$1 = 0; i$1 < decoded.length; i$1++) {
		const line = decoded[i$1];
		if (i$1 > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j$2 = 0; j$2 < line.length; j$2++) {
			const segment = line[j$2];
			if (j$2 > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}

//#endregion
//#region ../../node_modules/.pnpm/esrap@1.4.9/node_modules/esrap/src/index.js
/** @type {(str: string) => string} str */
let btoa$2 = () => {
	throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") btoa$2 = (str) => window.btoa(unescape(encodeURIComponent(str)));
else if (typeof Buffer === "function") btoa$2 = (str) => Buffer.from(str, "utf-8").toString("base64");
/**
* @param {{ type: string, [key: string]: any }} node
* @param {PrintOptions} opts
* @returns {{ code: string, map: any }} // TODO
*/
function print(node, opts = {}) {
	if (Array.isArray(node)) return print({
		type: "Program",
		body: node,
		sourceType: "module"
	}, opts);
	/** @type {State} */
	const state = {
		commands: [],
		comments: [],
		multiline: false,
		quote: opts.quotes === "double" ? "\"" : "'"
	};
	handle(node, state);
	/** @typedef {[number, number, number, number]} Segment */
	let code = "";
	let current_column = 0;
	/** @type {Segment[][]} */
	let mappings = [];
	/** @type {Segment[]} */
	let current_line = [];
	/** @param {string} str */
	function append(str) {
		code += str;
		for (let i$1 = 0; i$1 < str.length; i$1 += 1) if (str[i$1] === "\n") {
			mappings.push(current_line);
			current_line = [];
			current_column = 0;
		} else current_column += 1;
	}
	let newline$1 = "\n";
	const indent$2 = opts.indent ?? "	";
	/** @param {Command} command */
	function run(command) {
		if (typeof command === "string") {
			append(command);
			return;
		}
		if (Array.isArray(command)) {
			for (let i$1 = 0; i$1 < command.length; i$1 += 1) run(command[i$1]);
			return;
		}
		switch (command.type) {
			case "Location":
				current_line.push([
					current_column,
					0,
					command.line - 1,
					command.column
				]);
				break;
			case "Newline":
				append(newline$1);
				break;
			case "Indent":
				newline$1 += indent$2;
				break;
			case "Dedent":
				newline$1 = newline$1.slice(0, -indent$2.length);
				break;
			case "Comment":
				if (command.comment.type === "Line") append(`//${command.comment.value}`);
				else append(`/*${command.comment.value.replace(/\n/g, newline$1)}*/`);
				break;
		}
	}
	for (let i$1 = 0; i$1 < state.commands.length; i$1 += 1) run(state.commands[i$1]);
	mappings.push(current_line);
	const map$6 = {
		version: 3,
		names: [],
		sources: [opts.sourceMapSource || null],
		sourcesContent: [opts.sourceMapContent || null],
		mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? encode(mappings) : mappings
	};
	Object.defineProperties(map$6, {
		toString: {
			enumerable: false,
			value: function toString$2() {
				return JSON.stringify(this);
			}
		},
		toUrl: {
			enumerable: false,
			value: function toUrl() {
				return "data:application/json;charset=utf-8;base64," + btoa$2(this.toString());
			}
		}
	});
	return {
		code,
		map: map$6
	};
}

//#endregion
//#region ../../node_modules/.pnpm/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs
var acorn_exports = /* @__PURE__ */ __export({
	Node: () => Node$3,
	Parser: () => Parser$1,
	Position: () => Position,
	SourceLocation: () => SourceLocation,
	TokContext: () => TokContext,
	Token: () => Token,
	TokenType: () => TokenType,
	defaultOptions: () => defaultOptions,
	getLineInfo: () => getLineInfo,
	isIdentifierChar: () => isIdentifierChar,
	isIdentifierStart: () => isIdentifierStart,
	isNewLine: () => isNewLine,
	keywordTypes: () => keywords,
	lineBreak: () => lineBreak,
	lineBreakG: () => lineBreakG,
	nonASCIIwhitespace: () => nonASCIIwhitespace,
	parse: () => parse$2,
	parseExpressionAt: () => parseExpressionAt,
	tokContexts: () => types,
	tokTypes: () => types$1,
	tokenizer: () => tokenizer,
	version: () => version
});
var astralIdentifierCodes = [
	509,
	0,
	227,
	0,
	150,
	4,
	294,
	9,
	1368,
	2,
	2,
	1,
	6,
	3,
	41,
	2,
	5,
	0,
	166,
	1,
	574,
	3,
	9,
	9,
	7,
	9,
	32,
	4,
	318,
	1,
	80,
	3,
	71,
	10,
	50,
	3,
	123,
	2,
	54,
	14,
	32,
	10,
	3,
	1,
	11,
	3,
	46,
	10,
	8,
	0,
	46,
	9,
	7,
	2,
	37,
	13,
	2,
	9,
	6,
	1,
	45,
	0,
	13,
	2,
	49,
	13,
	9,
	3,
	2,
	11,
	83,
	11,
	7,
	0,
	3,
	0,
	158,
	11,
	6,
	9,
	7,
	3,
	56,
	1,
	2,
	6,
	3,
	1,
	3,
	2,
	10,
	0,
	11,
	1,
	3,
	6,
	4,
	4,
	68,
	8,
	2,
	0,
	3,
	0,
	2,
	3,
	2,
	4,
	2,
	0,
	15,
	1,
	83,
	17,
	10,
	9,
	5,
	0,
	82,
	19,
	13,
	9,
	214,
	6,
	3,
	8,
	28,
	1,
	83,
	16,
	16,
	9,
	82,
	12,
	9,
	9,
	7,
	19,
	58,
	14,
	5,
	9,
	243,
	14,
	166,
	9,
	71,
	5,
	2,
	1,
	3,
	3,
	2,
	0,
	2,
	1,
	13,
	9,
	120,
	6,
	3,
	6,
	4,
	0,
	29,
	9,
	41,
	6,
	2,
	3,
	9,
	0,
	10,
	10,
	47,
	15,
	343,
	9,
	54,
	7,
	2,
	7,
	17,
	9,
	57,
	21,
	2,
	13,
	123,
	5,
	4,
	0,
	2,
	1,
	2,
	6,
	2,
	0,
	9,
	9,
	49,
	4,
	2,
	1,
	2,
	4,
	9,
	9,
	330,
	3,
	10,
	1,
	2,
	0,
	49,
	6,
	4,
	4,
	14,
	10,
	5350,
	0,
	7,
	14,
	11465,
	27,
	2343,
	9,
	87,
	9,
	39,
	4,
	60,
	6,
	26,
	9,
	535,
	9,
	470,
	0,
	2,
	54,
	8,
	3,
	82,
	0,
	12,
	1,
	19628,
	1,
	4178,
	9,
	519,
	45,
	3,
	22,
	543,
	4,
	4,
	5,
	9,
	7,
	3,
	6,
	31,
	3,
	149,
	2,
	1418,
	49,
	513,
	54,
	5,
	49,
	9,
	0,
	15,
	0,
	23,
	4,
	2,
	14,
	1361,
	6,
	2,
	16,
	3,
	6,
	2,
	1,
	2,
	4,
	101,
	0,
	161,
	6,
	10,
	9,
	357,
	0,
	62,
	13,
	499,
	13,
	245,
	1,
	2,
	9,
	726,
	6,
	110,
	6,
	6,
	9,
	4759,
	9,
	787719,
	239
];
var astralIdentifierStartCodes = [
	0,
	11,
	2,
	25,
	2,
	18,
	2,
	1,
	2,
	14,
	3,
	13,
	35,
	122,
	70,
	52,
	268,
	28,
	4,
	48,
	48,
	31,
	14,
	29,
	6,
	37,
	11,
	29,
	3,
	35,
	5,
	7,
	2,
	4,
	43,
	157,
	19,
	35,
	5,
	35,
	5,
	39,
	9,
	51,
	13,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	2,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	4,
	51,
	13,
	310,
	10,
	21,
	11,
	7,
	25,
	5,
	2,
	41,
	2,
	8,
	70,
	5,
	3,
	0,
	2,
	43,
	2,
	1,
	4,
	0,
	3,
	22,
	11,
	22,
	10,
	30,
	66,
	18,
	2,
	1,
	11,
	21,
	11,
	25,
	71,
	55,
	7,
	1,
	65,
	0,
	16,
	3,
	2,
	2,
	2,
	28,
	43,
	28,
	4,
	28,
	36,
	7,
	2,
	27,
	28,
	53,
	11,
	21,
	11,
	18,
	14,
	17,
	111,
	72,
	56,
	50,
	14,
	50,
	14,
	35,
	39,
	27,
	10,
	22,
	251,
	41,
	7,
	1,
	17,
	2,
	60,
	28,
	11,
	0,
	9,
	21,
	43,
	17,
	47,
	20,
	28,
	22,
	13,
	52,
	58,
	1,
	3,
	0,
	14,
	44,
	33,
	24,
	27,
	35,
	30,
	0,
	3,
	0,
	9,
	34,
	4,
	0,
	13,
	47,
	15,
	3,
	22,
	0,
	2,
	0,
	36,
	17,
	2,
	24,
	20,
	1,
	64,
	6,
	2,
	0,
	2,
	3,
	2,
	14,
	2,
	9,
	8,
	46,
	39,
	7,
	3,
	1,
	3,
	21,
	2,
	6,
	2,
	1,
	2,
	4,
	4,
	0,
	19,
	0,
	13,
	4,
	31,
	9,
	2,
	0,
	3,
	0,
	2,
	37,
	2,
	0,
	26,
	0,
	2,
	0,
	45,
	52,
	19,
	3,
	21,
	2,
	31,
	47,
	21,
	1,
	2,
	0,
	185,
	46,
	42,
	3,
	37,
	47,
	21,
	0,
	60,
	42,
	14,
	0,
	72,
	26,
	38,
	6,
	186,
	43,
	117,
	63,
	32,
	7,
	3,
	0,
	3,
	7,
	2,
	1,
	2,
	23,
	16,
	0,
	2,
	0,
	95,
	7,
	3,
	38,
	17,
	0,
	2,
	0,
	29,
	0,
	11,
	39,
	8,
	0,
	22,
	0,
	12,
	45,
	20,
	0,
	19,
	72,
	200,
	32,
	32,
	8,
	2,
	36,
	18,
	0,
	50,
	29,
	113,
	6,
	2,
	1,
	2,
	37,
	22,
	0,
	26,
	5,
	2,
	1,
	2,
	31,
	15,
	0,
	328,
	18,
	16,
	0,
	2,
	12,
	2,
	33,
	125,
	0,
	80,
	921,
	103,
	110,
	18,
	195,
	2637,
	96,
	16,
	1071,
	18,
	5,
	26,
	3994,
	6,
	582,
	6842,
	29,
	1763,
	568,
	8,
	30,
	18,
	78,
	18,
	29,
	19,
	47,
	17,
	3,
	32,
	20,
	6,
	18,
	433,
	44,
	212,
	63,
	129,
	74,
	6,
	0,
	67,
	12,
	65,
	1,
	2,
	0,
	29,
	6135,
	9,
	1237,
	42,
	9,
	8936,
	3,
	2,
	6,
	2,
	1,
	2,
	290,
	16,
	0,
	30,
	2,
	3,
	0,
	15,
	3,
	9,
	395,
	2309,
	106,
	6,
	12,
	4,
	8,
	8,
	9,
	5991,
	84,
	2,
	70,
	2,
	1,
	3,
	0,
	3,
	1,
	3,
	3,
	2,
	11,
	2,
	0,
	2,
	6,
	2,
	64,
	2,
	3,
	3,
	7,
	2,
	6,
	2,
	27,
	2,
	3,
	2,
	4,
	2,
	0,
	4,
	6,
	2,
	339,
	3,
	24,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	7,
	1845,
	30,
	7,
	5,
	262,
	61,
	147,
	44,
	11,
	6,
	17,
	0,
	322,
	29,
	19,
	43,
	485,
	27,
	229,
	29,
	3,
	0,
	496,
	6,
	2,
	3,
	2,
	1,
	2,
	14,
	2,
	196,
	60,
	67,
	8,
	0,
	1205,
	3,
	2,
	26,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	9,
	2,
	3,
	2,
	0,
	2,
	0,
	7,
	0,
	5,
	0,
	2,
	0,
	2,
	0,
	2,
	2,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	1,
	2,
	0,
	3,
	3,
	2,
	6,
	2,
	3,
	2,
	3,
	2,
	0,
	2,
	9,
	2,
	16,
	6,
	2,
	2,
	4,
	2,
	16,
	4421,
	42719,
	33,
	4153,
	7,
	221,
	3,
	5761,
	15,
	7472,
	16,
	621,
	2467,
	541,
	1507,
	4938,
	6,
	4191
];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
	3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	5: "class enum extends super const export import",
	6: "enum",
	strict: "implements interface let package private protected public static yield",
	strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
	5: ecma5AndLessKeywords,
	"5module": ecma5AndLessKeywords + " export import",
	6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set$3) {
	var pos = 65536;
	for (var i$1 = 0; i$1 < set$3.length; i$1 += 2) {
		pos += set$3[i$1];
		if (pos > code) return false;
		pos += set$3[i$1 + 1];
		if (pos >= code) return true;
	}
	return false;
}
function isIdentifierStart(code, astral) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType$1(label, conf) {
	if (conf === void 0) conf = {};
	this.label = label;
	this.keyword = conf.keyword;
	this.beforeExpr = !!conf.beforeExpr;
	this.startsExpr = !!conf.startsExpr;
	this.isLoop = !!conf.isLoop;
	this.isAssign = !!conf.isAssign;
	this.prefix = !!conf.prefix;
	this.postfix = !!conf.postfix;
	this.binop = conf.binop || null;
	this.updateContext = null;
};
function binop(name, prec) {
	return new TokenType(name, {
		beforeExpr: true,
		binop: prec
	});
}
var beforeExpr = { beforeExpr: true }, startsExpr$1 = { startsExpr: true };
var keywords = {};
function kw(name, options) {
	if (options === void 0) options = {};
	options.keyword = name;
	return keywords[name] = new TokenType(name, options);
}
var types$1 = {
	num: new TokenType("num", startsExpr$1),
	regexp: new TokenType("regexp", startsExpr$1),
	string: new TokenType("string", startsExpr$1),
	name: new TokenType("name", startsExpr$1),
	privateId: new TokenType("privateId", startsExpr$1),
	eof: new TokenType("eof"),
	bracketL: new TokenType("[", {
		beforeExpr: true,
		startsExpr: true
	}),
	bracketR: new TokenType("]"),
	braceL: new TokenType("{", {
		beforeExpr: true,
		startsExpr: true
	}),
	braceR: new TokenType("}"),
	parenL: new TokenType("(", {
		beforeExpr: true,
		startsExpr: true
	}),
	parenR: new TokenType(")"),
	comma: new TokenType(",", beforeExpr),
	semi: new TokenType(";", beforeExpr),
	colon: new TokenType(":", beforeExpr),
	dot: new TokenType("."),
	question: new TokenType("?", beforeExpr),
	questionDot: new TokenType("?."),
	arrow: new TokenType("=>", beforeExpr),
	template: new TokenType("template"),
	invalidTemplate: new TokenType("invalidTemplate"),
	ellipsis: new TokenType("...", beforeExpr),
	backQuote: new TokenType("`", startsExpr$1),
	dollarBraceL: new TokenType("${", {
		beforeExpr: true,
		startsExpr: true
	}),
	eq: new TokenType("=", {
		beforeExpr: true,
		isAssign: true
	}),
	assign: new TokenType("_=", {
		beforeExpr: true,
		isAssign: true
	}),
	incDec: new TokenType("++/--", {
		prefix: true,
		postfix: true,
		startsExpr: true
	}),
	prefix: new TokenType("!/~", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	logicalOR: binop("||", 1),
	logicalAND: binop("&&", 2),
	bitwiseOR: binop("|", 3),
	bitwiseXOR: binop("^", 4),
	bitwiseAND: binop("&", 5),
	equality: binop("==/!=/===/!==", 6),
	relational: binop("</>/<=/>=", 7),
	bitShift: binop("<</>>/>>>", 8),
	plusMin: new TokenType("+/-", {
		beforeExpr: true,
		binop: 9,
		prefix: true,
		startsExpr: true
	}),
	modulo: binop("%", 10),
	star: binop("*", 10),
	slash: binop("/", 10),
	starstar: new TokenType("**", { beforeExpr: true }),
	coalesce: binop("??", 1),
	_break: kw("break"),
	_case: kw("case", beforeExpr),
	_catch: kw("catch"),
	_continue: kw("continue"),
	_debugger: kw("debugger"),
	_default: kw("default", beforeExpr),
	_do: kw("do", {
		isLoop: true,
		beforeExpr: true
	}),
	_else: kw("else", beforeExpr),
	_finally: kw("finally"),
	_for: kw("for", { isLoop: true }),
	_function: kw("function", startsExpr$1),
	_if: kw("if"),
	_return: kw("return", beforeExpr),
	_switch: kw("switch"),
	_throw: kw("throw", beforeExpr),
	_try: kw("try"),
	_var: kw("var"),
	_const: kw("const"),
	_while: kw("while", { isLoop: true }),
	_with: kw("with"),
	_new: kw("new", {
		beforeExpr: true,
		startsExpr: true
	}),
	_this: kw("this", startsExpr$1),
	_super: kw("super", startsExpr$1),
	_class: kw("class", startsExpr$1),
	_extends: kw("extends", beforeExpr),
	_export: kw("export"),
	_import: kw("import", startsExpr$1),
	_null: kw("null", startsExpr$1),
	_true: kw("true", startsExpr$1),
	_false: kw("false", startsExpr$1),
	_in: kw("in", {
		beforeExpr: true,
		binop: 7
	}),
	_instanceof: kw("instanceof", {
		beforeExpr: true,
		binop: 7
	}),
	_typeof: kw("typeof", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_void: kw("void", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_delete: kw("delete", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	})
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
	return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from$1, end) {
	if (end === void 0) end = code.length;
	for (var i$1 = from$1; i$1 < end; i$1++) {
		var next = code.charCodeAt(i$1);
		if (isNewLine(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
	}
	return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
	return hasOwnProperty.call(obj, propName);
});
var isArray = Array.isArray || (function(obj) {
	return toString$1.call(obj) === "[object Array]";
});
var regexpCache = Object.create(null);
function wordsRegexp(words) {
	return regexpCache[words] || (regexpCache[words] = /* @__PURE__ */ new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
	if (code <= 65535) return String.fromCharCode(code);
	code -= 65536;
	return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position$1(line, col) {
	this.line = line;
	this.column = col;
};
Position.prototype.offset = function offset(n$1) {
	return new Position(this.line, this.column + n$1);
};
var SourceLocation = function SourceLocation$1(p$2, start, end) {
	this.start = start;
	this.end = end;
	if (p$2.sourceFile !== null) this.source = p$2.sourceFile;
};
function getLineInfo(input, offset) {
	for (var line = 1, cur = 0;;) {
		var nextBreak = nextLineBreak(input, cur, offset);
		if (nextBreak < 0) return new Position(line, offset - cur);
		++line;
		cur = nextBreak;
	}
}
var defaultOptions = {
	ecmaVersion: null,
	sourceType: "script",
	onInsertedSemicolon: null,
	onTrailingComma: null,
	allowReserved: null,
	allowReturnOutsideFunction: false,
	allowImportExportEverywhere: false,
	allowAwaitOutsideFunction: null,
	allowSuperOutsideMethod: null,
	allowHashBang: false,
	checkPrivateFields: true,
	locations: false,
	onToken: null,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null,
	preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
	var options = {};
	for (var opt in defaultOptions) options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
	if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
	else if (options.ecmaVersion == null) {
		if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
			warnedAboutEcmaVersion = true;
			console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		}
		options.ecmaVersion = 11;
	} else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
	if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
	if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
	if (isArray(options.onToken)) {
		var tokens = options.onToken;
		options.onToken = function(token) {
			return tokens.push(token);
		};
	}
	if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
	return options;
}
function pushComment(options, array) {
	return function(block, text, start, end, startLoc, endLoc) {
		var comment$1 = {
			type: block ? "Block" : "Line",
			value: text,
			start,
			end
		};
		if (options.locations) comment$1.loc = new SourceLocation(this, startLoc, endLoc);
		if (options.ranges) comment$1.range = [start, end];
		array.push(comment$1);
	};
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags$1(async, generator) {
	return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser$1 = function Parser$5(options, input, startPos) {
	this.options = options = getOptions(options);
	this.sourceFile = options.sourceFile;
	this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
	var reserved = "";
	if (options.allowReserved !== true) {
		reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		if (options.sourceType === "module") reserved += " await";
	}
	this.reservedWords = wordsRegexp(reserved);
	var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	this.reservedWordsStrict = wordsRegexp(reservedStrict);
	this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
	this.input = String(input);
	this.containsEsc = false;
	if (startPos) {
		this.pos = startPos;
		this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	} else {
		this.pos = this.lineStart = 0;
		this.curLine = 1;
	}
	this.type = types$1.eof;
	this.value = null;
	this.start = this.end = this.pos;
	this.startLoc = this.endLoc = this.curPosition();
	this.lastTokEndLoc = this.lastTokStartLoc = null;
	this.lastTokStart = this.lastTokEnd = this.pos;
	this.context = this.initialContext();
	this.exprAllowed = true;
	this.inModule = options.sourceType === "module";
	this.strict = this.inModule || this.strictDirective(this.pos);
	this.potentialArrowAt = -1;
	this.potentialArrowInForAwait = false;
	this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
	this.labels = [];
	this.undefinedExports = Object.create(null);
	if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	this.scopeStack = [];
	this.enterScope(SCOPE_TOP);
	this.regexpState = null;
	this.privateNameStack = [];
};
var prototypeAccessors = {
	inFunction: { configurable: true },
	inGenerator: { configurable: true },
	inAsync: { configurable: true },
	canAwait: { configurable: true },
	allowSuper: { configurable: true },
	allowDirectSuper: { configurable: true },
	treatFunctionsAsVar: { configurable: true },
	allowNewDotTarget: { configurable: true },
	inClassStaticBlock: { configurable: true }
};
Parser$1.prototype.parse = function parse$8() {
	var node = this.options.program || this.startNode();
	this.nextToken();
	return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
	return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
	return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
	return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
	for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
		var flags = this.scopeStack[i$1].flags;
		if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) return false;
		if (flags & SCOPE_FUNCTION) return (flags & SCOPE_ASYNC) > 0;
	}
	return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
	return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
	for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
		var flags = this.scopeStack[i$1].flags;
		if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) return true;
	}
	return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
	return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser$1.extend = function extend() {
	var plugins = [], len = arguments.length;
	while (len--) plugins[len] = arguments[len];
	var cls = this;
	for (var i$1 = 0; i$1 < plugins.length; i$1++) cls = plugins[i$1](cls);
	return cls;
};
Parser$1.parse = function parse$8(input, options) {
	return new this(options, input).parse();
};
Parser$1.parseExpressionAt = function parseExpressionAt$1(input, pos, options) {
	var parser$2 = new this(options, input, pos);
	parser$2.nextToken();
	return parser$2.parseExpression();
};
Parser$1.tokenizer = function tokenizer$3(input, options) {
	return new this(options, input);
};
Object.defineProperties(Parser$1.prototype, prototypeAccessors);
var pp$9 = Parser$1.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
	if (this.options.ecmaVersion < 5) return false;
	for (;;) {
		skipWhiteSpace$1.lastIndex = start;
		start += skipWhiteSpace$1.exec(this.input)[0].length;
		var match = literal.exec(this.input.slice(start));
		if (!match) return false;
		if ((match[1] || match[2]) === "use strict") {
			skipWhiteSpace$1.lastIndex = start + match[0].length;
			var spaceAfter = skipWhiteSpace$1.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
			var next = this.input.charAt(end);
			return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
		}
		start += match[0].length;
		skipWhiteSpace$1.lastIndex = start;
		start += skipWhiteSpace$1.exec(this.input)[0].length;
		if (this.input[start] === ";") start++;
	}
};
pp$9.eat = function(type) {
	if (this.type === type) {
		this.next();
		return true;
	} else return false;
};
pp$9.isContextual = function(name) {
	return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
	if (!this.isContextual(name)) return false;
	this.next();
	return true;
};
pp$9.expectContextual = function(name) {
	if (!this.eatContextual(name)) this.unexpected();
};
pp$9.canInsertSemicolon = function() {
	return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
	if (this.canInsertSemicolon()) {
		if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
		return true;
	}
};
pp$9.semicolon = function() {
	if (!this.eat(types$1.semi) && !this.insertSemicolon()) this.unexpected();
};
pp$9.afterTrailingComma = function(tokType, notNext) {
	if (this.type === tokType) {
		if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
		if (!notNext) this.next();
		return true;
	}
};
pp$9.expect = function(type) {
	this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
	this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors$1 = function DestructuringErrors$2() {
	this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	if (!refDestructuringErrors) return;
	if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
	var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	if (!refDestructuringErrors) return false;
	var shorthandAssign = refDestructuringErrors.shorthandAssign;
	var doubleProto = refDestructuringErrors.doubleProto;
	if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
	if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
	if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp$9.checkYieldAwaitInDefaultParams = function() {
	if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
	if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp$9.isSimpleAssignTarget = function(expr) {
	if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
	return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser$1.prototype;
pp$8.parseTopLevel = function(node) {
	var exports$1 = Object.create(null);
	if (!node.body) node.body = [];
	while (this.type !== types$1.eof) {
		var stmt = this.parseStatement(null, true, exports$1);
		node.body.push(stmt);
	}
	if (this.inModule) for (var i$1 = 0, list$5 = Object.keys(this.undefinedExports); i$1 < list$5.length; i$1 += 1) {
		var name = list$5[i$1];
		this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
	}
	this.adaptDirectivePrologue(node.body);
	this.next();
	node.sourceType = this.options.sourceType;
	return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
	if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
	skipWhiteSpace$1.lastIndex = this.pos;
	var skip = skipWhiteSpace$1.exec(this.input);
	var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	if (nextCh === 91 || nextCh === 92) return true;
	if (context) return false;
	if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) return true;
	if (isIdentifierStart(nextCh, true)) {
		var pos = next + 1;
		while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) ++pos;
		if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) return true;
		var ident = this.input.slice(next, pos);
		if (!keywordRelationalOperator.test(ident)) return true;
	}
	return false;
};
pp$8.isAsyncFunction = function() {
	if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
	skipWhiteSpace$1.lastIndex = this.pos;
	var skip = skipWhiteSpace$1.exec(this.input);
	var next = this.pos + skip[0].length, after;
	return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
	if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) return false;
	skipWhiteSpace$1.lastIndex = this.pos;
	var skip = skipWhiteSpace$1.exec(this.input);
	var next = this.pos + skip[0].length;
	if (lineBreak.test(this.input.slice(this.pos, next))) return false;
	if (isAwaitUsing) {
		var awaitEndPos = next + 5, after;
		if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) return false;
		skipWhiteSpace$1.lastIndex = awaitEndPos;
		var skipAfterUsing = skipWhiteSpace$1.exec(this.input);
		if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) return false;
	}
	if (isFor) {
		var ofEndPos = next + 2, after$1;
		if (this.input.slice(next, ofEndPos) === "of") {
			if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) return false;
		}
	}
	var ch = this.input.charCodeAt(next);
	return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
	return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
	return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports$1) {
	var starttype = this.type, node = this.startNode(), kind;
	if (this.isLet(context)) {
		starttype = types$1._var;
		kind = "let";
	}
	switch (starttype) {
		case types$1._break:
		case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword);
		case types$1._debugger: return this.parseDebuggerStatement(node);
		case types$1._do: return this.parseDoStatement(node);
		case types$1._for: return this.parseForStatement(node);
		case types$1._function:
			if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
			return this.parseFunctionStatement(node, false, !context);
		case types$1._class:
			if (context) this.unexpected();
			return this.parseClass(node, true);
		case types$1._if: return this.parseIfStatement(node);
		case types$1._return: return this.parseReturnStatement(node);
		case types$1._switch: return this.parseSwitchStatement(node);
		case types$1._throw: return this.parseThrowStatement(node);
		case types$1._try: return this.parseTryStatement(node);
		case types$1._const:
		case types$1._var:
			kind = kind || this.value;
			if (context && kind !== "var") this.unexpected();
			return this.parseVarStatement(node, kind);
		case types$1._while: return this.parseWhileStatement(node);
		case types$1._with: return this.parseWithStatement(node);
		case types$1.braceL: return this.parseBlock(true, node);
		case types$1.semi: return this.parseEmptyStatement(node);
		case types$1._export:
		case types$1._import:
			if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
				skipWhiteSpace$1.lastIndex = this.pos;
				var skip = skipWhiteSpace$1.exec(this.input);
				var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
				if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
			}
			if (!this.options.allowImportExportEverywhere) {
				if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
				if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
			}
			return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports$1);
		default:
			if (this.isAsyncFunction()) {
				if (context) this.unexpected();
				this.next();
				return this.parseFunctionStatement(node, true, !context);
			}
			var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
			if (usingKind) {
				if (topLevel && this.options.sourceType === "script") this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
				if (usingKind === "await using") {
					if (!this.canAwait) this.raise(this.start, "Await using cannot appear outside of async function");
					this.next();
				}
				this.next();
				this.parseVar(node, false, usingKind);
				this.semicolon();
				return this.finishNode(node, "VariableDeclaration");
			}
			var maybeName = this.value, expr = this.parseExpression();
			if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
			else return this.parseExpressionStatement(node, expr);
	}
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
	var isBreak = keyword === "break";
	this.next();
	if (this.eat(types$1.semi) || this.insertSemicolon()) node.label = null;
	else if (this.type !== types$1.name) this.unexpected();
	else {
		node.label = this.parseIdent();
		this.semicolon();
	}
	var i$1 = 0;
	for (; i$1 < this.labels.length; ++i$1) {
		var lab = this.labels[i$1];
		if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
			if (node.label && isBreak) break;
		}
	}
	if (i$1 === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
	this.next();
	this.semicolon();
	return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
	this.next();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("do");
	this.labels.pop();
	this.expect(types$1._while);
	node.test = this.parseParenExpression();
	if (this.options.ecmaVersion >= 6) this.eat(types$1.semi);
	else this.semicolon();
	return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
	this.next();
	var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
	this.labels.push(loopLabel);
	this.enterScope(0);
	this.expect(types$1.parenL);
	if (this.type === types$1.semi) {
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, null);
	}
	var isLet = this.isLet();
	if (this.type === types$1._var || this.type === types$1._const || isLet) {
		var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		this.next();
		this.parseVar(init$1, true, kind);
		this.finishNode(init$1, "VariableDeclaration");
		return this.parseForAfterInit(node, init$1, awaitAt);
	}
	var startsWithLet = this.isContextual("let"), isForOf = false;
	var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
	if (usingKind) {
		var init$2 = this.startNode();
		this.next();
		if (usingKind === "await using") this.next();
		this.parseVar(init$2, true, usingKind);
		this.finishNode(init$2, "VariableDeclaration");
		return this.parseForAfterInit(node, init$2, awaitAt);
	}
	var containsEsc = this.containsEsc;
	var refDestructuringErrors = new DestructuringErrors$1();
	var initPos = this.start;
	var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
	if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		if (awaitAt > -1) {
			if (this.type === types$1._in) this.unexpected(awaitAt);
			node.await = true;
		} else if (isForOf && this.options.ecmaVersion >= 8) {
			if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") this.unexpected();
			else if (this.options.ecmaVersion >= 9) node.await = false;
		}
		if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
		this.toAssignable(init, false, refDestructuringErrors);
		this.checkLValPattern(init);
		return this.parseForIn(node, init);
	} else this.checkExpressionErrors(refDestructuringErrors, true);
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
	if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
		if (this.options.ecmaVersion >= 9) if (this.type === types$1._in) {
			if (awaitAt > -1) this.unexpected(awaitAt);
		} else node.await = awaitAt > -1;
		return this.parseForIn(node, init);
	}
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
	this.next();
	return this.parseFunction(node, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT$1), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	node.consequent = this.parseStatement("if");
	node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
	return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
	if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	this.next();
	if (this.eat(types$1.semi) || this.insertSemicolon()) node.argument = null;
	else {
		node.argument = this.parseExpression();
		this.semicolon();
	}
	return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
	this.next();
	node.discriminant = this.parseParenExpression();
	node.cases = [];
	this.expect(types$1.braceL);
	this.labels.push(switchLabel);
	this.enterScope(0);
	var cur;
	for (var sawDefault = false; this.type !== types$1.braceR;) if (this.type === types$1._case || this.type === types$1._default) {
		var isCase = this.type === types$1._case;
		if (cur) this.finishNode(cur, "SwitchCase");
		node.cases.push(cur = this.startNode());
		cur.consequent = [];
		this.next();
		if (isCase) cur.test = this.parseExpression();
		else {
			if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
			sawDefault = true;
			cur.test = null;
		}
		this.expect(types$1.colon);
	} else {
		if (!cur) this.unexpected();
		cur.consequent.push(this.parseStatement(null));
	}
	this.exitScope();
	if (cur) this.finishNode(cur, "SwitchCase");
	this.next();
	this.labels.pop();
	return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
	this.next();
	if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	node.argument = this.parseExpression();
	this.semicolon();
	return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
	var param = this.parseBindingAtom();
	var simple = param.type === "Identifier";
	this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
	this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
	this.expect(types$1.parenR);
	return param;
};
pp$8.parseTryStatement = function(node) {
	this.next();
	node.block = this.parseBlock();
	node.handler = null;
	if (this.type === types$1._catch) {
		var clause = this.startNode();
		this.next();
		if (this.eat(types$1.parenL)) clause.param = this.parseCatchClauseParam();
		else {
			if (this.options.ecmaVersion < 10) this.unexpected();
			clause.param = null;
			this.enterScope(0);
		}
		clause.body = this.parseBlock(false);
		this.exitScope();
		node.handler = this.finishNode(clause, "CatchClause");
	}
	node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
	if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
	this.next();
	this.parseVar(node, false, kind, allowMissingInitializer);
	this.semicolon();
	return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("while");
	this.labels.pop();
	return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
	if (this.strict) this.raise(this.start, "'with' in strict mode");
	this.next();
	node.object = this.parseParenExpression();
	node.body = this.parseStatement("with");
	return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
	this.next();
	return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
	for (var i$1 = 0, list$5 = this.labels; i$1 < list$5.length; i$1 += 1) if (list$5[i$1].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
	for (var i$2 = this.labels.length - 1; i$2 >= 0; i$2--) {
		var label$1 = this.labels[i$2];
		if (label$1.statementStart === node.start) {
			label$1.statementStart = this.start;
			label$1.kind = kind;
		} else break;
	}
	this.labels.push({
		name: maybeName,
		kind,
		statementStart: this.start
	});
	node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	this.labels.pop();
	node.label = expr;
	return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
	node.expression = expr;
	this.semicolon();
	return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
	if (createNewLexicalScope === void 0) createNewLexicalScope = true;
	if (node === void 0) node = this.startNode();
	node.body = [];
	this.expect(types$1.braceL);
	if (createNewLexicalScope) this.enterScope(0);
	while (this.type !== types$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	if (exitStrict) this.strict = false;
	this.next();
	if (createNewLexicalScope) this.exitScope();
	return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
	node.init = init;
	this.expect(types$1.semi);
	node.test = this.type === types$1.semi ? null : this.parseExpression();
	this.expect(types$1.semi);
	node.update = this.type === types$1.parenR ? null : this.parseExpression();
	this.expect(types$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
	var isForIn = this.type === types$1._in;
	this.next();
	if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
	node.left = init;
	node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
	this.expect(types$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
	node.declarations = [];
	node.kind = kind;
	for (;;) {
		var decl$1 = this.startNode();
		this.parseVarId(decl$1, kind);
		if (this.eat(types$1.eq)) decl$1.init = this.parseMaybeAssign(isFor);
		else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
		else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
		else if (!allowMissingInitializer && decl$1.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		else decl$1.init = null;
		node.declarations.push(this.finishNode(decl$1, "VariableDeclarator"));
		if (!this.eat(types$1.comma)) break;
	}
	return node;
};
pp$8.parseVarId = function(decl$1, kind) {
	decl$1.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
	this.checkLValPattern(decl$1.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT$1 = 1, FUNC_HANGING_STATEMENT$1 = 2, FUNC_NULLABLE_ID$1 = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
	this.initFunction(node);
	if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
		if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT$1) this.unexpected();
		node.generator = this.eat(types$1.star);
	}
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	if (statement & FUNC_STATEMENT$1) {
		node.id = statement & FUNC_NULLABLE_ID$1 && this.type !== types$1.name ? null : this.parseIdent();
		if (node.id && !(statement & FUNC_HANGING_STATEMENT$1)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
	}
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags$1(node.async, node.generator));
	if (!(statement & FUNC_STATEMENT$1)) node.id = this.type === types$1.name ? this.parseIdent() : null;
	this.parseFunctionParams(node);
	this.parseFunctionBody(node, allowExpressionBody, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, statement & FUNC_STATEMENT$1 ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
	this.expect(types$1.parenL);
	node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
	this.next();
	var oldStrict = this.strict;
	this.strict = true;
	this.parseClassId(node, isStatement);
	this.parseClassSuper(node);
	var privateNameMap = this.enterClassBody();
	var classBody = this.startNode();
	var hadConstructor = false;
	classBody.body = [];
	this.expect(types$1.braceL);
	while (this.type !== types$1.braceR) {
		var element = this.parseClassElement(node.superClass !== null);
		if (element) {
			classBody.body.push(element);
			if (element.type === "MethodDefinition" && element.kind === "constructor") {
				if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
				hadConstructor = true;
			} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted$1(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
		}
	}
	this.strict = oldStrict;
	this.next();
	node.body = this.finishNode(classBody, "ClassBody");
	this.exitClassBody();
	return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
	if (this.eat(types$1.semi)) return null;
	var ecmaVersion$1 = this.options.ecmaVersion;
	var node = this.startNode();
	var keyName = "";
	var isGenerator = false;
	var isAsync = false;
	var kind = "method";
	var isStatic = false;
	if (this.eatContextual("static")) {
		if (ecmaVersion$1 >= 13 && this.eat(types$1.braceL)) {
			this.parseClassStaticBlock(node);
			return node;
		}
		if (this.isClassElementNameStart() || this.type === types$1.star) isStatic = true;
		else keyName = "static";
	}
	node.static = isStatic;
	if (!keyName && ecmaVersion$1 >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) isAsync = true;
	else keyName = "async";
	if (!keyName && (ecmaVersion$1 >= 9 || !isAsync) && this.eat(types$1.star)) isGenerator = true;
	if (!keyName && !isAsync && !isGenerator) {
		var lastValue = this.value;
		if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
		else keyName = lastValue;
	}
	if (keyName) {
		node.computed = false;
		node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		node.key.name = keyName;
		this.finishNode(node.key, "Identifier");
	} else this.parseClassElementName(node);
	if (ecmaVersion$1 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
		var isConstructor = !node.static && checkKeyName$1(node, "constructor");
		var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
		node.kind = isConstructor ? "constructor" : kind;
		this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
	} else this.parseClassField(node);
	return node;
};
pp$8.isClassElementNameStart = function() {
	return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
	if (this.type === types$1.privateId) {
		if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
		element.computed = false;
		element.key = this.parsePrivateIdent();
	} else this.parsePropertyName(element);
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
	var key = method.key;
	if (method.kind === "constructor") {
		if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
		if (isAsync) this.raise(key.start, "Constructor can't be an async method");
	} else if (method.static && checkKeyName$1(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
	var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
	if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
	if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
	if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
	return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
	if (checkKeyName$1(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
	else if (field.static && checkKeyName$1(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
	if (this.eat(types$1.eq)) {
		this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
		field.value = this.parseMaybeAssign();
		this.exitScope();
	} else field.value = null;
	this.semicolon();
	return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
	node.body = [];
	var oldLabels = this.labels;
	this.labels = [];
	this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
	while (this.type !== types$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	this.next();
	this.exitScope();
	this.labels = oldLabels;
	return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
	if (this.type === types$1.name) {
		node.id = this.parseIdent();
		if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
	} else {
		if (isStatement === true) this.unexpected();
		node.id = null;
	}
};
pp$8.parseClassSuper = function(node) {
	node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
	var element = {
		declared: Object.create(null),
		used: []
	};
	this.privateNameStack.push(element);
	return element.declared;
};
pp$8.exitClassBody = function() {
	var ref$1 = this.privateNameStack.pop();
	var declared = ref$1.declared;
	var used = ref$1.used;
	if (!this.options.checkPrivateFields) return;
	var len = this.privateNameStack.length;
	var parent = len === 0 ? null : this.privateNameStack[len - 1];
	for (var i$1 = 0; i$1 < used.length; ++i$1) {
		var id = used[i$1];
		if (!hasOwn(declared, id.name)) if (parent) parent.used.push(id);
		else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
	}
};
function isPrivateNameConflicted$1(privateNameMap, element) {
	var name = element.key.name;
	var curr = privateNameMap[name];
	var next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName$1(node, name) {
	var computed = node.computed;
	var key = node.key;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports$1) {
	if (this.options.ecmaVersion >= 11) if (this.eatContextual("as")) {
		node.exported = this.parseModuleExportName();
		this.checkExport(exports$1, node.exported, this.lastTokStart);
	} else node.exported = null;
	this.expectContextual("from");
	if (this.type !== types$1.string) this.unexpected();
	node.source = this.parseExprAtom();
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports$1) {
	this.next();
	if (this.eat(types$1.star)) return this.parseExportAllDeclaration(node, exports$1);
	if (this.eat(types$1._default)) {
		this.checkExport(exports$1, "default", this.lastTokStart);
		node.declaration = this.parseExportDefaultDeclaration();
		return this.finishNode(node, "ExportDefaultDeclaration");
	}
	if (this.shouldParseExportStatement()) {
		node.declaration = this.parseExportDeclaration(node);
		if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports$1, node.declaration.declarations);
		else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
		node.specifiers = [];
		node.source = null;
		if (this.options.ecmaVersion >= 16) node.attributes = [];
	} else {
		node.declaration = null;
		node.specifiers = this.parseExportSpecifiers(exports$1);
		if (this.eatContextual("from")) {
			if (this.type !== types$1.string) this.unexpected();
			node.source = this.parseExprAtom();
			if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		} else {
			for (var i$1 = 0, list$5 = node.specifiers; i$1 < list$5.length; i$1 += 1) {
				var spec = list$5[i$1];
				this.checkUnreserved(spec.local);
				this.checkLocalExport(spec.local);
				if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
			}
			node.source = null;
			if (this.options.ecmaVersion >= 16) node.attributes = [];
		}
		this.semicolon();
	}
	return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
	return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
	var isAsync;
	if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
		var fNode = this.startNode();
		this.next();
		if (isAsync) this.next();
		return this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync);
	} else if (this.type === types$1._class) {
		var cNode = this.startNode();
		return this.parseClass(cNode, "nullableID");
	} else {
		var declaration = this.parseMaybeAssign();
		this.semicolon();
		return declaration;
	}
};
pp$8.checkExport = function(exports$1, name, pos) {
	if (!exports$1) return;
	if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
	if (hasOwn(exports$1, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
	exports$1[name] = true;
};
pp$8.checkPatternExport = function(exports$1, pat) {
	var type = pat.type;
	if (type === "Identifier") this.checkExport(exports$1, pat, pat.start);
	else if (type === "ObjectPattern") for (var i$1 = 0, list$5 = pat.properties; i$1 < list$5.length; i$1 += 1) {
		var prop = list$5[i$1];
		this.checkPatternExport(exports$1, prop);
	}
	else if (type === "ArrayPattern") for (var i$1$1 = 0, list$1$1 = pat.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
		var elt = list$1$1[i$1$1];
		if (elt) this.checkPatternExport(exports$1, elt);
	}
	else if (type === "Property") this.checkPatternExport(exports$1, pat.value);
	else if (type === "AssignmentPattern") this.checkPatternExport(exports$1, pat.left);
	else if (type === "RestElement") this.checkPatternExport(exports$1, pat.argument);
};
pp$8.checkVariableExport = function(exports$1, decls) {
	if (!exports$1) return;
	for (var i$1 = 0, list$5 = decls; i$1 < list$5.length; i$1 += 1) {
		var decl$1 = list$5[i$1];
		this.checkPatternExport(exports$1, decl$1.id);
	}
};
pp$8.shouldParseExportStatement = function() {
	return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports$1) {
	var node = this.startNode();
	node.local = this.parseModuleExportName();
	node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
	this.checkExport(exports$1, node.exported, node.exported.start);
	return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports$1) {
	var nodes = [], first = true;
	this.expect(types$1.braceL);
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseExportSpecifier(exports$1));
	}
	return nodes;
};
pp$8.parseImport = function(node) {
	this.next();
	if (this.type === types$1.string) {
		node.specifiers = empty$1;
		node.source = this.parseExprAtom();
	} else {
		node.specifiers = this.parseImportSpecifiers();
		this.expectContextual("from");
		node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
	}
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
	var node = this.startNode();
	node.imported = this.parseModuleExportName();
	if (this.eatContextual("as")) node.local = this.parseIdent();
	else {
		this.checkUnreserved(node.imported);
		node.local = node.imported;
	}
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
	var node = this.startNode();
	this.next();
	this.expectContextual("as");
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
	var nodes = [], first = true;
	if (this.type === types$1.name) {
		nodes.push(this.parseImportDefaultSpecifier());
		if (!this.eat(types$1.comma)) return nodes;
	}
	if (this.type === types$1.star) {
		nodes.push(this.parseImportNamespaceSpecifier());
		return nodes;
	}
	this.expect(types$1.braceL);
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseImportSpecifier());
	}
	return nodes;
};
pp$8.parseWithClause = function() {
	var nodes = [];
	if (!this.eat(types$1._with)) return nodes;
	this.expect(types$1.braceL);
	var attributeKeys = {};
	var first = true;
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		var attr = this.parseImportAttribute();
		var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
		if (hasOwn(attributeKeys, keyName)) this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
		attributeKeys[keyName] = true;
		nodes.push(attr);
	}
	return nodes;
};
pp$8.parseImportAttribute = function() {
	var node = this.startNode();
	node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
	this.expect(types$1.colon);
	if (this.type !== types$1.string) this.unexpected();
	node.value = this.parseExprAtom();
	return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
	if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
		var stringLiteral = this.parseLiteral(this.value);
		if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		return stringLiteral;
	}
	return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
	for (var i$1 = 0; i$1 < statements.length && this.isDirectiveCandidate(statements[i$1]); ++i$1) statements[i$1].directive = statements[i$1].expression.raw.slice(1, -1);
};
pp$8.isDirectiveCandidate = function(statement) {
	return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};
var pp$7 = Parser$1.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
		case "Identifier":
			if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
			break;
		case "ObjectPattern":
		case "ArrayPattern":
		case "AssignmentPattern":
		case "RestElement": break;
		case "ObjectExpression":
			node.type = "ObjectPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			for (var i$1 = 0, list$5 = node.properties; i$1 < list$5.length; i$1 += 1) {
				var prop = list$5[i$1];
				this.toAssignable(prop, isBinding);
				if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
			}
			break;
		case "Property":
			if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
			this.toAssignable(node.value, isBinding);
			break;
		case "ArrayExpression":
			node.type = "ArrayPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			this.toAssignableList(node.elements, isBinding);
			break;
		case "SpreadElement":
			node.type = "RestElement";
			this.toAssignable(node.argument, isBinding);
			if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
			break;
		case "AssignmentExpression":
			if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
			node.type = "AssignmentPattern";
			delete node.operator;
			this.toAssignable(node.left, isBinding);
			break;
		case "ParenthesizedExpression":
			this.toAssignable(node.expression, isBinding, refDestructuringErrors);
			break;
		case "ChainExpression":
			this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression": if (!isBinding) break;
		default: this.raise(node.start, "Assigning to rvalue");
	}
	else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
	return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
	var end = exprList.length;
	for (var i$1 = 0; i$1 < end; i$1++) {
		var elt = exprList[i$1];
		if (elt) this.toAssignable(elt, isBinding);
	}
	if (end) {
		var last = exprList[end - 1];
		if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	}
	return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion === 6 && this.type !== types$1.name) this.unexpected();
	node.argument = this.parseBindingAtom();
	return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
	if (this.options.ecmaVersion >= 6) switch (this.type) {
		case types$1.bracketL:
			var node = this.startNode();
			this.next();
			node.elements = this.parseBindingList(types$1.bracketR, true, true);
			return this.finishNode(node, "ArrayPattern");
		case types$1.braceL: return this.parseObj(true);
	}
	return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (first) first = false;
		else this.expect(types$1.comma);
		if (allowEmpty && this.type === types$1.comma) elts.push(null);
		else if (allowTrailingComma && this.afterTrailingComma(close)) break;
		else if (this.type === types$1.ellipsis) {
			var rest = this.parseRestBinding();
			this.parseBindingListItem(rest);
			elts.push(rest);
			if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			this.expect(close);
			break;
		} else elts.push(this.parseAssignableListItem(allowModifiers));
	}
	return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
	var elem = this.parseMaybeDefault(this.start, this.startLoc);
	this.parseBindingListItem(elem);
	return elem;
};
pp$7.parseBindingListItem = function(param) {
	return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
	left = left || this.parseBindingAtom();
	if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.right = this.parseMaybeAssign();
	return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	var isBind = bindingType !== BIND_NONE;
	switch (expr.type) {
		case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			if (isBind) {
				if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
				if (checkClashes) {
					if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
					checkClashes[expr.name] = true;
				}
				if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
			}
			break;
		case "ChainExpression":
			this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
			break;
		case "ParenthesizedExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
			return this.checkLValSimple(expr.expression, bindingType, checkClashes);
		default: this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
	}
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "ObjectPattern":
			for (var i$1 = 0, list$5 = expr.properties; i$1 < list$5.length; i$1 += 1) {
				var prop = list$5[i$1];
				this.checkLValInnerPattern(prop, bindingType, checkClashes);
			}
			break;
		case "ArrayPattern":
			for (var i$1$1 = 0, list$1$1 = expr.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
				var elem = list$1$1[i$1$1];
				if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
			}
			break;
		default: this.checkLValSimple(expr, bindingType, checkClashes);
	}
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "Property":
			this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
			break;
		case "AssignmentPattern":
			this.checkLValPattern(expr.left, bindingType, checkClashes);
			break;
		case "RestElement":
			this.checkLValPattern(expr.argument, bindingType, checkClashes);
			break;
		default: this.checkLValPattern(expr, bindingType, checkClashes);
	}
};
var TokContext = function TokContext$1(token, isExpr, preserveSpace, override, generator) {
	this.token = token;
	this.isExpr = !!isExpr;
	this.preserveSpace = !!preserveSpace;
	this.override = override;
	this.generator = !!generator;
};
var types = {
	b_stat: new TokContext("{", false),
	b_expr: new TokContext("{", true),
	b_tmpl: new TokContext("${", false),
	p_stat: new TokContext("(", false),
	p_expr: new TokContext("(", true),
	q_tmpl: new TokContext("`", true, true, function(p$2) {
		return p$2.tryReadTemplateToken();
	}),
	f_stat: new TokContext("function", false),
	f_expr: new TokContext("function", true),
	f_expr_gen: new TokContext("function", true, false, null, true),
	f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser$1.prototype;
pp$6.initialContext = function() {
	return [types.b_stat];
};
pp$6.curContext = function() {
	return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
	var parent = this.curContext();
	if (parent === types.f_expr || parent === types.f_stat) return true;
	if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) return !parent.isExpr;
	if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) return true;
	if (prevType === types$1.braceL) return parent === types.b_stat;
	if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) return false;
	return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
	for (var i$1 = this.context.length - 1; i$1 >= 1; i$1--) {
		var context = this.context[i$1];
		if (context.token === "function") return context.generator;
	}
	return false;
};
pp$6.updateContext = function(prevType) {
	var update, type = this.type;
	if (type.keyword && prevType === types$1.dot) this.exprAllowed = false;
	else if (update = type.updateContext) update.call(this, prevType);
	else this.exprAllowed = type.beforeExpr;
};
pp$6.overrideContext = function(tokenCtx) {
	if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
	if (this.context.length === 1) {
		this.exprAllowed = true;
		return;
	}
	var out = this.context.pop();
	if (out === types.b_stat && this.curContext().token === "function") out = this.context.pop();
	this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
	this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
	this.context.push(types.b_tmpl);
	this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
	var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
	this.context.push(statementParens ? types.p_stat : types.p_expr);
	this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
	if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);
	else this.context.push(types.f_stat);
	this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
	if (this.curContext().token === "function") this.context.pop();
	this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
	if (this.curContext() === types.q_tmpl) this.context.pop();
	else this.context.push(types.q_tmpl);
	this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
	if (prevType === types$1._function) {
		var index = this.context.length - 1;
		if (this.context[index] === types.f_expr) this.context[index] = types.f_expr_gen;
		else this.context[index] = types.f_gen;
	}
	this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
	var allowed = false;
	if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
		if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
	}
	this.exprAllowed = allowed;
};
var pp$5 = Parser$1.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
	if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	var key = prop.key;
	var name;
	switch (key.type) {
		case "Identifier":
			name = key.name;
			break;
		case "Literal":
			name = String(key.value);
			break;
		default: return;
	}
	var kind = prop.kind;
	if (this.options.ecmaVersion >= 6) {
		if (name === "__proto__" && kind === "init") {
			if (propHash.proto) if (refDestructuringErrors) {
				if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
			} else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			propHash.proto = true;
		}
		return;
	}
	name = "$" + name;
	var other = propHash[name];
	if (other) {
		var redefinition;
		if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
		else redefinition = other.init || other[kind];
		if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
	} else other = propHash[name] = {
		init: false,
		get: false,
		set: false
	};
	other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
	if (this.type === types$1.comma) {
		var node = this.startNodeAt(startPos, startLoc);
		node.expressions = [expr];
		while (this.eat(types$1.comma)) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
		return this.finishNode(node, "SequenceExpression");
	}
	return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
	if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
	else this.exprAllowed = false;
	var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
	if (refDestructuringErrors) {
		oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		oldTrailingComma = refDestructuringErrors.trailingComma;
		oldDoubleProto = refDestructuringErrors.doubleProto;
		refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	} else {
		refDestructuringErrors = new DestructuringErrors$1();
		ownDestructuringErrors = true;
	}
	var startPos = this.start, startLoc = this.startLoc;
	if (this.type === types$1.parenL || this.type === types$1.name) {
		this.potentialArrowAt = this.start;
		this.potentialArrowInForAwait = forInit === "await";
	}
	var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
	if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	if (this.type.isAssign) {
		var node = this.startNodeAt(startPos, startLoc);
		node.operator = this.value;
		if (this.type === types$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
		if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
		if (this.type === types$1.eq) this.checkLValPattern(left);
		else this.checkLValSimple(left);
		node.left = left;
		this.next();
		node.right = this.parseMaybeAssign(forInit);
		if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
		return this.finishNode(node, "AssignmentExpression");
	} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
	if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
	if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
	return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprOps(forInit, refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	if (this.eat(types$1.question)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.test = expr;
		node.consequent = this.parseMaybeAssign();
		this.expect(types$1.colon);
		node.alternate = this.parseMaybeAssign(forInit);
		return this.finishNode(node, "ConditionalExpression");
	}
	return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
	var prec = this.type.binop;
	if (prec != null && (!forInit || this.type !== types$1._in)) {
		if (prec > minPrec) {
			var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
			var coalesce = this.type === types$1.coalesce;
			if (coalesce) prec = types$1.logicalAND.binop;
			var op = this.value;
			this.next();
			var startPos = this.start, startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
			if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
		}
	}
	return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.operator = op;
	node.right = right;
	return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
	var startPos = this.start, startLoc = this.startLoc, expr;
	if (this.isContextual("await") && this.canAwait) {
		expr = this.parseAwait(forInit);
		sawUnary = true;
	} else if (this.type.prefix) {
		var node = this.startNode(), update = this.type === types$1.incDec;
		node.operator = this.value;
		node.prefix = true;
		this.next();
		node.argument = this.parseMaybeUnary(null, true, update, forInit);
		this.checkExpressionErrors(refDestructuringErrors, true);
		if (update) this.checkLValSimple(node.argument);
		else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
		else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
		else sawUnary = true;
		expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	} else if (!sawUnary && this.type === types$1.privateId) {
		if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
		expr = this.parsePrivateIdent();
		if (this.type !== types$1._in) this.unexpected();
	} else {
		expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this.startNodeAt(startPos, startLoc);
			node$1.operator = this.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this.checkLValSimple(expr);
			this.next();
			expr = this.finishNode(node$1, "UpdateExpression");
		}
	}
	if (!incDec && this.eat(types$1.starstar)) if (sawUnary) this.unexpected(this.lastTokStart);
	else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
	else return expr;
};
function isLocalVariableAccess(node) {
	return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
	return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprAtom(refDestructuringErrors, forInit);
	if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
	var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
	if (refDestructuringErrors && result.type === "MemberExpression") {
		if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
		if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
		if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
	}
	return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
	var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
	var optionalChained = false;
	while (true) {
		var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
		if (element.optional) optionalChained = true;
		if (element === base || element.type === "ArrowFunctionExpression") {
			if (optionalChained) {
				var chainNode = this.startNodeAt(startPos, startLoc);
				chainNode.expression = element;
				element = this.finishNode(chainNode, "ChainExpression");
			}
			return element;
		}
		base = element;
	}
};
pp$5.shouldParseAsyncArrow = function() {
	return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
	var optionalSupported = this.options.ecmaVersion >= 11;
	var optional = optionalSupported && this.eat(types$1.questionDot);
	if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
	var computed = this.eat(types$1.bracketL);
	if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.object = base;
		if (computed) {
			node.property = this.parseExpression();
			this.expect(types$1.bracketR);
		} else if (this.type === types$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
		else node.property = this.parseIdent(this.options.allowReserved !== "never");
		node.computed = !!computed;
		if (optionalSupported) node.optional = optional;
		base = this.finishNode(node, "MemberExpression");
	} else if (!noCalls && this.eat(types$1.parenL)) {
		var refDestructuringErrors = new DestructuringErrors$1(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			this.awaitIdentPos = oldAwaitIdentPos;
			return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
		}
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		var node$1 = this.startNodeAt(startPos, startLoc);
		node$1.callee = base;
		node$1.arguments = exprList;
		if (optionalSupported) node$1.optional = optional;
		base = this.finishNode(node$1, "CallExpression");
	} else if (this.type === types$1.backQuote) {
		if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		var node$2 = this.startNodeAt(startPos, startLoc);
		node$2.tag = base;
		node$2.quasi = this.parseTemplate({ isTagged: true });
		base = this.finishNode(node$2, "TaggedTemplateExpression");
	}
	return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
	if (this.type === types$1.slash) this.readRegexp();
	var node, canBeArrow = this.potentialArrowAt === this.start;
	switch (this.type) {
		case types$1._super:
			if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
			node = this.startNode();
			this.next();
			if (this.type === types$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
			if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) this.unexpected();
			return this.finishNode(node, "Super");
		case types$1._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");
		case types$1.name:
			var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
			var id = this.parseIdent(false);
			if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
				this.overrideContext(types.f_expr);
				return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
				if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
				if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
					id = this.parseIdent(false);
					if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) this.unexpected();
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
				}
			}
			return id;
		case types$1.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = {
				pattern: value.pattern,
				flags: value.flags
			};
			return node;
		case types$1.num:
		case types$1.string: return this.parseLiteral(this.value);
		case types$1._null:
		case types$1._true:
		case types$1._false:
			node = this.startNode();
			node.value = this.type === types$1._null ? null : this.type === types$1._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");
		case types$1.parenL:
			var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
			if (refDestructuringErrors) {
				if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
				if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
			}
			return expr;
		case types$1.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");
		case types$1.braceL:
			this.overrideContext(types.b_expr);
			return this.parseObj(false, refDestructuringErrors);
		case types$1._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, 0);
		case types$1._class: return this.parseClass(this.startNode(), false);
		case types$1._new: return this.parseNew();
		case types$1.backQuote: return this.parseTemplate();
		case types$1._import: if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
		else return this.unexpected();
		default: return this.parseExprAtomDefault();
	}
};
pp$5.parseExprAtomDefault = function() {
	this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
	var node = this.startNode();
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
	this.next();
	if (this.type === types$1.parenL && !forNew) return this.parseDynamicImport(node);
	else if (this.type === types$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "import";
		node.meta = this.finishNode(meta, "Identifier");
		return this.parseImportMeta(node);
	} else this.unexpected();
};
pp$5.parseDynamicImport = function(node) {
	this.next();
	node.source = this.parseMaybeAssign();
	if (this.options.ecmaVersion >= 16) if (!this.eat(types$1.parenR)) {
		this.expect(types$1.comma);
		if (!this.afterTrailingComma(types$1.parenR)) {
			node.options = this.parseMaybeAssign();
			if (!this.eat(types$1.parenR)) {
				this.expect(types$1.comma);
				if (!this.afterTrailingComma(types$1.parenR)) this.unexpected();
			}
		} else node.options = null;
	} else node.options = null;
	else if (!this.eat(types$1.parenR)) {
		var errorPos = this.start;
		if (this.eat(types$1.comma) && this.eat(types$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		else this.unexpected(errorPos);
	}
	return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
	this.next();
	var containsEsc = this.containsEsc;
	node.property = this.parseIdent(true);
	if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
	if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
	if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
	return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
	var node = this.startNode();
	node.value = value;
	node.raw = this.input.slice(this.start, this.end);
	if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
	this.next();
	return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
	this.expect(types$1.parenL);
	var val = this.parseExpression();
	this.expect(types$1.parenR);
	return val;
};
pp$5.shouldParseArrow = function(exprList) {
	return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
	var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	if (this.options.ecmaVersion >= 6) {
		this.next();
		var innerStartPos = this.start, innerStartLoc = this.startLoc;
		var exprList = [], first = true, lastIsComma = false;
		var refDestructuringErrors = new DestructuringErrors$1(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		this.yieldPos = 0;
		this.awaitPos = 0;
		while (this.type !== types$1.parenR) {
			first ? first = false : this.expect(types$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
				lastIsComma = true;
				break;
			} else if (this.type === types$1.ellipsis) {
				spreadStart = this.start;
				exprList.push(this.parseParenItem(this.parseRestBinding()));
				if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				break;
			} else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		}
		var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		this.expect(types$1.parenR);
		if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
		}
		if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
		if (spreadStart) this.unexpected(spreadStart);
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		} else val = exprList[0];
	} else val = this.parseParenExpression();
	if (this.options.preserveParens) {
		var par = this.startNodeAt(startPos, startLoc);
		par.expression = val;
		return this.finishNode(par, "ParenthesizedExpression");
	} else return val;
};
pp$5.parseParenItem = function(item) {
	return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "new";
		node.meta = this.finishNode(meta, "Identifier");
		this.next();
		var containsEsc = this.containsEsc;
		node.property = this.parseIdent(true);
		if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
		if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
		if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
		return this.finishNode(node, "MetaProperty");
	}
	var startPos = this.start, startLoc = this.startLoc;
	node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
	if (this.eat(types$1.parenL)) node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
	else node.arguments = empty;
	return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref$1) {
	var isTagged = ref$1.isTagged;
	var elem = this.startNode();
	if (this.type === types$1.invalidTemplate) {
		if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		elem.value = {
			raw: this.value.replace(/\r\n?/g, "\n"),
			cooked: null
		};
	} else elem.value = {
		raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		cooked: this.value
	};
	this.next();
	elem.tail = this.type === types$1.backQuote;
	return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref$1) {
	if (ref$1 === void 0) ref$1 = {};
	var isTagged = ref$1.isTagged;
	if (isTagged === void 0) isTagged = false;
	var node = this.startNode();
	this.next();
	node.expressions = [];
	var curElt = this.parseTemplateElement({ isTagged });
	node.quasis = [curElt];
	while (!curElt.tail) {
		if (this.type === types$1.eof) this.raise(this.pos, "Unterminated template literal");
		this.expect(types$1.dollarBraceL);
		node.expressions.push(this.parseExpression());
		this.expect(types$1.braceR);
		node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
	}
	this.next();
	return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
	return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
	var node = this.startNode(), first = true, propHash = {};
	node.properties = [];
	this.next();
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		var prop = this.parseProperty(isPattern, refDestructuringErrors);
		if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
		node.properties.push(prop);
	}
	return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
	var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
	if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
		if (isPattern) {
			prop.argument = this.parseIdent(false);
			if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			return this.finishNode(prop, "RestElement");
		}
		prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		return this.finishNode(prop, "SpreadElement");
	}
	if (this.options.ecmaVersion >= 6) {
		prop.method = false;
		prop.shorthand = false;
		if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
		}
		if (!isPattern) isGenerator = this.eat(types$1.star);
	}
	var containsEsc = this.containsEsc;
	this.parsePropertyName(prop);
	if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		isAsync = true;
		isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
		this.parsePropertyName(prop);
	} else isAsync = false;
	this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
	return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
	var kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	prop.kind = kind;
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
		var start = prop.value.start;
		if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
		else this.raiseRecoverable(start, "setter should have exactly one param");
	} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
	if ((isGenerator || isAsync) && this.type === types$1.colon) this.unexpected();
	if (this.eat(types$1.colon)) {
		prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		prop.kind = "init";
	} else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
		if (isPattern) this.unexpected();
		prop.method = true;
		prop.value = this.parseMethod(isGenerator, isAsync);
		prop.kind = "init";
	} else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
		if (isGenerator || isAsync) this.unexpected();
		this.parseGetterSetter(prop);
	} else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		if (isGenerator || isAsync) this.unexpected();
		this.checkUnreserved(prop.key);
		if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
		if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		else if (this.type === types$1.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
			prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		} else prop.value = this.copyNode(prop.key);
		prop.kind = "init";
		prop.shorthand = true;
	} else this.unexpected();
};
pp$5.parsePropertyName = function(prop) {
	if (this.options.ecmaVersion >= 6) if (this.eat(types$1.bracketL)) {
		prop.computed = true;
		prop.key = this.parseMaybeAssign();
		this.expect(types$1.bracketR);
		return prop.key;
	} else prop.computed = false;
	return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
	node.id = null;
	if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
	if (this.options.ecmaVersion >= 8) node.async = false;
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
	var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.initFunction(node);
	if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags$1(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
	this.expect(types$1.parenL);
	node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
	this.parseFunctionBody(node, false, true, false);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.enterScope(functionFlags$1(isAsync, false) | SCOPE_ARROW);
	this.initFunction(node);
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	node.params = this.toAssignableList(params, true);
	this.parseFunctionBody(node, true, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
	var isExpression = isArrowFunction && this.type !== types$1.braceL;
	var oldStrict = this.strict, useStrict = false;
	if (isExpression) {
		node.body = this.parseMaybeAssign(forInit);
		node.expression = true;
		this.checkParams(node, false);
	} else {
		var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
		}
		var oldLabels = this.labels;
		this.labels = [];
		if (useStrict) this.strict = true;
		this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
		node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
		node.expression = false;
		this.adaptDirectivePrologue(node.body.body);
		this.labels = oldLabels;
	}
	this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
	for (var i$1 = 0, list$5 = params; i$1 < list$5.length; i$1 += 1) if (list$5[i$1].type !== "Identifier") return false;
	return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
	var nameHash = Object.create(null);
	for (var i$1 = 0, list$5 = node.params; i$1 < list$5.length; i$1 += 1) {
		var param = list$5[i$1];
		this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
	}
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (!first) {
			this.expect(types$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(close)) break;
		} else first = false;
		var elt = void 0;
		if (allowEmpty && this.type === types$1.comma) elt = null;
		else if (this.type === types$1.ellipsis) {
			elt = this.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		} else elt = this.parseMaybeAssign(false, refDestructuringErrors);
		elts.push(elt);
	}
	return elts;
};
pp$5.checkUnreserved = function(ref$1) {
	var start = ref$1.start;
	var end = ref$1.end;
	var name = ref$1.name;
	if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
	if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
	if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
	if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
	if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
	if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
	if ((this.strict ? this.reservedWordsStrict : this.reservedWords).test(name)) {
		if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
		this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
	}
};
pp$5.parseIdent = function(liberal) {
	var node = this.parseIdentNode();
	this.next(!!liberal);
	this.finishNode(node, "Identifier");
	if (!liberal) {
		this.checkUnreserved(node);
		if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
	}
	return node;
};
pp$5.parseIdentNode = function() {
	var node = this.startNode();
	if (this.type === types$1.name) node.name = this.value;
	else if (this.type.keyword) {
		node.name = this.type.keyword;
		if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
		this.type = types$1.name;
	} else this.unexpected();
	return node;
};
pp$5.parsePrivateIdent = function() {
	var node = this.startNode();
	if (this.type === types$1.privateId) node.name = this.value;
	else this.unexpected();
	this.next();
	this.finishNode(node, "PrivateIdentifier");
	if (this.options.checkPrivateFields) if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
	else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
	return node;
};
pp$5.parseYield = function(forInit) {
	if (!this.yieldPos) this.yieldPos = this.start;
	var node = this.startNode();
	this.next();
	if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
		node.delegate = false;
		node.argument = null;
	} else {
		node.delegate = this.eat(types$1.star);
		node.argument = this.parseMaybeAssign(forInit);
	}
	return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
	if (!this.awaitPos) this.awaitPos = this.start;
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeUnary(null, true, false, forInit);
	return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser$1.prototype;
pp$4.raise = function(pos, message) {
	var loc = getLineInfo(this.input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	if (this.sourceFile) message += " in " + this.sourceFile;
	var err = new SyntaxError(message);
	err.pos = pos;
	err.loc = loc;
	err.raisedAt = this.pos;
	throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
	if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser$1.prototype;
var Scope = function Scope$1(flags) {
	this.flags = flags;
	this.var = [];
	this.lexical = [];
	this.functions = [];
};
pp$3.enterScope = function(flags) {
	this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
	this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
	return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
	var redeclared = false;
	if (bindingType === BIND_LEXICAL) {
		var scope = this.currentScope();
		redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		scope.lexical.push(name);
		if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
	} else if (bindingType === BIND_SIMPLE_CATCH) this.currentScope().lexical.push(name);
	else if (bindingType === BIND_FUNCTION) {
		var scope$2 = this.currentScope();
		if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
		else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
		scope$2.functions.push(name);
	} else for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; --i$1) {
		var scope$3 = this.scopeStack[i$1];
		if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
			redeclared = true;
			break;
		}
		scope$3.var.push(name);
		if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
		if (scope$3.flags & SCOPE_VAR) break;
	}
	if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$3.checkLocalExport = function(id) {
	if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$3.currentScope = function() {
	return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) return scope;
	}
};
pp$3.currentThisScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) return scope;
	}
};
var Node$3 = function Node$11(parser$2, pos, loc) {
	this.type = "";
	this.start = pos;
	this.end = 0;
	if (parser$2.options.locations) this.loc = new SourceLocation(parser$2, loc);
	if (parser$2.options.directSourceFile) this.sourceFile = parser$2.options.directSourceFile;
	if (parser$2.options.ranges) this.range = [pos, 0];
};
var pp$2 = Parser$1.prototype;
pp$2.startNode = function() {
	return new Node$3(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
	return new Node$3(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
	node.type = type;
	node.end = pos;
	if (this.options.locations) node.loc.end = loc;
	if (this.options.ranges) node.range[1] = pos;
	return node;
}
pp$2.finishNode = function(node, type) {
	return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
	return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
	var newNode = new Node$3(this, node.start, this.startLoc);
	for (var prop in node) newNode[prop] = node[prop];
	return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
	9: ecma9BinaryProperties,
	10: ecma10BinaryProperties,
	11: ecma11BinaryProperties,
	12: ecma12BinaryProperties,
	13: ecma13BinaryProperties,
	14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
	9: "",
	10: "",
	11: "",
	12: "",
	13: "",
	14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
	9: ecma9ScriptValues,
	10: ecma10ScriptValues,
	11: ecma11ScriptValues,
	12: ecma12ScriptValues,
	13: ecma13ScriptValues,
	14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion$1) {
	var d$1 = data[ecmaVersion$1] = {
		binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion$1] + " " + unicodeGeneralCategoryValues),
		binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion$1]),
		nonBinary: {
			General_Category: wordsRegexp(unicodeGeneralCategoryValues),
			Script: wordsRegexp(unicodeScriptValues[ecmaVersion$1])
		}
	};
	d$1.nonBinary.Script_Extensions = d$1.nonBinary.Script;
	d$1.nonBinary.gc = d$1.nonBinary.General_Category;
	d$1.nonBinary.sc = d$1.nonBinary.Script;
	d$1.nonBinary.scx = d$1.nonBinary.Script_Extensions;
}
for (var i = 0, list = [
	9,
	10,
	11,
	12,
	13,
	14
]; i < list.length; i += 1) {
	var ecmaVersion = list[i];
	buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser$1.prototype;
var BranchID = function BranchID$1(parent, base) {
	this.parent = parent;
	this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
	for (var self$1 = this; self$1; self$1 = self$1.parent) for (var other = alt; other; other = other.parent) if (self$1.base === other.base && self$1 !== other) return true;
	return false;
};
BranchID.prototype.sibling = function sibling() {
	return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState$1(parser$2) {
	this.parser = parser$2;
	this.validFlags = "gim" + (parser$2.options.ecmaVersion >= 6 ? "uy" : "") + (parser$2.options.ecmaVersion >= 9 ? "s" : "") + (parser$2.options.ecmaVersion >= 13 ? "d" : "") + (parser$2.options.ecmaVersion >= 15 ? "v" : "");
	this.unicodeProperties = data[parser$2.options.ecmaVersion >= 14 ? 14 : parser$2.options.ecmaVersion];
	this.source = "";
	this.flags = "";
	this.start = 0;
	this.switchU = false;
	this.switchV = false;
	this.switchN = false;
	this.pos = 0;
	this.lastIntValue = 0;
	this.lastStringValue = "";
	this.lastAssertionIsQuantifiable = false;
	this.numCapturingParens = 0;
	this.maxBackReference = 0;
	this.groupNames = Object.create(null);
	this.backReferenceNames = [];
	this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
	var unicodeSets = flags.indexOf("v") !== -1;
	var unicode = flags.indexOf("u") !== -1;
	this.start = start | 0;
	this.source = pattern + "";
	this.flags = flags;
	if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		this.switchU = true;
		this.switchV = true;
		this.switchN = true;
	} else {
		this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		this.switchV = false;
		this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
	}
};
RegExpValidationState.prototype.raise = function raise(message) {
	this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l$2 = s.length;
	if (i$1 >= l$2) return -1;
	var c$2 = s.charCodeAt(i$1);
	if (!(forceU || this.switchU) || c$2 <= 55295 || c$2 >= 57344 || i$1 + 1 >= l$2) return c$2;
	var next = s.charCodeAt(i$1 + 1);
	return next >= 56320 && next <= 57343 ? (c$2 << 10) + next - 56613888 : c$2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l$2 = s.length;
	if (i$1 >= l$2) return l$2;
	var c$2 = s.charCodeAt(i$1), next;
	if (!(forceU || this.switchU) || c$2 <= 55295 || c$2 >= 57344 || i$1 + 1 >= l$2 || (next = s.charCodeAt(i$1 + 1)) < 56320 || next > 57343) return i$1 + 1;
	return i$1 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
	if (forceU === void 0) forceU = false;
	this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
	if (forceU === void 0) forceU = false;
	if (this.current(forceU) === ch) {
		this.advance(forceU);
		return true;
	}
	return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
	if (forceU === void 0) forceU = false;
	var pos = this.pos;
	for (var i$1 = 0, list$5 = chs; i$1 < list$5.length; i$1 += 1) {
		var ch = list$5[i$1];
		var current = this.at(pos, forceU);
		if (current === -1 || current !== ch) return false;
		pos = this.nextIndex(pos, forceU);
	}
	this.pos = pos;
	return true;
};
/**
* Validate the flags part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpFlags = function(state) {
	var validFlags = state.validFlags;
	var flags = state.flags;
	var u = false;
	var v$2 = false;
	for (var i$1 = 0; i$1 < flags.length; i$1++) {
		var flag = flags.charAt(i$1);
		if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
		if (flags.indexOf(flag, i$1 + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
		if (flag === "u") u = true;
		if (flag === "v") v$2 = true;
	}
	if (this.options.ecmaVersion >= 15 && u && v$2) this.raise(state.start, "Invalid regular expression flag");
};
function hasProp(obj) {
	for (var _$1 in obj) return true;
	return false;
}
/**
* Validate the pattern part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpPattern = function(state) {
	this.regexp_pattern(state);
	if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
		state.switchN = true;
		this.regexp_pattern(state);
	}
};
pp$1.regexp_pattern = function(state) {
	state.pos = 0;
	state.lastIntValue = 0;
	state.lastStringValue = "";
	state.lastAssertionIsQuantifiable = false;
	state.numCapturingParens = 0;
	state.maxBackReference = 0;
	state.groupNames = Object.create(null);
	state.backReferenceNames.length = 0;
	state.branchID = null;
	this.regexp_disjunction(state);
	if (state.pos !== state.source.length) {
		if (state.eat(41)) state.raise("Unmatched ')'");
		if (state.eat(93) || state.eat(125)) state.raise("Lone quantifier brackets");
	}
	if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
	for (var i$1 = 0, list$5 = state.backReferenceNames; i$1 < list$5.length; i$1 += 1) {
		var name = list$5[i$1];
		if (!state.groupNames[name]) state.raise("Invalid named capture referenced");
	}
};
pp$1.regexp_disjunction = function(state) {
	var trackDisjunction = this.options.ecmaVersion >= 16;
	if (trackDisjunction) state.branchID = new BranchID(state.branchID, null);
	this.regexp_alternative(state);
	while (state.eat(124)) {
		if (trackDisjunction) state.branchID = state.branchID.sibling();
		this.regexp_alternative(state);
	}
	if (trackDisjunction) state.branchID = state.branchID.parent;
	if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
	if (state.eat(123)) state.raise("Lone quantifier brackets");
};
pp$1.regexp_alternative = function(state) {
	while (state.pos < state.source.length && this.regexp_eatTerm(state));
};
pp$1.regexp_eatTerm = function(state) {
	if (this.regexp_eatAssertion(state)) {
		if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
			if (state.switchU) state.raise("Invalid quantifier");
		}
		return true;
	}
	if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		this.regexp_eatQuantifier(state);
		return true;
	}
	return false;
};
pp$1.regexp_eatAssertion = function(state) {
	var start = state.pos;
	state.lastAssertionIsQuantifiable = false;
	if (state.eat(94) || state.eat(36)) return true;
	if (state.eat(92)) {
		if (state.eat(66) || state.eat(98)) return true;
		state.pos = start;
	}
	if (state.eat(40) && state.eat(63)) {
		var lookbehind = false;
		if (this.options.ecmaVersion >= 9) lookbehind = state.eat(60);
		if (state.eat(61) || state.eat(33)) {
			this.regexp_disjunction(state);
			if (!state.eat(41)) state.raise("Unterminated group");
			state.lastAssertionIsQuantifiable = !lookbehind;
			return true;
		}
	}
	state.pos = start;
	return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
	if (noError === void 0) noError = false;
	if (this.regexp_eatQuantifierPrefix(state, noError)) {
		state.eat(63);
		return true;
	}
	return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
	return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
	var start = state.pos;
	if (state.eat(123)) {
		var min = 0, max = -1;
		if (this.regexp_eatDecimalDigits(state)) {
			min = state.lastIntValue;
			if (state.eat(44) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
			if (state.eat(125)) {
				if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
				return true;
			}
		}
		if (state.switchU && !noError) state.raise("Incomplete quantifier");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatAtom = function(state) {
	return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatAtomEscape(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
	var start = state.pos;
	if (state.eat(40)) {
		if (state.eat(63)) {
			if (this.options.ecmaVersion >= 16) {
				var addModifiers = this.regexp_eatModifiers(state);
				var hasHyphen = state.eat(45);
				if (addModifiers || hasHyphen) {
					for (var i$1 = 0; i$1 < addModifiers.length; i$1++) {
						var modifier = addModifiers.charAt(i$1);
						if (addModifiers.indexOf(modifier, i$1 + 1) > -1) state.raise("Duplicate regular expression modifiers");
					}
					if (hasHyphen) {
						var removeModifiers = this.regexp_eatModifiers(state);
						if (!addModifiers && !removeModifiers && state.current() === 58) state.raise("Invalid regular expression modifiers");
						for (var i$1$1 = 0; i$1$1 < removeModifiers.length; i$1$1++) {
							var modifier$1 = removeModifiers.charAt(i$1$1);
							if (removeModifiers.indexOf(modifier$1, i$1$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) state.raise("Duplicate regular expression modifiers");
						}
					}
				}
			}
			if (state.eat(58)) {
				this.regexp_disjunction(state);
				if (state.eat(41)) return true;
				state.raise("Unterminated group");
			}
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
	if (state.eat(40)) {
		if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
		else if (state.current() === 63) state.raise("Invalid group");
		this.regexp_disjunction(state);
		if (state.eat(41)) {
			state.numCapturingParens += 1;
			return true;
		}
		state.raise("Unterminated group");
	}
	return false;
};
pp$1.regexp_eatModifiers = function(state) {
	var modifiers = "";
	var ch = 0;
	while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
		modifiers += codePointToString(ch);
		state.advance();
	}
	return modifiers;
};
function isRegularExpressionModifier(ch) {
	return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
	return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
	if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
	return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
	var ch = state.current();
	if (isSyntaxCharacter(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isSyntaxCharacter(ch) {
	return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
	var start = state.pos;
	var ch = 0;
	while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) state.advance();
	return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
	var ch = state.current();
	if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_groupSpecifier = function(state) {
	if (state.eat(63)) {
		if (!this.regexp_eatGroupName(state)) state.raise("Invalid group");
		var trackDisjunction = this.options.ecmaVersion >= 16;
		var known = state.groupNames[state.lastStringValue];
		if (known) if (trackDisjunction) {
			for (var i$1 = 0, list$5 = known; i$1 < list$5.length; i$1 += 1) if (!list$5[i$1].separatedFrom(state.branchID)) state.raise("Duplicate capture group name");
		} else state.raise("Duplicate capture group name");
		if (trackDisjunction) (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
		else state.groupNames[state.lastStringValue] = true;
	}
};
pp$1.regexp_eatGroupName = function(state) {
	state.lastStringValue = "";
	if (state.eat(60)) {
		if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return true;
		state.raise("Invalid capture group name");
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
	state.lastStringValue = "";
	if (this.regexp_eatRegExpIdentifierStart(state)) {
		state.lastStringValue += codePointToString(state.lastIntValue);
		while (this.regexp_eatRegExpIdentifierPart(state)) state.lastStringValue += codePointToString(state.lastIntValue);
		return true;
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierStart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierStart(ch) {
	return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierPart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierPart(ch) {
	return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
	if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
	if (state.switchU) {
		if (state.current() === 99) state.raise("Invalid unicode escape");
		state.raise("Invalid escape");
	}
	return false;
};
pp$1.regexp_eatBackReference = function(state) {
	var start = state.pos;
	if (this.regexp_eatDecimalEscape(state)) {
		var n$1 = state.lastIntValue;
		if (state.switchU) {
			if (n$1 > state.maxBackReference) state.maxBackReference = n$1;
			return true;
		}
		if (n$1 <= state.numCapturingParens) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatKGroupName = function(state) {
	if (state.eat(107)) {
		if (this.regexp_eatGroupName(state)) {
			state.backReferenceNames.push(state.lastStringValue);
			return true;
		}
		state.raise("Invalid named reference");
	}
	return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
	return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
	var start = state.pos;
	if (state.eat(99)) {
		if (this.regexp_eatControlLetter(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatZero = function(state) {
	if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
		state.lastIntValue = 0;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlEscape = function(state) {
	var ch = state.current();
	if (ch === 116) {
		state.lastIntValue = 9;
		state.advance();
		return true;
	}
	if (ch === 110) {
		state.lastIntValue = 10;
		state.advance();
		return true;
	}
	if (ch === 118) {
		state.lastIntValue = 11;
		state.advance();
		return true;
	}
	if (ch === 102) {
		state.lastIntValue = 12;
		state.advance();
		return true;
	}
	if (ch === 114) {
		state.lastIntValue = 13;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlLetter = function(state) {
	var ch = state.current();
	if (isControlLetter(ch)) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
function isControlLetter(ch) {
	return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
	if (forceU === void 0) forceU = false;
	var start = state.pos;
	var switchU = forceU || state.switchU;
	if (state.eat(117)) {
		if (this.regexp_eatFixedHexDigits(state, 4)) {
			var lead = state.lastIntValue;
			if (switchU && lead >= 55296 && lead <= 56319) {
				var leadSurrogateEnd = state.pos;
				if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
					var trail = state.lastIntValue;
					if (trail >= 56320 && trail <= 57343) {
						state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
						return true;
					}
				}
				state.pos = leadSurrogateEnd;
				state.lastIntValue = lead;
			}
			return true;
		}
		if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) return true;
		if (switchU) state.raise("Invalid unicode escape");
		state.pos = start;
	}
	return false;
};
function isValidUnicode(ch) {
	return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
	if (state.switchU) {
		if (this.regexp_eatSyntaxCharacter(state)) return true;
		if (state.eat(47)) {
			state.lastIntValue = 47;
			return true;
		}
		return false;
	}
	var ch = state.current();
	if (ch !== 99 && (!state.switchN || ch !== 107)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
	state.lastIntValue = 0;
	var ch = state.current();
	if (ch >= 49 && ch <= 57) {
		do {
			state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
			state.advance();
		} while ((ch = state.current()) >= 48 && ch <= 57);
		return true;
	}
	return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
	var ch = state.current();
	if (isCharacterClassEscape(ch)) {
		state.lastIntValue = -1;
		state.advance();
		return CharSetOk;
	}
	var negate = false;
	if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
		state.lastIntValue = -1;
		state.advance();
		var result;
		if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
			if (negate && result === CharSetString) state.raise("Invalid property name");
			return result;
		}
		state.raise("Invalid property name");
	}
	return CharSetNone;
};
function isCharacterClassEscape(ch) {
	return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
	var start = state.pos;
	if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
		var name = state.lastStringValue;
		if (this.regexp_eatUnicodePropertyValue(state)) {
			var value = state.lastStringValue;
			this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
			return CharSetOk;
		}
	}
	state.pos = start;
	if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		var nameOrValue = state.lastStringValue;
		return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	}
	return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
	if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
	if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
	state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyNameCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
	return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyValueCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
	return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (!state.eat(93)) state.raise("Unterminated character class");
		if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
		return true;
	}
	return false;
};
pp$1.regexp_classContents = function(state) {
	if (state.current() === 93) return CharSetOk;
	if (state.switchV) return this.regexp_classSetExpression(state);
	this.regexp_nonEmptyClassRanges(state);
	return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
	while (this.regexp_eatClassAtom(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassAtom(state)) {
			var right = state.lastIntValue;
			if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
		}
	}
};
pp$1.regexp_eatClassAtom = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatClassEscape(state)) return true;
		if (state.switchU) {
			var ch$1 = state.current();
			if (ch$1 === 99 || isOctalDigit(ch$1)) state.raise("Invalid class escape");
			state.raise("Invalid escape");
		}
		state.pos = start;
	}
	var ch = state.current();
	if (ch !== 93) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatClassEscape = function(state) {
	var start = state.pos;
	if (state.eat(98)) {
		state.lastIntValue = 8;
		return true;
	}
	if (state.switchU && state.eat(45)) {
		state.lastIntValue = 45;
		return true;
	}
	if (!state.switchU && state.eat(99)) {
		if (this.regexp_eatClassControlLetter(state)) return true;
		state.pos = start;
	}
	return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
	var result = CharSetOk, subResult;
	if (this.regexp_eatClassSetRange(state));
	else if (subResult = this.regexp_eatClassSetOperand(state)) {
		if (subResult === CharSetString) result = CharSetString;
		var start = state.pos;
		while (state.eatChars([38, 38])) {
			if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
				if (subResult !== CharSetString) result = CharSetOk;
				continue;
			}
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
		while (state.eatChars([45, 45])) {
			if (this.regexp_eatClassSetOperand(state)) continue;
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
	} else state.raise("Invalid character in character class");
	for (;;) {
		if (this.regexp_eatClassSetRange(state)) continue;
		subResult = this.regexp_eatClassSetOperand(state);
		if (!subResult) return result;
		if (subResult === CharSetString) result = CharSetString;
	}
};
pp$1.regexp_eatClassSetRange = function(state) {
	var start = state.pos;
	if (this.regexp_eatClassSetCharacter(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
			var right = state.lastIntValue;
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
			return true;
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
	if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
	return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
	var start = state.pos;
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (state.eat(93)) {
			if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
			return result;
		}
		state.pos = start;
	}
	if (state.eat(92)) {
		var result$1 = this.regexp_eatCharacterClassEscape(state);
		if (result$1) return result$1;
		state.pos = start;
	}
	return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
	var start = state.pos;
	if (state.eatChars([92, 113])) {
		if (state.eat(123)) {
			var result = this.regexp_classStringDisjunctionContents(state);
			if (state.eat(125)) return result;
		} else state.raise("Invalid escape");
		state.pos = start;
	}
	return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
	var result = this.regexp_classString(state);
	while (state.eat(124)) if (this.regexp_classString(state) === CharSetString) result = CharSetString;
	return result;
};
pp$1.regexp_classString = function(state) {
	var count = 0;
	while (this.regexp_eatClassSetCharacter(state)) count++;
	return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
		if (state.eat(98)) {
			state.lastIntValue = 8;
			return true;
		}
		state.pos = start;
		return false;
	}
	var ch = state.current();
	if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
	if (isClassSetSyntaxCharacter(ch)) return false;
	state.advance();
	state.lastIntValue = ch;
	return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
	return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
	return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
	var ch = state.current();
	if (isClassSetReservedPunctuator(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isClassSetReservedPunctuator(ch) {
	return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
	var ch = state.current();
	if (isDecimalDigit(ch) || ch === 95) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
	var start = state.pos;
	if (state.eat(120)) {
		if (this.regexp_eatFixedHexDigits(state, 2)) return true;
		if (state.switchU) state.raise("Invalid escape");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isDecimalDigit(ch = state.current())) {
		state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
		state.advance();
	}
	return state.pos !== start;
};
function isDecimalDigit(ch) {
	return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isHexDigit(ch = state.current())) {
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return state.pos !== start;
};
function isHexDigit(ch) {
	return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
	if (ch >= 65 && ch <= 70) return 10 + (ch - 65);
	if (ch >= 97 && ch <= 102) return 10 + (ch - 97);
	return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
	if (this.regexp_eatOctalDigit(state)) {
		var n1 = state.lastIntValue;
		if (this.regexp_eatOctalDigit(state)) {
			var n2 = state.lastIntValue;
			if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
			else state.lastIntValue = n1 * 8 + n2;
		} else state.lastIntValue = n1;
		return true;
	}
	return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
	var ch = state.current();
	if (isOctalDigit(ch)) {
		state.lastIntValue = ch - 48;
		state.advance();
		return true;
	}
	state.lastIntValue = 0;
	return false;
};
function isOctalDigit(ch) {
	return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
	var start = state.pos;
	state.lastIntValue = 0;
	for (var i$1 = 0; i$1 < length; ++i$1) {
		var ch = state.current();
		if (!isHexDigit(ch)) {
			state.pos = start;
			return false;
		}
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return true;
};
var Token = function Token$1(p$2) {
	this.type = p$2.type;
	this.value = p$2.value;
	this.start = p$2.start;
	this.end = p$2.end;
	if (p$2.options.locations) this.loc = new SourceLocation(p$2, p$2.startLoc, p$2.endLoc);
	if (p$2.options.ranges) this.range = [p$2.start, p$2.end];
};
var pp = Parser$1.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
	if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
	if (this.options.onToken) this.options.onToken(new Token(this));
	this.lastTokEnd = this.end;
	this.lastTokStart = this.start;
	this.lastTokEndLoc = this.endLoc;
	this.lastTokStartLoc = this.startLoc;
	this.nextToken();
};
pp.getToken = function() {
	this.next();
	return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
	var this$1$1 = this;
	return { next: function() {
		var token = this$1$1.getToken();
		return {
			done: token.type === types$1.eof,
			value: token
		};
	} };
};
pp.nextToken = function() {
	var curContext = this.curContext();
	if (!curContext || !curContext.preserveSpace) this.skipSpace();
	this.start = this.pos;
	if (this.options.locations) this.startLoc = this.curPosition();
	if (this.pos >= this.input.length) return this.finishToken(types$1.eof);
	if (curContext.override) return curContext.override(this);
	else this.readToken(this.fullCharCodeAtPos());
};
pp.readToken = function(code) {
	if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
	return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
	var code = this.input.charCodeAt(this.pos);
	if (code <= 55295 || code >= 56320) return code;
	var next = this.input.charCodeAt(this.pos + 1);
	return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
	var startLoc = this.options.onComment && this.curPosition();
	var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	this.pos = end + 2;
	if (this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		++this.curLine;
		pos = this.lineStart = nextBreak;
	}
	if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp.skipLineComment = function(startSkip) {
	var start = this.pos;
	var startLoc = this.options.onComment && this.curPosition();
	var ch = this.input.charCodeAt(this.pos += startSkip);
	while (this.pos < this.input.length && !isNewLine(ch)) ch = this.input.charCodeAt(++this.pos);
	if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function() {
	loop: while (this.pos < this.input.length) {
		var ch = this.input.charCodeAt(this.pos);
		switch (ch) {
			case 32:
			case 160:
				++this.pos;
				break;
			case 13: if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
			case 10:
			case 8232:
			case 8233:
				++this.pos;
				if (this.options.locations) {
					++this.curLine;
					this.lineStart = this.pos;
				}
				break;
			case 47:
				switch (this.input.charCodeAt(this.pos + 1)) {
					case 42:
						this.skipBlockComment();
						break;
					case 47:
						this.skipLineComment(2);
						break;
					default: break loop;
				}
				break;
			default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
			else break loop;
		}
	}
};
pp.finishToken = function(type, val) {
	this.end = this.pos;
	if (this.options.locations) this.endLoc = this.curPosition();
	var prevType = this.type;
	this.type = type;
	this.value = val;
	this.updateContext(prevType);
};
pp.readToken_dot = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next >= 48 && next <= 57) return this.readNumber(true);
	var next2 = this.input.charCodeAt(this.pos + 2);
	if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
		this.pos += 3;
		return this.finishToken(types$1.ellipsis);
	} else {
		++this.pos;
		return this.finishToken(types$1.dot);
	}
};
pp.readToken_slash = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (this.exprAllowed) {
		++this.pos;
		return this.readRegexp();
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	var tokentype = code === 42 ? types$1.star : types$1.modulo;
	if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		++size;
		tokentype = types$1.starstar;
		next = this.input.charCodeAt(this.pos + 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, size + 1);
	return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (this.options.ecmaVersion >= 12) {
			if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1.assign, 3);
		}
		return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
	if (this.input.charCodeAt(this.pos + 1) === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
		}
		return this.finishOp(types$1.incDec, 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	if (next === code) {
		size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1.assign, size + 1);
		return this.finishOp(types$1.bitShift, size);
	}
	if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
		this.skipLineComment(4);
		this.skipSpace();
		return this.nextToken();
	}
	if (next === 61) size = 2;
	return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === 61) return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
		this.pos += 2;
		return this.finishToken(types$1.arrow);
	}
	return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	if (ecmaVersion$1 >= 11) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === 46) {
			var next2 = this.input.charCodeAt(this.pos + 2);
			if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
		}
		if (next === 63) {
			if (ecmaVersion$1 >= 12) {
				if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1.assign, 3);
			}
			return this.finishOp(types$1.coalesce, 2);
		}
	}
	return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	var code = 35;
	if (ecmaVersion$1 >= 13) {
		++this.pos;
		code = this.fullCharCodeAtPos();
		if (isIdentifierStart(code, true) || code === 92) return this.finishToken(types$1.privateId, this.readWord1());
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
	switch (code) {
		case 46: return this.readToken_dot();
		case 40:
			++this.pos;
			return this.finishToken(types$1.parenL);
		case 41:
			++this.pos;
			return this.finishToken(types$1.parenR);
		case 59:
			++this.pos;
			return this.finishToken(types$1.semi);
		case 44:
			++this.pos;
			return this.finishToken(types$1.comma);
		case 91:
			++this.pos;
			return this.finishToken(types$1.bracketL);
		case 93:
			++this.pos;
			return this.finishToken(types$1.bracketR);
		case 123:
			++this.pos;
			return this.finishToken(types$1.braceL);
		case 125:
			++this.pos;
			return this.finishToken(types$1.braceR);
		case 58:
			++this.pos;
			return this.finishToken(types$1.colon);
		case 96:
			if (this.options.ecmaVersion < 6) break;
			++this.pos;
			return this.finishToken(types$1.backQuote);
		case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) return this.readRadixNumber(16);
			if (this.options.ecmaVersion >= 6) {
				if (next === 111 || next === 79) return this.readRadixNumber(8);
				if (next === 98 || next === 66) return this.readRadixNumber(2);
			}
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57: return this.readNumber(false);
		case 34:
		case 39: return this.readString(code);
		case 47: return this.readToken_slash();
		case 37:
		case 42: return this.readToken_mult_modulo_exp(code);
		case 124:
		case 38: return this.readToken_pipe_amp(code);
		case 94: return this.readToken_caret();
		case 43:
		case 45: return this.readToken_plus_min(code);
		case 60:
		case 62: return this.readToken_lt_gt(code);
		case 61:
		case 33: return this.readToken_eq_excl(code);
		case 63: return this.readToken_question();
		case 126: return this.finishOp(types$1.prefix, 1);
		case 35: return this.readToken_numberSign();
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
	var str = this.input.slice(this.pos, this.pos + size);
	this.pos += size;
	return this.finishToken(type, str);
};
pp.readRegexp = function() {
	var escaped, inClass, start = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
		var ch = this.input.charAt(this.pos);
		if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
		if (!escaped) {
			if (ch === "[") inClass = true;
			else if (ch === "]" && inClass) inClass = false;
			else if (ch === "/" && !inClass) break;
			escaped = ch === "\\";
		} else escaped = false;
		++this.pos;
	}
	var pattern = this.input.slice(start, this.pos);
	++this.pos;
	var flagsStart = this.pos;
	var flags = this.readWord1();
	if (this.containsEsc) this.unexpected(flagsStart);
	var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	state.reset(start, pattern, flags);
	this.validateRegExpFlags(state);
	this.validateRegExpPattern(state);
	var value = null;
	try {
		value = new RegExp(pattern, flags);
	} catch (e$1) {}
	return this.finishToken(types$1.regexp, {
		pattern,
		flags,
		value
	});
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
	var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
	var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
	var start = this.pos, total = 0, lastCode = 0;
	for (var i$1 = 0, e$1 = len == null ? Infinity : len; i$1 < e$1; ++i$1, ++this.pos) {
		var code = this.input.charCodeAt(this.pos), val = void 0;
		if (allowSeparators && code === 95) {
			if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
			if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
			if (i$1 === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
			lastCode = code;
			continue;
		}
		if (code >= 97) val = code - 97 + 10;
		else if (code >= 65) val = code - 65 + 10;
		else if (code >= 48 && code <= 57) val = code - 48;
		else val = Infinity;
		if (val >= radix) break;
		lastCode = code;
		total = total * radix + val;
	}
	if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
	if (this.pos === start || len != null && this.pos - start !== len) return null;
	return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
	if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
	return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
	if (typeof BigInt !== "function") return null;
	return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
	var start = this.pos;
	this.pos += 2;
	var val = this.readInt(radix);
	if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		val = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
	} else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
	var start = this.pos;
	if (!startsWithDot && this.readInt(10, void 0, true) === null) this.raise(start, "Invalid number");
	var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	if (octal && this.strict) this.raise(start, "Invalid number");
	var next = this.input.charCodeAt(this.pos);
	if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
		if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		return this.finishToken(types$1.num, val$1);
	}
	if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
	if (next === 46 && !octal) {
		++this.pos;
		this.readInt(10);
		next = this.input.charCodeAt(this.pos);
	}
	if ((next === 69 || next === 101) && !octal) {
		next = this.input.charCodeAt(++this.pos);
		if (next === 43 || next === 45) ++this.pos;
		if (this.readInt(10) === null) this.raise(start, "Invalid number");
	}
	if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	var val = stringToNumber(this.input.slice(start, this.pos), octal);
	return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
	var ch = this.input.charCodeAt(this.pos), code;
	if (ch === 123) {
		if (this.options.ecmaVersion < 6) this.unexpected();
		var codePos = ++this.pos;
		code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		++this.pos;
		if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
	} else code = this.readHexChar(4);
	return code;
};
pp.readString = function(quote$1) {
	var out = "", chunkStart = ++this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === quote$1) break;
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(false);
			chunkStart = this.pos;
		} else if (ch === 8232 || ch === 8233) {
			if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
			++this.pos;
			if (this.options.locations) {
				this.curLine++;
				this.lineStart = this.pos;
			}
		} else {
			if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
			++this.pos;
		}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
	this.inTemplateElement = true;
	try {
		this.readTmplToken();
	} catch (err) {
		if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
		else throw err;
	}
	this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
	if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
	else this.raise(position, message);
};
pp.readTmplToken = function() {
	var out = "", chunkStart = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
			if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) if (ch === 36) {
				this.pos += 2;
				return this.finishToken(types$1.dollarBraceL);
			} else {
				++this.pos;
				return this.finishToken(types$1.backQuote);
			}
			out += this.input.slice(chunkStart, this.pos);
			return this.finishToken(types$1.template, out);
		}
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(true);
			chunkStart = this.pos;
		} else if (isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			++this.pos;
			switch (ch) {
				case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
				case 10:
					out += "\n";
					break;
				default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			chunkStart = this.pos;
		} else ++this.pos;
	}
};
pp.readInvalidTemplateToken = function() {
	for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
		case "\\":
			++this.pos;
			break;
		case "$": if (this.input[this.pos + 1] !== "{") break;
		case "`": return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
		case "\r": if (this.input[this.pos + 1] === "\n") ++this.pos;
		case "\n":
		case "\u2028":
		case "\u2029":
			++this.curLine;
			this.lineStart = this.pos + 1;
			break;
	}
	this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
	var ch = this.input.charCodeAt(++this.pos);
	++this.pos;
	switch (ch) {
		case 110: return "\n";
		case 114: return "\r";
		case 120: return String.fromCharCode(this.readHexChar(2));
		case 117: return codePointToString(this.readCodePoint());
		case 116: return "	";
		case 98: return "\b";
		case 118: return "\v";
		case 102: return "\f";
		case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
		case 10:
			if (this.options.locations) {
				this.lineStart = this.pos;
				++this.curLine;
			}
			return "";
		case 56:
		case 57:
			if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
			if (inTemplate) {
				var codePos = this.pos - 1;
				this.invalidStringToken(codePos, "Invalid escape sequence in template string");
			}
		default:
			if (ch >= 48 && ch <= 55) {
				var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
				var octal = parseInt(octalStr, 8);
				if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
				}
				this.pos += octalStr.length - 1;
				ch = this.input.charCodeAt(this.pos);
				if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
				return String.fromCharCode(octal);
			}
			if (isNewLine(ch)) {
				if (this.options.locations) {
					this.lineStart = this.pos;
					++this.curLine;
				}
				return "";
			}
			return String.fromCharCode(ch);
	}
};
pp.readHexChar = function(len) {
	var codePos = this.pos;
	var n$1 = this.readInt(16, len);
	if (n$1 === null) this.invalidStringToken(codePos, "Bad character escape sequence");
	return n$1;
};
pp.readWord1 = function() {
	this.containsEsc = false;
	var word = "", first = true, chunkStart = this.pos;
	var astral = this.options.ecmaVersion >= 6;
	while (this.pos < this.input.length) {
		var ch = this.fullCharCodeAtPos();
		if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
		else if (ch === 92) {
			this.containsEsc = true;
			word += this.input.slice(chunkStart, this.pos);
			var escStart = this.pos;
			if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
			++this.pos;
			var esc = this.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
			word += codePointToString(esc);
			chunkStart = this.pos;
		} else break;
		first = false;
	}
	return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
	var word = this.readWord1();
	var type = types$1.name;
	if (this.keywords.test(word)) type = keywords[word];
	return this.finishToken(type, word);
};
var version = "8.15.0";
Parser$1.acorn = {
	Parser: Parser$1,
	version,
	defaultOptions,
	Position,
	SourceLocation,
	getLineInfo,
	Node: Node$3,
	TokenType,
	tokTypes: types$1,
	keywordTypes: keywords,
	TokContext,
	tokContexts: types,
	isIdentifierChar,
	isIdentifierStart,
	Token,
	isNewLine,
	lineBreak,
	lineBreakG,
	nonASCIIwhitespace
};
function parse$2(input, options) {
	return Parser$1.parse(input, options);
}
function parseExpressionAt(input, pos, options) {
	return Parser$1.parseExpressionAt(input, pos, options);
}
function tokenizer(input, options) {
	return Parser$1.tokenizer(input, options);
}

//#endregion
//#region ../../node_modules/.pnpm/@sveltejs+acorn-typescript@1.0.5_acorn@8.15.0/node_modules/@sveltejs/acorn-typescript/index.js
var startsExpr = true;
function kwLike(_name, options = {}) {
	return new TokenType("name", options);
}
var acornTypeScriptMap = /* @__PURE__ */ new WeakMap();
function generateAcornTypeScript(_acorn) {
	const acorn = _acorn.Parser.acorn || _acorn;
	let acornTypeScript = acornTypeScriptMap.get(acorn);
	if (!acornTypeScript) {
		let tokenIsLiteralPropertyName = function(token) {
			return [
				...[
					types$1.name,
					types$1.string,
					types$1.num
				],
				...Object.values(keywords),
				...Object.values(tsKwTokenType)
			].includes(token);
		}, tokenIsKeywordOrIdentifier = function(token) {
			return [
				...[types$1.name],
				...Object.values(keywords),
				...Object.values(tsKwTokenType)
			].includes(token);
		}, tokenIsIdentifier = function(token) {
			return [...Object.values(tsKwTokenType), types$1.name].includes(token);
		}, tokenIsTSDeclarationStart = function(token) {
			return [
				tsKwTokenType.abstract,
				tsKwTokenType.declare,
				tsKwTokenType.enum,
				tsKwTokenType.module,
				tsKwTokenType.namespace,
				tsKwTokenType.interface,
				tsKwTokenType.type
			].includes(token);
		}, tokenIsTSTypeOperator = function(token) {
			return [
				tsKwTokenType.keyof,
				tsKwTokenType.readonly,
				tsKwTokenType.unique
			].includes(token);
		}, tokenIsTemplate = function(token) {
			return token === types$1.invalidTemplate;
		};
		const tsKwTokenType = generateTsKwTokenType();
		const tsTokenType = generateTsTokenType();
		const tsTokenContext = generateTsTokenContext();
		const tsKeywordsRegExp = /* @__PURE__ */ new RegExp(`^(?:${Object.keys(tsKwTokenType).join("|")})$`);
		tsTokenType.jsxTagStart.updateContext = function() {
			this.context.push(tsTokenContext.tc_expr);
			this.context.push(tsTokenContext.tc_oTag);
			this.exprAllowed = false;
		};
		tsTokenType.jsxTagEnd.updateContext = function(prevType) {
			let out = this.context.pop();
			if (out === tsTokenContext.tc_oTag && prevType === types$1.slash || out === tsTokenContext.tc_cTag) {
				this.context.pop();
				this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;
			} else this.exprAllowed = true;
		};
		acornTypeScript = {
			tokTypes: {
				...tsKwTokenType,
				...tsTokenType
			},
			tokContexts: { ...tsTokenContext },
			keywordsRegExp: tsKeywordsRegExp,
			tokenIsLiteralPropertyName,
			tokenIsKeywordOrIdentifier,
			tokenIsIdentifier,
			tokenIsTSDeclarationStart,
			tokenIsTSTypeOperator,
			tokenIsTemplate
		};
	}
	return acornTypeScript;
}
function generateTsTokenContext() {
	return {
		tc_oTag: new TokContext("<tag", false, false),
		tc_cTag: new TokContext("</tag", false, false),
		tc_expr: new TokContext("<tag>...</tag>", true, true)
	};
}
function generateTsTokenType() {
	return {
		at: new TokenType("@"),
		jsxName: new TokenType("jsxName"),
		jsxText: new TokenType("jsxText", { beforeExpr: true }),
		jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
		jsxTagEnd: new TokenType("jsxTagEnd")
	};
}
function generateTsKwTokenType() {
	return {
		assert: kwLike("assert", { startsExpr }),
		asserts: kwLike("asserts", { startsExpr }),
		global: kwLike("global", { startsExpr }),
		keyof: kwLike("keyof", { startsExpr }),
		readonly: kwLike("readonly", { startsExpr }),
		unique: kwLike("unique", { startsExpr }),
		abstract: kwLike("abstract", { startsExpr }),
		declare: kwLike("declare", { startsExpr }),
		enum: kwLike("enum", { startsExpr }),
		module: kwLike("module", { startsExpr }),
		namespace: kwLike("namespace", { startsExpr }),
		interface: kwLike("interface", { startsExpr }),
		type: kwLike("type", { startsExpr })
	};
}
var TS_SCOPE_OTHER = 512;
var TS_SCOPE_TS_MODULE = 1024;
var BIND_KIND_VALUE = 1;
var BIND_KIND_TYPE = 2;
var BIND_SCOPE_VAR = 4;
var BIND_SCOPE_LEXICAL = 8;
var BIND_SCOPE_FUNCTION = 16;
var BIND_FLAGS_NONE = 64;
var BIND_FLAGS_CLASS = 128;
var BIND_FLAGS_TS_ENUM = 256;
var BIND_FLAGS_TS_CONST_ENUM = 512;
var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
BIND_KIND_TYPE | 0;
var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
0 | BIND_FLAGS_TS_EXPORT_ONLY;
0 | BIND_FLAGS_NONE;
BIND_KIND_VALUE | 0 | BIND_FLAGS_NONE;
BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
0 | BIND_FLAGS_TS_EXPORT_ONLY;
var CLASS_ELEMENT_FLAG_STATIC = 4;
var CLASS_ELEMENT_KIND_GETTER = 2;
var CLASS_ELEMENT_KIND_SETTER = 1;
CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
var DestructuringErrors = class {
	constructor() {
		this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
	}
};
function isPrivateNameConflicted(privateNameMap, element) {
	const name = element.key.name;
	const curr = privateNameMap[name];
	let next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName(node, name) {
	const { computed, key } = node;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
var TypeScriptError = {
	AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
	AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
	AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
	AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
	CannotFindName: ({ name }) => `Cannot find name '${name}'.`,
	ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
	ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
	ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
	ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
	DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
	DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
	DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
	DuplicateAccessibilityModifier: (() => `Accessibility modifier already seen.`),
	DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
	EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
	EmptyTypeArguments: "Type argument list cannot be empty.",
	EmptyTypeParameters: "Type parameter list cannot be empty.",
	ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
	ImportAliasHasImportType: "An import alias can not use 'import type'.",
	IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
	IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
	IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
	IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
	IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
	IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
	InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
	InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
	InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
	InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
	InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
	InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
	InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
	MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
	MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
	NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
	NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
	OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
	OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
	PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
	PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
	PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
	PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,
	ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
	ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
	ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
	SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
	SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
	SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
	SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
	StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
	TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
	TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
	TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
	UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
	UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
	GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,
	UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
	UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
	UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
	UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
	UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
	LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
};
var DecoratorsError = {
	UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
	DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
	TrailingDecorator: "Decorators must be attached to a class element.",
	SpreadElementDecorator: `Decorators can't be used with SpreadElement`
};
function generateParseDecorators(Parse, acornTypeScript, acorn) {
	const { tokTypes: tt } = acorn;
	const { tokTypes: tokTypes2 } = acornTypeScript;
	return class ParseDecorators extends Parse {
		takeDecorators(node) {
			const decorators = this.decoratorStack[this.decoratorStack.length - 1];
			if (decorators.length) {
				node.decorators = decorators;
				this.resetStartLocationFromNode(node, decorators[0]);
				this.decoratorStack[this.decoratorStack.length - 1] = [];
			}
		}
		parseDecorators(allowExport) {
			const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];
			while (this.match(tokTypes2.at)) {
				const decorator = this.parseDecorator();
				currentContextDecorators.push(decorator);
			}
			if (this.match(tt._export)) {
				if (!allowExport) this.unexpected();
			} else if (!this.canHaveLeadingDecorator()) this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);
		}
		parseDecorator() {
			const node = this.startNode();
			this.next();
			this.decoratorStack.push([]);
			const startPos = this.start;
			const startLoc = this.startLoc;
			let expr;
			if (this.match(tt.parenL)) {
				const startPos2 = this.start;
				const startLoc2 = this.startLoc;
				this.next();
				expr = this.parseExpression();
				this.expect(tt.parenR);
				if (this.options.preserveParens) {
					let par = this.startNodeAt(startPos2, startLoc2);
					par.expression = expr;
					expr = this.finishNode(par, "ParenthesizedExpression");
				}
			} else {
				expr = this.parseIdent(false);
				while (this.eat(tt.dot)) {
					const node2 = this.startNodeAt(startPos, startLoc);
					node2.object = expr;
					node2.property = this.parseIdent(true);
					node2.computed = false;
					expr = this.finishNode(node2, "MemberExpression");
				}
			}
			node.expression = this.parseMaybeDecoratorArguments(expr);
			this.decoratorStack.pop();
			return this.finishNode(node, "Decorator");
		}
		parseMaybeDecoratorArguments(expr) {
			if (this.eat(tt.parenL)) {
				const node = this.startNodeAtNode(expr);
				node.callee = expr;
				node.arguments = this.parseExprList(tt.parenR, false);
				return this.finishNode(node, "CallExpression");
			}
			return expr;
		}
	};
}
var xhtml_default = {
	quot: "\"",
	amp: "&",
	apos: "'",
	lt: "<",
	gt: ">",
	nbsp: "\xA0",
	iexcl: "",
	cent: "",
	pound: "",
	curren: "",
	yen: "",
	brvbar: "",
	sect: "",
	uml: "",
	copy: "",
	ordf: "",
	laquo: "",
	not: "",
	shy: "",
	reg: "",
	macr: "",
	deg: "",
	plusmn: "",
	sup2: "",
	sup3: "",
	acute: "",
	micro: "",
	para: "",
	middot: "",
	cedil: "",
	sup1: "",
	ordm: "",
	raquo: "",
	frac14: "",
	frac12: "",
	frac34: "",
	iquest: "",
	Agrave: "",
	Aacute: "",
	Acirc: "",
	Atilde: "",
	Auml: "",
	Aring: "",
	AElig: "",
	Ccedil: "",
	Egrave: "",
	Eacute: "",
	Ecirc: "",
	Euml: "",
	Igrave: "",
	Iacute: "",
	Icirc: "",
	Iuml: "",
	ETH: "",
	Ntilde: "",
	Ograve: "",
	Oacute: "",
	Ocirc: "",
	Otilde: "",
	Ouml: "",
	times: "",
	Oslash: "",
	Ugrave: "",
	Uacute: "",
	Ucirc: "",
	Uuml: "",
	Yacute: "",
	THORN: "",
	szlig: "",
	agrave: "",
	aacute: "",
	acirc: "",
	atilde: "",
	auml: "",
	aring: "",
	aelig: "",
	ccedil: "",
	egrave: "",
	eacute: "",
	ecirc: "",
	euml: "",
	igrave: "",
	iacute: "",
	icirc: "",
	iuml: "",
	eth: "",
	ntilde: "",
	ograve: "",
	oacute: "",
	ocirc: "",
	otilde: "",
	ouml: "",
	divide: "",
	oslash: "",
	ugrave: "",
	uacute: "",
	ucirc: "",
	uuml: "",
	yacute: "",
	thorn: "",
	yuml: "",
	OElig: "",
	oelig: "",
	Scaron: "",
	scaron: "",
	Yuml: "",
	fnof: "",
	circ: "",
	tilde: "",
	Alpha: "",
	Beta: "",
	Gamma: "",
	Delta: "",
	Epsilon: "",
	Zeta: "",
	Eta: "",
	Theta: "",
	Iota: "",
	Kappa: "",
	Lambda: "",
	Mu: "",
	Nu: "",
	Xi: "",
	Omicron: "",
	Pi: "",
	Rho: "",
	Sigma: "",
	Tau: "",
	Upsilon: "",
	Phi: "",
	Chi: "",
	Psi: "",
	Omega: "",
	alpha: "",
	beta: "",
	gamma: "",
	delta: "",
	epsilon: "",
	zeta: "",
	eta: "",
	theta: "",
	iota: "",
	kappa: "",
	lambda: "",
	mu: "",
	nu: "",
	xi: "",
	omicron: "",
	pi: "",
	rho: "",
	sigmaf: "",
	sigma: "",
	tau: "",
	upsilon: "",
	phi: "",
	chi: "",
	psi: "",
	omega: "",
	thetasym: "",
	upsih: "",
	piv: "",
	ensp: "",
	emsp: "",
	thinsp: "",
	zwnj: "",
	zwj: "",
	lrm: "",
	rlm: "",
	ndash: "",
	mdash: "",
	lsquo: "",
	rsquo: "",
	sbquo: "",
	ldquo: "",
	rdquo: "",
	bdquo: "",
	dagger: "",
	Dagger: "",
	bull: "",
	hellip: "",
	permil: "",
	prime: "",
	Prime: "",
	lsaquo: "",
	rsaquo: "",
	oline: "",
	frasl: "",
	euro: "",
	image: "",
	weierp: "",
	real: "",
	trade: "",
	alefsym: "",
	larr: "",
	uarr: "",
	rarr: "",
	darr: "",
	harr: "",
	crarr: "",
	lArr: "",
	uArr: "",
	rArr: "",
	dArr: "",
	hArr: "",
	forall: "",
	part: "",
	exist: "",
	empty: "",
	nabla: "",
	isin: "",
	notin: "",
	ni: "",
	prod: "",
	sum: "",
	minus: "",
	lowast: "",
	radic: "",
	prop: "",
	infin: "",
	ang: "",
	and: "",
	or: "",
	cap: "",
	cup: "",
	int: "",
	there4: "",
	sim: "",
	cong: "",
	asymp: "",
	ne: "",
	equiv: "",
	le: "",
	ge: "",
	sub: "",
	sup: "",
	nsub: "",
	sube: "",
	supe: "",
	oplus: "",
	otimes: "",
	perp: "",
	sdot: "",
	lceil: "",
	rceil: "",
	lfloor: "",
	rfloor: "",
	lang: "",
	rang: "",
	loz: "",
	spades: "",
	clubs: "",
	hearts: "",
	diams: ""
};
var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;
function getQualifiedJSXName(object) {
	if (!object) return object;
	if (object.type === "JSXIdentifier") return object.name;
	if (object.type === "JSXNamespacedName") return object.namespace.name + ":" + object.name.name;
	if (object.type === "JSXMemberExpression") return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
}
function generateJsxParser(acorn, acornTypeScript, Parser$5, jsxOptions) {
	const tt = acorn.tokTypes;
	const tok = acornTypeScript.tokTypes;
	const isNewLine$1 = acorn.isNewLine;
	const isIdentifierChar$1 = acorn.isIdentifierChar;
	const options = Object.assign({
		allowNamespaces: true,
		allowNamespacedObjects: true
	}, jsxOptions || {});
	return class JsxParser extends Parser$5 {
		jsx_readToken() {
			let out = "", chunkStart = this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(this.start, "Unterminated JSX contents");
				let ch = this.input.charCodeAt(this.pos);
				switch (ch) {
					case 60:
					case 123:
						if (this.pos === this.start) {
							if (ch === 60 && this.exprAllowed) {
								++this.pos;
								return this.finishToken(tok.jsxTagStart);
							}
							return this.getTokenFromCode(ch);
						}
						out += this.input.slice(chunkStart, this.pos);
						return this.finishToken(tok.jsxText, out);
					case 38:
						out += this.input.slice(chunkStart, this.pos);
						out += this.jsx_readEntity();
						chunkStart = this.pos;
						break;
					case 62:
					case 125: this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + "` or `{\"" + this.input[this.pos] + "\"}`?");
					default: if (isNewLine$1(ch)) {
						out += this.input.slice(chunkStart, this.pos);
						out += this.jsx_readNewLine(true);
						chunkStart = this.pos;
					} else ++this.pos;
				}
			}
		}
		jsx_readNewLine(normalizeCRLF) {
			let ch = this.input.charCodeAt(this.pos);
			let out;
			++this.pos;
			if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
				++this.pos;
				out = normalizeCRLF ? "\n" : "\r\n";
			} else out = String.fromCharCode(ch);
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			return out;
		}
		jsx_readString(quote$1) {
			let out = "", chunkStart = ++this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
				let ch = this.input.charCodeAt(this.pos);
				if (ch === quote$1) break;
				if (ch === 38) {
					out += this.input.slice(chunkStart, this.pos);
					out += this.jsx_readEntity();
					chunkStart = this.pos;
				} else if (isNewLine$1(ch)) {
					out += this.input.slice(chunkStart, this.pos);
					out += this.jsx_readNewLine(false);
					chunkStart = this.pos;
				} else ++this.pos;
			}
			out += this.input.slice(chunkStart, this.pos++);
			return this.finishToken(tt.string, out);
		}
		jsx_readEntity() {
			let str = "", count = 0, entity;
			let ch = this.input[this.pos];
			if (ch !== "&") this.raise(this.pos, "Entity must start with an ampersand");
			let startPos = ++this.pos;
			while (this.pos < this.input.length && count++ < 10) {
				ch = this.input[this.pos++];
				if (ch === ";") {
					if (str[0] === "#") if (str[1] === "x") {
						str = str.substr(2);
						if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
					} else {
						str = str.substr(1);
						if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
					}
					else entity = xhtml_default[str];
					break;
				}
				str += ch;
			}
			if (!entity) {
				this.pos = startPos;
				return "&";
			}
			return entity;
		}
		jsx_readWord() {
			let ch, start = this.pos;
			do
				ch = this.input.charCodeAt(++this.pos);
			while (isIdentifierChar$1(ch) || ch === 45);
			return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
		}
		jsx_parseIdentifier() {
			let node = this.startNode();
			if (this.type === tok.jsxName) node.name = this.value;
			else if (this.type.keyword) node.name = this.type.keyword;
			else this.unexpected();
			this.next();
			return this.finishNode(node, "JSXIdentifier");
		}
		jsx_parseNamespacedName() {
			let startPos = this.start, startLoc = this.startLoc;
			let name = this.jsx_parseIdentifier();
			if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
			var node = this.startNodeAt(startPos, startLoc);
			node.namespace = name;
			node.name = this.jsx_parseIdentifier();
			return this.finishNode(node, "JSXNamespacedName");
		}
		jsx_parseElementName() {
			if (this.type === tok.jsxTagEnd) return "";
			let startPos = this.start, startLoc = this.startLoc;
			let node = this.jsx_parseNamespacedName();
			if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) this.unexpected();
			while (this.eat(tt.dot)) {
				let newNode = this.startNodeAt(startPos, startLoc);
				newNode.object = node;
				newNode.property = this.jsx_parseIdentifier();
				node = this.finishNode(newNode, "JSXMemberExpression");
			}
			return node;
		}
		jsx_parseAttributeValue() {
			switch (this.type) {
				case tt.braceL:
					let node = this.jsx_parseExpressionContainer();
					if (node.expression.type === "JSXEmptyExpression") this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
					return node;
				case tok.jsxTagStart:
				case tt.string: return this.parseExprAtom();
				default: this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
			}
		}
		jsx_parseEmptyExpression() {
			let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
			return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
		}
		jsx_parseExpressionContainer() {
			let node = this.startNode();
			this.next();
			node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
			this.expect(tt.braceR);
			return this.finishNode(node, "JSXExpressionContainer");
		}
		jsx_parseAttribute() {
			let node = this.startNode();
			if (this.eat(tt.braceL)) {
				this.expect(tt.ellipsis);
				node.argument = this.parseMaybeAssign();
				this.expect(tt.braceR);
				return this.finishNode(node, "JSXSpreadAttribute");
			}
			node.name = this.jsx_parseNamespacedName();
			node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
			return this.finishNode(node, "JSXAttribute");
		}
		jsx_parseOpeningElementAt(startPos, startLoc) {
			let node = this.startNodeAt(startPos, startLoc);
			node.attributes = [];
			let nodeName = this.jsx_parseElementName();
			if (nodeName) node.name = nodeName;
			while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());
			node.selfClosing = this.eat(tt.slash);
			this.expect(tok.jsxTagEnd);
			return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
		}
		jsx_parseClosingElementAt(startPos, startLoc) {
			let node = this.startNodeAt(startPos, startLoc);
			let nodeName = this.jsx_parseElementName();
			if (nodeName) node.name = nodeName;
			this.expect(tok.jsxTagEnd);
			return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
		}
		jsx_parseElementAt(startPos, startLoc) {
			let node = this.startNodeAt(startPos, startLoc);
			let children = [];
			let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
			let closingElement = null;
			if (!openingElement.selfClosing) {
				contents: for (;;) switch (this.type) {
					case tok.jsxTagStart:
						startPos = this.start;
						startLoc = this.startLoc;
						this.next();
						if (this.eat(tt.slash)) {
							closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
							break contents;
						}
						children.push(this.jsx_parseElementAt(startPos, startLoc));
						break;
					case tok.jsxText:
						children.push(this.parseExprAtom());
						break;
					case tt.braceL:
						children.push(this.jsx_parseExpressionContainer());
						break;
					default: this.unexpected();
				}
				if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
			}
			let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
			node["opening" + fragmentOrElement] = openingElement;
			node["closing" + fragmentOrElement] = closingElement;
			node.children = children;
			if (this.type === tt.relational && this.value === "<") this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
			return this.finishNode(node, "JSX" + fragmentOrElement);
		}
		jsx_parseText() {
			let node = this.parseLiteral(this.value);
			node.type = "JSXText";
			return node;
		}
		jsx_parseElement() {
			let startPos = this.start, startLoc = this.startLoc;
			this.next();
			return this.jsx_parseElementAt(startPos, startLoc);
		}
	};
}
function generateParseImportAssertions(Parse, acornTypeScript, acorn) {
	const { tokTypes: tokTypes2 } = acornTypeScript;
	const { tokTypes: tt } = acorn;
	return class ImportAttributes extends Parse {
		parseMaybeImportAttributes(node) {
			if (this.type === tt._with || this.type === tokTypes2.assert) {
				this.next();
				const attributes = this.parseImportAttributes();
				if (attributes) node.attributes = attributes;
			}
		}
		parseImportAttributes() {
			this.expect(tt.braceL);
			const attrs = this.parseWithEntries();
			this.expect(tt.braceR);
			return attrs;
		}
		parseWithEntries() {
			const attrs = [];
			const attrNames = /* @__PURE__ */ new Set();
			do {
				if (this.type === tt.braceR) break;
				const node = this.startNode();
				let withionKeyNode;
				if (this.type === tt.string) withionKeyNode = this.parseLiteral(this.value);
				else withionKeyNode = this.parseIdent(true);
				this.next();
				node.key = withionKeyNode;
				if (attrNames.has(node.key.name)) this.raise(this.pos, "Duplicated key in attributes");
				attrNames.add(node.key.name);
				if (this.type !== tt.string) this.raise(this.pos, "Only string is supported as an attribute value");
				node.value = this.parseLiteral(this.value);
				attrs.push(this.finishNode(node, "ImportAttribute"));
			} while (this.eat(tt.comma));
			return attrs;
		}
	};
}
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function assert(x$3) {
	if (!x$3) throw new Error("Assert fail");
}
function tsIsClassAccessor(modifier) {
	return modifier === "accessor";
}
function tsIsVarianceAnnotations(modifier) {
	return modifier === "in" || modifier === "out";
}
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
var acornScope = {
	SCOPE_TOP: 1,
	SCOPE_FUNCTION: 2,
	SCOPE_ASYNC: 4,
	SCOPE_GENERATOR: 8,
	SCOPE_ARROW: 16,
	SCOPE_SIMPLE_CATCH: 32,
	SCOPE_SUPER: 64,
	SCOPE_DIRECT_SUPER: 128,
	SCOPE_CLASS_STATIC_BLOCK: 256,
	SCOPE_VAR: 256,
	BIND_NONE: 0,
	BIND_VAR: 1,
	BIND_LEXICAL: 2,
	BIND_FUNCTION: 3,
	BIND_SIMPLE_CATCH: 4,
	BIND_OUTSIDE: 5,
	BIND_TS_TYPE: 6,
	BIND_TS_INTERFACE: 7,
	BIND_TS_NAMESPACE: 8,
	BIND_FLAGS_TS_EXPORT_ONLY: 1024,
	BIND_FLAGS_TS_IMPORT: 4096,
	BIND_FLAGS_TS_ENUM: 256,
	BIND_FLAGS_TS_CONST_ENUM: 512,
	BIND_FLAGS_CLASS: 128
};
function functionFlags(async, generator) {
	return acornScope.SCOPE_FUNCTION | (async ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);
}
function isPossiblyLiteralEnum(expression) {
	if (expression.type !== "MemberExpression") return false;
	const { computed, property } = expression;
	if (computed && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) return false;
	return isUncomputedMemberExpressionChain(expression.object);
}
function isUncomputedMemberExpressionChain(expression) {
	if (expression.type === "Identifier") return true;
	if (expression.type !== "MemberExpression") return false;
	if (expression.computed) return false;
	return isUncomputedMemberExpressionChain(expression.object);
}
function tsIsAccessModifier(modifier) {
	return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tokenCanStartExpression(token) {
	return Boolean(token.startsExpr);
}
function nonNull(x$3) {
	if (x$3 == null) throw new Error(`Unexpected ${x$3} value.`);
	return x$3;
}
function keywordTypeFromName(value) {
	switch (value) {
		case "any": return "TSAnyKeyword";
		case "boolean": return "TSBooleanKeyword";
		case "bigint": return "TSBigIntKeyword";
		case "never": return "TSNeverKeyword";
		case "number": return "TSNumberKeyword";
		case "object": return "TSObjectKeyword";
		case "string": return "TSStringKeyword";
		case "symbol": return "TSSymbolKeyword";
		case "undefined": return "TSUndefinedKeyword";
		case "unknown": return "TSUnknownKeyword";
		default: return;
	}
}
function tsPlugin(options) {
	const { dts = false } = options || {};
	const disallowAmbiguousJSXLike = !!options?.jsx;
	return function(Parser$5) {
		const _acorn = Parser$5.acorn || acorn_exports;
		const acornTypeScript = generateAcornTypeScript(_acorn);
		const tt = _acorn.tokTypes;
		const keywordTypes2 = _acorn.keywordTypes;
		const isIdentifierStart$1 = _acorn.isIdentifierStart;
		const lineBreak$1 = _acorn.lineBreak;
		const isNewLine$1 = _acorn.isNewLine;
		const tokContexts = _acorn.tokContexts;
		const isIdentifierChar$1 = _acorn.isIdentifierChar;
		const { tokTypes: tokTypes2, tokContexts: tsTokContexts, keywordsRegExp, tokenIsLiteralPropertyName, tokenIsTemplate, tokenIsTSDeclarationStart, tokenIsIdentifier, tokenIsKeywordOrIdentifier, tokenIsTSTypeOperator } = acornTypeScript;
		function nextLineBreak$1(code, from$1, end = code.length) {
			for (let i$1 = from$1; i$1 < end; i$1++) {
				let next = code.charCodeAt(i$1);
				if (isNewLine$1(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
			}
			return -1;
		}
		Parser$5 = generateParseDecorators(Parser$5, acornTypeScript, _acorn);
		if (options?.jsx) Parser$5 = generateJsxParser(_acorn, acornTypeScript, Parser$5, typeof options.jsx === "boolean" ? {} : options.jsx);
		Parser$5 = generateParseImportAssertions(Parser$5, acornTypeScript, _acorn);
		class TypeScriptParser extends Parser$5 {
			constructor(options2, input, startPos) {
				super(options2, input, startPos);
				this.preValue = null;
				this.preToken = null;
				this.isLookahead = false;
				this.isAmbientContext = false;
				this.inAbstractClass = false;
				this.inType = false;
				this.inDisallowConditionalTypesContext = false;
				this.maybeInArrowParameters = false;
				this.shouldParseArrowReturnType = void 0;
				this.shouldParseAsyncArrowReturnType = void 0;
				this.decoratorStack = [[]];
				this.importsStack = [[]];
				/**
				* we will only parse one import node or export node at same time.
				* default kind is undefined
				* */
				this.importOrExportOuterKind = void 0;
				this.tsParseConstModifier = (node) => {
					this.tsParseModifiers({
						modified: node,
						allowedModifiers: ["const"],
						disallowedModifiers: ["in", "out"],
						errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
					});
				};
				this.ecmaVersion = this.options.ecmaVersion;
			}
			static get acornTypeScript() {
				return acornTypeScript;
			}
			get acornTypeScript() {
				return acornTypeScript;
			}
			getTokenFromCodeInType(code) {
				if (code === 62) return this.finishOp(tt.relational, 1);
				if (code === 60) return this.finishOp(tt.relational, 1);
				return super.getTokenFromCode(code);
			}
			readToken(code) {
				if (!this.inType) {
					let context = this.curContext();
					if (context === tsTokContexts.tc_expr) return this.jsx_readToken();
					if (context === tsTokContexts.tc_oTag || context === tsTokContexts.tc_cTag) {
						if (isIdentifierStart$1(code)) return this.jsx_readWord();
						if (code == 62) {
							++this.pos;
							return this.finishToken(tokTypes2.jsxTagEnd);
						}
						if ((code === 34 || code === 39) && context == tsTokContexts.tc_oTag) return this.jsx_readString(code);
					}
					if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
						++this.pos;
						if (options?.jsx) return this.finishToken(tokTypes2.jsxTagStart);
						else return this.finishToken(tt.relational, "<");
					}
				}
				return super.readToken(code);
			}
			getTokenFromCode(code) {
				if (this.inType) return this.getTokenFromCodeInType(code);
				if (code === 64) {
					++this.pos;
					return this.finishToken(tokTypes2.at);
				}
				return super.getTokenFromCode(code);
			}
			isAbstractClass() {
				return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._class;
			}
			finishNode(node, type) {
				if (node.type !== "" && node.end !== 0) return node;
				return super.finishNode(node, type);
			}
			tryParse(fn, oldState = this.cloneCurLookaheadState()) {
				const abortSignal = { node: null };
				try {
					return {
						node: fn((node2 = null) => {
							abortSignal.node = node2;
							throw abortSignal;
						}),
						error: null,
						thrown: false,
						aborted: false,
						failState: null
					};
				} catch (error) {
					const failState = this.getCurLookaheadState();
					this.setLookaheadState(oldState);
					if (error instanceof SyntaxError) return {
						node: null,
						error,
						thrown: true,
						aborted: false,
						failState
					};
					if (error === abortSignal) return {
						node: abortSignal.node,
						error: null,
						thrown: false,
						aborted: true,
						failState
					};
					throw error;
				}
			}
			setOptionalParametersError(refExpressionErrors, resultError) {
				refExpressionErrors.optionalParametersLoc = resultError?.loc ?? this.startLoc;
			}
			reScan_lt_gt() {
				if (this.type === tt.relational) {
					this.pos -= 1;
					this.readToken_lt_gt(this.fullCharCodeAtPos());
				}
			}
			reScan_lt() {
				const { type } = this;
				if (type === tt.bitShift) {
					this.pos -= 2;
					this.finishOp(tt.relational, 1);
					return tt.relational;
				}
				return type;
			}
			resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {
				node.end = endPos;
				node.loc.end = endLoc;
				if (this.options.ranges) node.range[1] = endPos;
			}
			startNodeAtNode(type) {
				return super.startNodeAt(type.start, type.loc.start);
			}
			nextTokenStart() {
				return this.nextTokenStartSince(this.pos);
			}
			tsHasSomeModifiers(member, modifiers) {
				return modifiers.some((modifier) => {
					if (tsIsAccessModifier(modifier)) return member.accessibility === modifier;
					return !!member[modifier];
				});
			}
			tsIsStartOfStaticBlocks() {
				return this.isContextual("static") && this.lookaheadCharCode() === 123;
			}
			tsCheckForInvalidTypeCasts(items) {
				items.forEach((node) => {
					if (node?.type === "TSTypeCastExpression") this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);
				});
			}
			atPossibleAsyncArrow(base) {
				return base.type === "Identifier" && base.name === "async" && this.lastTokEndLoc.column === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;
			}
			tsIsIdentifier() {
				return tokenIsIdentifier(this.type);
			}
			tsTryParseTypeOrTypePredicateAnnotation() {
				return this.match(tt.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon) : void 0;
			}
			tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {
				if (!this.tsMatchLeftRelational()) return;
				const oldMaybeInArrowParameters = this.maybeInArrowParameters;
				this.maybeInArrowParameters = true;
				const res = this.tsTryParseAndCatch(() => {
					const node = this.startNodeAt(startPos, startLoc);
					node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
					super.parseFunctionParams(node);
					node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
					this.expect(tt.arrow);
					return node;
				});
				this.maybeInArrowParameters = oldMaybeInArrowParameters;
				if (!res) return;
				return super.parseArrowExpression(res, null, true, forInit);
			}
			tsParseTypeArgumentsInExpression() {
				if (this.reScan_lt() !== tt.relational) return;
				return this.tsParseTypeArguments();
			}
			tsInNoContext(cb) {
				const oldContext = this.context;
				this.context = [oldContext[0]];
				try {
					return cb();
				} finally {
					this.context = oldContext;
				}
			}
			tsTryParseTypeAnnotation() {
				return this.match(tt.colon) ? this.tsParseTypeAnnotation() : void 0;
			}
			isUnparsedContextual(nameStart, name) {
				const nameEnd = nameStart + name.length;
				if (this.input.slice(nameStart, nameEnd) === name) {
					const nextCh = this.input.charCodeAt(nameEnd);
					return !(isIdentifierChar$1(nextCh) || (nextCh & 64512) === 55296);
				}
				return false;
			}
			isAbstractConstructorSignature() {
				return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._new;
			}
			nextTokenStartSince(pos) {
				skipWhiteSpace.lastIndex = pos;
				return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
			}
			lookaheadCharCode() {
				return this.input.charCodeAt(this.nextTokenStart());
			}
			compareLookaheadState(state, state2) {
				for (const key of Object.keys(state)) if (state[key] !== state2[key]) return false;
				return true;
			}
			createLookaheadState() {
				this.value = null;
				this.context = [this.curContext()];
			}
			getCurLookaheadState() {
				return {
					endLoc: this.endLoc,
					lastTokEnd: this.lastTokEnd,
					lastTokStart: this.lastTokStart,
					lastTokStartLoc: this.lastTokStartLoc,
					pos: this.pos,
					value: this.value,
					type: this.type,
					start: this.start,
					end: this.end,
					context: this.context,
					startLoc: this.startLoc,
					lastTokEndLoc: this.lastTokEndLoc,
					curLine: this.curLine,
					lineStart: this.lineStart,
					curPosition: this.curPosition,
					containsEsc: this.containsEsc
				};
			}
			cloneCurLookaheadState() {
				return {
					pos: this.pos,
					value: this.value,
					type: this.type,
					start: this.start,
					end: this.end,
					context: this.context && this.context.slice(),
					startLoc: this.startLoc,
					lastTokEndLoc: this.lastTokEndLoc,
					endLoc: this.endLoc,
					lastTokEnd: this.lastTokEnd,
					lastTokStart: this.lastTokStart,
					lastTokStartLoc: this.lastTokStartLoc,
					curLine: this.curLine,
					lineStart: this.lineStart,
					curPosition: this.curPosition,
					containsEsc: this.containsEsc
				};
			}
			setLookaheadState(state) {
				this.pos = state.pos;
				this.value = state.value;
				this.endLoc = state.endLoc;
				this.lastTokEnd = state.lastTokEnd;
				this.lastTokStart = state.lastTokStart;
				this.lastTokStartLoc = state.lastTokStartLoc;
				this.type = state.type;
				this.start = state.start;
				this.end = state.end;
				this.context = state.context;
				this.startLoc = state.startLoc;
				this.lastTokEndLoc = state.lastTokEndLoc;
				this.curLine = state.curLine;
				this.lineStart = state.lineStart;
				this.curPosition = state.curPosition;
				this.containsEsc = state.containsEsc;
			}
			tsLookAhead(f$2) {
				const state = this.getCurLookaheadState();
				const res = f$2();
				this.setLookaheadState(state);
				return res;
			}
			lookahead(number) {
				const oldState = this.getCurLookaheadState();
				this.createLookaheadState();
				this.isLookahead = true;
				if (number !== void 0) for (let i$1 = 0; i$1 < number; i$1++) this.nextToken();
				else this.nextToken();
				this.isLookahead = false;
				const curState = this.getCurLookaheadState();
				this.setLookaheadState(oldState);
				return curState;
			}
			readWord() {
				let word = this.readWord1();
				let type = tt.name;
				if (this.keywords.test(word)) type = keywordTypes2[word];
				else if (new RegExp(keywordsRegExp).test(word)) type = tokTypes2[word];
				return this.finishToken(type, word);
			}
			skipBlockComment() {
				let startLoc;
				if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
				let start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
				if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
				this.pos = end + 2;
				if (this.options.locations) for (let nextBreak, pos = start; (nextBreak = nextLineBreak$1(this.input, pos, this.pos)) > -1;) {
					++this.curLine;
					pos = this.lineStart = nextBreak;
				}
				if (this.isLookahead) return;
				if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
			}
			skipLineComment(startSkip) {
				let start = this.pos;
				let startLoc;
				if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
				let ch = this.input.charCodeAt(this.pos += startSkip);
				while (this.pos < this.input.length && !isNewLine$1(ch)) ch = this.input.charCodeAt(++this.pos);
				if (this.isLookahead) return;
				if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
			}
			finishToken(type, val) {
				this.preValue = this.value;
				this.preToken = this.type;
				this.end = this.pos;
				if (this.options.locations) this.endLoc = this.curPosition();
				let prevType = this.type;
				this.type = type;
				this.value = val;
				if (!this.isLookahead) this.updateContext(prevType);
			}
			resetStartLocation(node, start, startLoc) {
				node.start = start;
				node.loc.start = startLoc;
				if (this.options.ranges) node.range[0] = start;
			}
			isLineTerminator() {
				return this.eat(tt.semi) || super.canInsertSemicolon();
			}
			hasFollowingLineBreak() {
				skipWhiteSpaceToLineBreak.lastIndex = this.end;
				return skipWhiteSpaceToLineBreak.test(this.input);
			}
			addExtra(node, key, value, enumerable = true) {
				if (!node) return;
				const extra = node.extra = node.extra || {};
				if (enumerable) extra[key] = value;
				else Object.defineProperty(extra, key, {
					enumerable,
					value
				});
			}
			/**
			* Test if current token is a literal property name
			* https://tc39.es/ecma262/#prod-LiteralPropertyName
			* LiteralPropertyName:
			*   IdentifierName
			*   StringLiteral
			*   NumericLiteral
			*   BigIntLiteral
			*/
			isLiteralPropertyName() {
				return tokenIsLiteralPropertyName(this.type);
			}
			hasPrecedingLineBreak() {
				return lineBreak$1.test(this.input.slice(this.lastTokEnd, this.start));
			}
			createIdentifier(node, name) {
				node.name = name;
				return this.finishNode(node, "Identifier");
			}
			/**
			* Reset the start location of node to the start location of locationNode
			*/
			resetStartLocationFromNode(node, locationNode) {
				this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
			}
			isThisParam(param) {
				return param.type === "Identifier" && param.name === "this";
			}
			isLookaheadContextual(name) {
				const next = this.nextTokenStart();
				return this.isUnparsedContextual(next, name);
			}
			/**
			* ts type isContextual
			* @param {TokenType} type
			* @param {TokenType} token
			* @returns {boolean}
			* */
			ts_type_isContextual(type, token) {
				return type === token && !this.containsEsc;
			}
			/**
			* ts isContextual
			* @param {TokenType} token
			* @returns {boolean}
			* */
			ts_isContextual(token) {
				return this.type === token && !this.containsEsc;
			}
			ts_isContextualWithState(state, token) {
				return state.type === token && !state.containsEsc;
			}
			isContextualWithState(keyword, state) {
				return state.type === tt.name && state.value === keyword && !state.containsEsc;
			}
			tsIsStartOfMappedType() {
				this.next();
				if (this.eat(tt.plusMin)) return this.ts_isContextual(tokTypes2.readonly);
				if (this.ts_isContextual(tokTypes2.readonly)) this.next();
				if (!this.match(tt.bracketL)) return false;
				this.next();
				if (!this.tsIsIdentifier()) return false;
				this.next();
				return this.match(tt._in);
			}
			tsInDisallowConditionalTypesContext(cb) {
				const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
				this.inDisallowConditionalTypesContext = true;
				try {
					return cb();
				} finally {
					this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
				}
			}
			tsTryParseType() {
				return this.tsEatThenParseType(tt.colon);
			}
			/**
			* Whether current token matches given type
			*
			* @param {TokenType} type
			* @returns {boolean}
			* @memberof Tokenizer
			*/
			match(type) {
				return this.type === type;
			}
			matchJsx(type) {
				return this.type === acornTypeScript.tokTypes[type];
			}
			ts_eatWithState(type, nextCount, state) {
				const targetType = state.type;
				if (type === targetType) {
					for (let i$1 = 0; i$1 < nextCount; i$1++) this.next();
					return true;
				} else return false;
			}
			ts_eatContextualWithState(name, nextCount, state) {
				if (keywordsRegExp.test(name)) {
					if (this.ts_isContextualWithState(state, tokTypes2[name])) {
						for (let i$1 = 0; i$1 < nextCount; i$1++) this.next();
						return true;
					}
					return false;
				} else {
					if (!this.isContextualWithState(name, state)) return false;
					for (let i$1 = 0; i$1 < nextCount; i$1++) this.next();
					return true;
				}
			}
			canHaveLeadingDecorator() {
				return this.match(tt._class);
			}
			eatContextual(name) {
				if (keywordsRegExp.test(name)) {
					if (this.ts_isContextual(tokTypes2[name])) {
						this.next();
						return true;
					}
					return false;
				} else return super.eatContextual(name);
			}
			tsIsExternalModuleReference() {
				return this.isContextual("require") && this.lookaheadCharCode() === 40;
			}
			tsParseExternalModuleReference() {
				const node = this.startNode();
				this.expectContextual("require");
				this.expect(tt.parenL);
				if (!this.match(tt.string)) this.unexpected();
				node.expression = this.parseExprAtom();
				this.expect(tt.parenR);
				return this.finishNode(node, "TSExternalModuleReference");
			}
			tsParseEntityName(allowReservedWords = true) {
				let entity = this.parseIdent(allowReservedWords);
				while (this.eat(tt.dot)) {
					const node = this.startNodeAtNode(entity);
					node.left = entity;
					node.right = this.parseIdent(allowReservedWords);
					entity = this.finishNode(node, "TSQualifiedName");
				}
				return entity;
			}
			tsParseEnumMember() {
				const node = this.startNode();
				node.id = this.match(tt.string) ? this.parseLiteral(this.value) : this.parseIdent(true);
				if (this.eat(tt.eq)) node.initializer = this.parseMaybeAssign();
				return this.finishNode(node, "TSEnumMember");
			}
			tsParseEnumDeclaration(node, properties = {}) {
				if (properties.const) node.const = true;
				if (properties.declare) node.declare = true;
				this.expectContextual("enum");
				node.id = this.parseIdent();
				this.checkLValSimple(node.id);
				this.expect(tt.braceL);
				node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
				this.expect(tt.braceR);
				return this.finishNode(node, "TSEnumDeclaration");
			}
			tsParseModuleBlock() {
				const node = this.startNode();
				this.enterScope(TS_SCOPE_OTHER);
				this.expect(tt.braceL);
				node.body = [];
				while (this.type !== tt.braceR) {
					let stmt = this.parseStatement(null, true);
					node.body.push(stmt);
				}
				this.next();
				super.exitScope();
				return this.finishNode(node, "TSModuleBlock");
			}
			tsParseAmbientExternalModuleDeclaration(node) {
				if (this.ts_isContextual(tokTypes2.global)) {
					node.global = true;
					node.id = this.parseIdent();
				} else if (this.match(tt.string)) node.id = this.parseLiteral(this.value);
				else this.unexpected();
				if (this.match(tt.braceL)) {
					this.enterScope(TS_SCOPE_TS_MODULE);
					node.body = this.tsParseModuleBlock();
					super.exitScope();
				} else super.semicolon();
				return this.finishNode(node, "TSModuleDeclaration");
			}
			tsTryParseDeclare(nany) {
				if (this.isLineTerminator()) return;
				let starttype = this.type;
				let kind;
				if (this.isContextual("let")) {
					starttype = tt._var;
					kind = "let";
				}
				return this.tsInAmbientContext(() => {
					if (starttype === tt._function) {
						nany.declare = true;
						return this.parseFunctionStatement(nany, false, true);
					}
					if (starttype === tt._class) {
						nany.declare = true;
						return this.parseClass(nany, true);
					}
					if (starttype === tokTypes2.enum) return this.tsParseEnumDeclaration(nany, { declare: true });
					if (starttype === tokTypes2.global) return this.tsParseAmbientExternalModuleDeclaration(nany);
					if (starttype === tt._const || starttype === tt._var) {
						if (!this.match(tt._const) || !this.isLookaheadContextual("enum")) {
							nany.declare = true;
							return this.parseVarStatement(nany, kind || this.value, true);
						}
						this.expect(tt._const);
						return this.tsParseEnumDeclaration(nany, {
							const: true,
							declare: true
						});
					}
					if (starttype === tokTypes2.interface) {
						const result = this.tsParseInterfaceDeclaration(nany, { declare: true });
						if (result) return result;
					}
					if (tokenIsIdentifier(starttype)) return this.tsParseDeclaration(nany, this.value, true);
				});
			}
			tsIsListTerminator(kind) {
				switch (kind) {
					case "EnumMembers":
					case "TypeMembers": return this.match(tt.braceR);
					case "HeritageClauseElement": return this.match(tt.braceL);
					case "TupleElementTypes": return this.match(tt.bracketR);
					case "TypeParametersOrArguments": return this.tsMatchRightRelational();
				}
			}
			/**
			* If !expectSuccess, returns undefined instead of failing to parse.
			* If expectSuccess, parseElement should always return a defined value.
			*/
			tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
				const result = [];
				let trailingCommaPos = -1;
				for (;;) {
					if (this.tsIsListTerminator(kind)) break;
					trailingCommaPos = -1;
					const element = parseElement();
					if (element == null) return;
					result.push(element);
					if (this.eat(tt.comma)) {
						trailingCommaPos = this.lastTokStart;
						continue;
					}
					if (this.tsIsListTerminator(kind)) break;
					if (expectSuccess) this.expect(tt.comma);
					return;
				}
				if (refTrailingCommaPos) refTrailingCommaPos.value = trailingCommaPos;
				return result;
			}
			tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
				return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
			}
			tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
				if (!skipFirstToken) if (bracket) this.expect(tt.bracketL);
				else this.expect(tt.relational);
				const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
				if (bracket) this.expect(tt.bracketR);
				else this.expect(tt.relational);
				return result;
			}
			tsParseTypeParameterName() {
				return this.parseIdent().name;
			}
			tsEatThenParseType(token) {
				return !this.match(token) ? void 0 : this.tsNextThenParseType();
			}
			tsExpectThenParseType(token) {
				return this.tsDoThenParseType(() => this.expect(token));
			}
			tsNextThenParseType() {
				return this.tsDoThenParseType(() => this.next());
			}
			tsDoThenParseType(cb) {
				return this.tsInType(() => {
					cb();
					return this.tsParseType();
				});
			}
			tsSkipParameterStart() {
				if (tokenIsIdentifier(this.type) || this.match(tt._this)) {
					this.next();
					return true;
				}
				if (this.match(tt.braceL)) try {
					this.parseObj(true);
					return true;
				} catch {
					return false;
				}
				if (this.match(tt.bracketL)) {
					this.next();
					try {
						this.parseBindingList(tt.bracketR, true, true);
						return true;
					} catch {
						return false;
					}
				}
				return false;
			}
			tsIsUnambiguouslyStartOfFunctionType() {
				this.next();
				if (this.match(tt.parenR) || this.match(tt.ellipsis)) return true;
				if (this.tsSkipParameterStart()) {
					if (this.match(tt.colon) || this.match(tt.comma) || this.match(tt.question) || this.match(tt.eq)) return true;
					if (this.match(tt.parenR)) {
						this.next();
						if (this.match(tt.arrow)) return true;
					}
				}
				return false;
			}
			tsIsStartOfFunctionType() {
				if (this.tsMatchLeftRelational()) return true;
				return this.match(tt.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
			}
			tsInAllowConditionalTypesContext(cb) {
				const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
				this.inDisallowConditionalTypesContext = false;
				try {
					return cb();
				} finally {
					this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
				}
			}
			tsParseBindingListForSignature() {
				return super.parseBindingList(tt.parenR, true, true).map((pattern) => {
					if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") this.raise(pattern.start, TypeScriptError.UnsupportedSignatureParameterKind(pattern.type));
					return pattern;
				});
			}
			tsParseTypePredicateAsserts() {
				if (this.type !== tokTypes2.asserts) return false;
				const containsEsc = this.containsEsc;
				this.next();
				if (!tokenIsIdentifier(this.type) && !this.match(tt._this)) return false;
				if (containsEsc) this.raise(this.lastTokStart, "Escape sequence in keyword asserts");
				return true;
			}
			tsParseThisTypeNode() {
				const node = this.startNode();
				this.next();
				return this.finishNode(node, "TSThisType");
			}
			tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
				this.tsInType(() => {
					if (eatColon) this.expect(tt.colon);
					t.typeAnnotation = this.tsParseType();
				});
				return this.finishNode(t, "TSTypeAnnotation");
			}
			tsParseThisTypePredicate(lhs) {
				this.next();
				const node = this.startNodeAtNode(lhs);
				node.parameterName = lhs;
				node.typeAnnotation = this.tsParseTypeAnnotation(false);
				node.asserts = false;
				return this.finishNode(node, "TSTypePredicate");
			}
			tsParseThisTypeOrThisTypePredicate() {
				const thisKeyword = this.tsParseThisTypeNode();
				if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.tsParseThisTypePredicate(thisKeyword);
				else return thisKeyword;
			}
			tsParseTypePredicatePrefix() {
				const id = this.parseIdent();
				if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
					this.next();
					return id;
				}
			}
			tsParseTypeOrTypePredicateAnnotation(returnToken) {
				return this.tsInType(() => {
					const t = this.startNode();
					this.expect(returnToken);
					const node = this.startNode();
					const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
					if (asserts && this.match(tt._this)) {
						let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
						if (thisTypePredicate.type === "TSThisType") {
							node.parameterName = thisTypePredicate;
							node.asserts = true;
							node.typeAnnotation = null;
							thisTypePredicate = this.finishNode(node, "TSTypePredicate");
						} else {
							this.resetStartLocationFromNode(thisTypePredicate, node);
							thisTypePredicate.asserts = true;
						}
						t.typeAnnotation = thisTypePredicate;
						return this.finishNode(t, "TSTypeAnnotation");
					}
					const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
					if (!typePredicateVariable) {
						if (!asserts) return this.tsParseTypeAnnotation(false, t);
						node.parameterName = this.parseIdent();
						node.asserts = asserts;
						node.typeAnnotation = null;
						t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
						return this.finishNode(t, "TSTypeAnnotation");
					}
					const type = this.tsParseTypeAnnotation(false);
					node.parameterName = typePredicateVariable;
					node.typeAnnotation = type;
					node.asserts = asserts;
					t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
					return this.finishNode(t, "TSTypeAnnotation");
				});
			}
			tsFillSignature(returnToken, signature) {
				const returnTokenRequired = returnToken === tt.arrow;
				const paramsKey = "parameters";
				const returnTypeKey = "typeAnnotation";
				signature.typeParameters = this.tsTryParseTypeParameters();
				this.expect(tt.parenL);
				signature[paramsKey] = this.tsParseBindingListForSignature();
				if (returnTokenRequired) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
				else if (this.match(returnToken)) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
			}
			tsTryNextParseConstantContext() {
				if (this.lookahead().type !== tt._const) return null;
				this.next();
				const typeReference = this.tsParseTypeReference();
				if (typeReference.typeParameters || typeReference.typeArguments) this.raise(typeReference.typeName.start, TypeScriptError.CannotFindName({ name: "const" }));
				return typeReference;
			}
			tsParseFunctionOrConstructorType(type, abstract) {
				const node = this.startNode();
				if (type === "TSConstructorType") {
					node.abstract = !!abstract;
					if (abstract) this.next();
					this.next();
				}
				this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt.arrow, node));
				return this.finishNode(node, type);
			}
			tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
				const node = this.startNode();
				const hasLeadingOperator = this.eat(operator);
				const types$2 = [];
				do
					types$2.push(parseConstituentType());
				while (this.eat(operator));
				if (types$2.length === 1 && !hasLeadingOperator) return types$2[0];
				node.types = types$2;
				return this.finishNode(node, kind);
			}
			tsCheckTypeAnnotationForReadOnly(node) {
				switch (node.typeAnnotation.type) {
					case "TSTupleType":
					case "TSArrayType": return;
					default: this.raise(node.start, TypeScriptError.UnexpectedReadonly);
				}
			}
			tsParseTypeOperator() {
				const node = this.startNode();
				const operator = this.value;
				this.next();
				node.operator = operator;
				node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
				if (operator === "readonly") this.tsCheckTypeAnnotationForReadOnly(node);
				return this.finishNode(node, "TSTypeOperator");
			}
			tsParseConstraintForInferType() {
				if (this.eat(tt._extends)) {
					const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
					if (this.inDisallowConditionalTypesContext || !this.match(tt.question)) return constraint;
				}
			}
			tsParseInferType() {
				const node = this.startNode();
				this.expectContextual("infer");
				const typeParameter = this.startNode();
				typeParameter.name = this.tsParseTypeParameterName();
				typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
				node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
				return this.finishNode(node, "TSInferType");
			}
			tsParseLiteralTypeNode() {
				const node = this.startNode();
				node.literal = (() => {
					switch (this.type) {
						case tt.num:
						case tt.string:
						case tt._true:
						case tt._false: return this.parseExprAtom();
						default: this.unexpected();
					}
				})();
				return this.finishNode(node, "TSLiteralType");
			}
			tsParseImportType() {
				const node = this.startNode();
				this.expect(tt._import);
				this.expect(tt.parenL);
				if (!this.match(tt.string)) this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);
				node.argument = this.parseExprAtom();
				this.expect(tt.parenR);
				if (this.eat(tt.dot)) node.qualifier = this.tsParseEntityName();
				if (this.tsMatchLeftRelational()) node.typeArguments = this.tsParseTypeArguments();
				return this.finishNode(node, "TSImportType");
			}
			tsParseTypeQuery() {
				const node = this.startNode();
				this.expect(tt._typeof);
				if (this.match(tt._import)) node.exprName = this.tsParseImportType();
				else node.exprName = this.tsParseEntityName();
				if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) node.typeArguments = this.tsParseTypeArguments();
				return this.finishNode(node, "TSTypeQuery");
			}
			tsParseMappedTypeParameter() {
				const node = this.startNode();
				node.name = this.tsParseTypeParameterName();
				node.constraint = this.tsExpectThenParseType(tt._in);
				return this.finishNode(node, "TSTypeParameter");
			}
			tsParseMappedType() {
				const node = this.startNode();
				this.expect(tt.braceL);
				if (this.match(tt.plusMin)) {
					node.readonly = this.value;
					this.next();
					this.expectContextual("readonly");
				} else if (this.eatContextual("readonly")) node.readonly = true;
				this.expect(tt.bracketL);
				node.typeParameter = this.tsParseMappedTypeParameter();
				node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
				this.expect(tt.bracketR);
				if (this.match(tt.plusMin)) {
					node.optional = this.value;
					this.next();
					this.expect(tt.question);
				} else if (this.eat(tt.question)) node.optional = true;
				node.typeAnnotation = this.tsTryParseType();
				this.semicolon();
				this.expect(tt.braceR);
				return this.finishNode(node, "TSMappedType");
			}
			tsParseTypeLiteral() {
				const node = this.startNode();
				node.members = this.tsParseObjectTypeMembers();
				return this.finishNode(node, "TSTypeLiteral");
			}
			tsParseTupleElementType() {
				const startLoc = this.startLoc;
				const startPos = this["start"];
				const rest = this.eat(tt.ellipsis);
				let type = this.tsParseType();
				const optional = this.eat(tt.question);
				if (this.eat(tt.colon)) {
					const labeledNode = this.startNodeAtNode(type);
					labeledNode.optional = optional;
					if (type.type === "TSTypeReference" && !type.typeArguments && type.typeName.type === "Identifier") labeledNode.label = type.typeName;
					else {
						this.raise(type.start, TypeScriptError.InvalidTupleMemberLabel);
						labeledNode.label = type;
					}
					labeledNode.elementType = this.tsParseType();
					type = this.finishNode(labeledNode, "TSNamedTupleMember");
				} else if (optional) {
					const optionalTypeNode = this.startNodeAtNode(type);
					optionalTypeNode.typeAnnotation = type;
					type = this.finishNode(optionalTypeNode, "TSOptionalType");
				}
				if (rest) {
					const restNode = this.startNodeAt(startPos, startLoc);
					restNode.typeAnnotation = type;
					type = this.finishNode(restNode, "TSRestType");
				}
				return type;
			}
			tsParseTupleType() {
				const node = this.startNode();
				node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
				let seenOptionalElement = false;
				let labeledElements = null;
				node.elementTypes.forEach((elementNode) => {
					const { type } = elementNode;
					if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);
					seenOptionalElement ||= type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
					let checkType = type;
					if (type === "TSRestType") {
						elementNode = elementNode.typeAnnotation;
						checkType = elementNode.type;
					}
					const isLabeled = checkType === "TSNamedTupleMember";
					labeledElements ??= isLabeled;
					if (labeledElements !== isLabeled) this.raise(elementNode.start, TypeScriptError.MixedLabeledAndUnlabeledElements);
				});
				return this.finishNode(node, "TSTupleType");
			}
			tsParseTemplateLiteralType() {
				const node = this.startNode();
				node.literal = this.parseTemplate({ isTagged: false });
				return this.finishNode(node, "TSLiteralType");
			}
			tsParseTypeReference() {
				const node = this.startNode();
				node.typeName = this.tsParseEntityName();
				if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) node.typeArguments = this.tsParseTypeArguments();
				return this.finishNode(node, "TSTypeReference");
			}
			tsMatchLeftRelational() {
				return this.match(tt.relational) && this.value === "<";
			}
			tsMatchRightRelational() {
				return this.match(tt.relational) && this.value === ">";
			}
			tsParseParenthesizedType() {
				const node = this.startNode();
				this.expect(tt.parenL);
				node.typeAnnotation = this.tsParseType();
				this.expect(tt.parenR);
				return this.finishNode(node, "TSParenthesizedType");
			}
			tsParseNonArrayType() {
				switch (this.type) {
					case tt.string:
					case tt.num:
					case tt._true:
					case tt._false: return this.tsParseLiteralTypeNode();
					case tt.plusMin:
						if (this.value === "-") {
							const node = this.startNode();
							if (this.lookahead().type !== tt.num) this.unexpected();
							node.literal = this.parseMaybeUnary();
							return this.finishNode(node, "TSLiteralType");
						}
						break;
					case tt._this: return this.tsParseThisTypeOrThisTypePredicate();
					case tt._typeof: return this.tsParseTypeQuery();
					case tt._import: return this.tsParseImportType();
					case tt.braceL: return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
					case tt.bracketL: return this.tsParseTupleType();
					case tt.parenL: return this.tsParseParenthesizedType();
					case tt.backQuote:
					case tt.dollarBraceL: return this.tsParseTemplateLiteralType();
					default: {
						const { type } = this;
						if (tokenIsIdentifier(type) || type === tt._void || type === tt._null) {
							const nodeType = type === tt._void ? "TSVoidKeyword" : type === tt._null ? "TSNullKeyword" : keywordTypeFromName(this.value);
							if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
								const node = this.startNode();
								this.next();
								return this.finishNode(node, nodeType);
							}
							return this.tsParseTypeReference();
						}
					}
				}
				this.unexpected();
			}
			tsParseArrayTypeOrHigher() {
				let type = this.tsParseNonArrayType();
				while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) if (this.match(tt.bracketR)) {
					const node = this.startNodeAtNode(type);
					node.elementType = type;
					this.expect(tt.bracketR);
					type = this.finishNode(node, "TSArrayType");
				} else {
					const node = this.startNodeAtNode(type);
					node.objectType = type;
					node.indexType = this.tsParseType();
					this.expect(tt.bracketR);
					type = this.finishNode(node, "TSIndexedAccessType");
				}
				return type;
			}
			tsParseTypeOperatorOrHigher() {
				return tokenIsTSTypeOperator(this.type) && !this.containsEsc ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
			}
			tsParseIntersectionTypeOrHigher() {
				return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), tt.bitwiseAND);
			}
			tsParseUnionTypeOrHigher() {
				return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), tt.bitwiseOR);
			}
			tsParseNonConditionalType() {
				if (this.tsIsStartOfFunctionType()) return this.tsParseFunctionOrConstructorType("TSFunctionType");
				if (this.match(tt._new)) return this.tsParseFunctionOrConstructorType("TSConstructorType");
				else if (this.isAbstractConstructorSignature()) return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
				return this.tsParseUnionTypeOrHigher();
			}
			/** Be sure to be in a type context before calling this, using `tsInType`. */
			tsParseType() {
				assert(this.inType);
				const type = this.tsParseNonConditionalType();
				if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt._extends)) return type;
				const node = this.startNodeAtNode(type);
				node.checkType = type;
				node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
				this.expect(tt.question);
				node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
				this.expect(tt.colon);
				node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
				return this.finishNode(node, "TSConditionalType");
			}
			tsIsUnambiguouslyIndexSignature() {
				this.next();
				if (tokenIsIdentifier(this.type)) {
					this.next();
					return this.match(tt.colon);
				}
				return false;
			}
			/**
			* Runs `cb` in a type context.
			* This should be called one token *before* the first type token,
			* so that the call to `next()` is run in type context.
			*/
			tsInType(cb) {
				const oldInType = this.inType;
				this.inType = true;
				try {
					return cb();
				} finally {
					this.inType = oldInType;
				}
			}
			tsTryParseIndexSignature(node) {
				if (!(this.match(tt.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
				this.expect(tt.bracketL);
				const id = this.parseIdent();
				id.typeAnnotation = this.tsParseTypeAnnotation();
				this.resetEndLocation(id);
				this.expect(tt.bracketR);
				node.parameters = [id];
				const type = this.tsTryParseTypeAnnotation();
				if (type) node.typeAnnotation = type;
				this.tsParseTypeMemberSemicolon();
				return this.finishNode(node, "TSIndexSignature");
			}
			tsParseNoneModifiers(node) {
				this.tsParseModifiers({
					modified: node,
					allowedModifiers: [],
					disallowedModifiers: ["in", "out"],
					errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
				});
			}
			tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
				const node = this.startNode();
				parseModifiers(node);
				node.name = this.tsParseTypeParameterName();
				node.constraint = this.tsEatThenParseType(tt._extends);
				node.default = this.tsEatThenParseType(tt.eq);
				return this.finishNode(node, "TSTypeParameter");
			}
			tsParseTypeParameters(parseModifiers) {
				const node = this.startNode();
				if (this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart")) this.next();
				else this.unexpected();
				const refTrailingCommaPos = { value: -1 };
				node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
				if (node.params.length === 0) this.raise(this.start, TypeScriptError.EmptyTypeParameters);
				if (refTrailingCommaPos.value !== -1) this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
				return this.finishNode(node, "TSTypeParameterDeclaration");
			}
			tsTryParseTypeParameters(parseModifiers) {
				if (this.tsMatchLeftRelational()) return this.tsParseTypeParameters(parseModifiers);
			}
			tsTryParse(f$2) {
				const state = this.getCurLookaheadState();
				const result = f$2();
				if (result !== void 0 && result !== false) return result;
				else {
					this.setLookaheadState(state);
					return;
				}
			}
			tsTokenCanFollowModifier() {
				return (this.match(tt.bracketL) || this.match(tt.braceL) || this.match(tt.star) || this.match(tt.ellipsis) || this.match(tt.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
			}
			tsNextTokenCanFollowModifier() {
				this.next(true);
				return this.tsTokenCanFollowModifier();
			}
			/** Parses a modifier matching one the given modifier names. */
			tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
				const modifier = this.value;
				if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {
					if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) return;
					if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return modifier;
				}
			}
			tsParseModifiersByMap({ modified, map: map$6 }) {
				for (const key of Object.keys(map$6)) modified[key] = map$6[key];
			}
			/** Parses a list of modifiers, in any order.
			*  If you need a specific order, you must call this function multiple times:
			*    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });
			*    this.tsParseModifiers({ modified: node, allowedModifiers: ["abstract", "readonly"] });
			*/
			tsParseModifiers({ modified, allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate = TypeScriptError.InvalidModifierOnTypeMember }) {
				const modifiedMap = {};
				const enforceOrder = (loc, modifier, before, after) => {
					if (modifier === before && modified[after]) this.raise(loc.column, TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before, after] }));
				};
				const incompatible = (loc, modifier, mod1, mod2) => {
					if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) this.raise(loc.column, TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] }));
				};
				for (;;) {
					const startLoc = this.startLoc;
					const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock);
					if (!modifier) break;
					if (tsIsAccessModifier(modifier)) if (modified.accessibility) this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());
					else {
						enforceOrder(startLoc, modifier, modifier, "override");
						enforceOrder(startLoc, modifier, modifier, "static");
						enforceOrder(startLoc, modifier, modifier, "readonly");
						enforceOrder(startLoc, modifier, modifier, "accessor");
						modifiedMap.accessibility = modifier;
						modified["accessibility"] = modifier;
					}
					else if (tsIsVarianceAnnotations(modifier)) if (modified[modifier]) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
					else {
						enforceOrder(startLoc, modifier, "in", "out");
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
					else if (tsIsClassAccessor(modifier)) if (modified[modifier]) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
					else {
						incompatible(startLoc, modifier, "accessor", "readonly");
						incompatible(startLoc, modifier, "accessor", "static");
						incompatible(startLoc, modifier, "accessor", "override");
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
					else if (modifier === "const") if (modified[modifier]) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
					else {
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
					else if (Object.hasOwnProperty.call(modified, modifier)) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
					else {
						enforceOrder(startLoc, modifier, "static", "readonly");
						enforceOrder(startLoc, modifier, "static", "override");
						enforceOrder(startLoc, modifier, "override", "readonly");
						enforceOrder(startLoc, modifier, "abstract", "override");
						incompatible(startLoc, modifier, "declare", "override");
						incompatible(startLoc, modifier, "static", "abstract");
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
					if (disallowedModifiers?.includes(modifier)) this.raise(this.start, errorTemplate);
				}
				return modifiedMap;
			}
			tsParseInOutModifiers(node) {
				this.tsParseModifiers({
					modified: node,
					allowedModifiers: ["in", "out"],
					disallowedModifiers: [
						"public",
						"private",
						"protected",
						"readonly",
						"declare",
						"abstract",
						"override"
					],
					errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter
				});
			}
			parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {
				if (!options?.jsx && this.tsMatchLeftRelational()) return this.tsParseTypeAssertion();
				else return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);
			}
			tsParseTypeAssertion() {
				if (disallowAmbiguousJSXLike) this.raise(this.start, TypeScriptError.ReservedTypeAssertion);
				const result = this.tryParse(() => {
					const node = this.startNode();
					node.typeAnnotation = this.tsTryNextParseConstantContext() || this.tsNextThenParseType();
					this.expect(tt.relational);
					node.expression = this.parseMaybeUnary();
					return this.finishNode(node, "TSTypeAssertion");
				});
				if (result.error) return this.tsParseTypeParameters(this.tsParseConstModifier);
				else return result.node;
			}
			tsParseTypeArguments() {
				const node = this.startNode();
				node.params = this.tsInType(() => this.tsInNoContext(() => {
					this.expect(tt.relational);
					return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
				}));
				if (node.params.length === 0) this.raise(this.start, TypeScriptError.EmptyTypeArguments);
				this.exprAllowed = false;
				this.expect(tt.relational);
				return this.finishNode(node, "TSTypeParameterInstantiation");
			}
			tsParseHeritageClause(token) {
				const originalStart = this.start;
				const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
					const node = this.startNode();
					node.expression = this.tsParseEntityName();
					if (this.tsMatchLeftRelational()) node.typeParameters = this.tsParseTypeArguments();
					return this.finishNode(node, "TSExpressionWithTypeArguments");
				});
				if (!delimitedList.length) this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));
				return delimitedList;
			}
			tsParseTypeMemberSemicolon() {
				if (!this.eat(tt.comma) && !this.isLineTerminator()) this.expect(tt.semi);
			}
			tsTryParseAndCatch(f$2) {
				const result = this.tryParse((abort) => f$2() || abort());
				if (result.aborted || !result.node) return void 0;
				if (result.error) this.setLookaheadState(result.failState);
				return result.node;
			}
			tsParseSignatureMember(kind, node) {
				this.tsFillSignature(tt.colon, node);
				this.tsParseTypeMemberSemicolon();
				return this.finishNode(node, kind);
			}
			tsParsePropertyOrMethodSignature(node, readonly) {
				if (this.eat(tt.question)) node.optional = true;
				const nodeAny = node;
				if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
					if (readonly) this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);
					const method = nodeAny;
					if (method.kind && this.tsMatchLeftRelational()) this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);
					this.tsFillSignature(tt.colon, method);
					this.tsParseTypeMemberSemicolon();
					const paramsKey = "parameters";
					const returnTypeKey = "typeAnnotation";
					if (method.kind === "get") {
						if (method[paramsKey].length > 0) {
							this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
							if (this.isThisParam(method[paramsKey][0])) this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
						}
					} else if (method.kind === "set") {
						if (method[paramsKey].length !== 1) this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
						else {
							const firstParameter = method[paramsKey][0];
							if (this.isThisParam(firstParameter)) this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
							if (firstParameter.type === "Identifier" && firstParameter.optional) this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);
							if (firstParameter.type === "RestElement") this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);
						}
						if (method[returnTypeKey]) this.raise(method[returnTypeKey].start, TypeScriptError.SetAccesorCannotHaveReturnType);
					} else method.kind = "method";
					return this.finishNode(method, "TSMethodSignature");
				} else {
					const property = nodeAny;
					if (readonly) property.readonly = true;
					const type = this.tsTryParseTypeAnnotation();
					if (type) property.typeAnnotation = type;
					this.tsParseTypeMemberSemicolon();
					return this.finishNode(property, "TSPropertySignature");
				}
			}
			tsParseTypeMember() {
				const node = this.startNode();
				if (this.match(tt.parenL) || this.tsMatchLeftRelational()) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
				if (this.match(tt._new)) {
					const id = this.startNode();
					this.next();
					if (this.match(tt.parenL) || this.tsMatchLeftRelational()) return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
					else {
						node.key = this.createIdentifier(id, "new");
						return this.tsParsePropertyOrMethodSignature(node, false);
					}
				}
				this.tsParseModifiers({
					modified: node,
					allowedModifiers: ["readonly"],
					disallowedModifiers: [
						"declare",
						"abstract",
						"private",
						"protected",
						"public",
						"static",
						"override"
					]
				});
				const idx = this.tsTryParseIndexSignature(node);
				if (idx) return idx;
				this.parsePropertyName(node);
				if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
					node.kind = node.key.name;
					this.parsePropertyName(node);
				}
				return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
			}
			tsParseList(kind, parseElement) {
				const result = [];
				while (!this.tsIsListTerminator(kind)) result.push(parseElement());
				return result;
			}
			tsParseObjectTypeMembers() {
				this.expect(tt.braceL);
				const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
				this.expect(tt.braceR);
				return members;
			}
			tsParseInterfaceDeclaration(node, properties = {}) {
				if (this.hasFollowingLineBreak()) return null;
				this.expectContextual("interface");
				if (properties.declare) node.declare = true;
				if (tokenIsIdentifier(this.type)) {
					node.id = this.parseIdent();
					this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);
				} else {
					node.id = null;
					this.raise(this.start, TypeScriptError.MissingInterfaceName);
				}
				node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
				if (this.eat(tt._extends)) node.extends = this.tsParseHeritageClause("extends");
				const body = this.startNode();
				body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
				node.body = this.finishNode(body, "TSInterfaceBody");
				return this.finishNode(node, "TSInterfaceDeclaration");
			}
			tsParseAbstractDeclaration(node) {
				if (this.match(tt._class)) {
					node.abstract = true;
					return this.parseClass(node, true);
				} else if (this.ts_isContextual(tokTypes2.interface)) {
					if (!this.hasFollowingLineBreak()) {
						node.abstract = true;
						return this.tsParseInterfaceDeclaration(node);
					}
				} else this.unexpected(node.start);
			}
			tsIsDeclarationStart() {
				return tokenIsTSDeclarationStart(this.type);
			}
			tsParseExpressionStatement(node, expr) {
				switch (expr.name) {
					case "declare": {
						const declaration = this.tsTryParseDeclare(node);
						if (declaration) {
							declaration.declare = true;
							return declaration;
						}
						break;
					}
					case "global":
						if (this.match(tt.braceL)) {
							this.enterScope(TS_SCOPE_TS_MODULE);
							const mod = node;
							mod.global = true;
							mod.id = expr;
							mod.body = this.tsParseModuleBlock();
							super.exitScope();
							return this.finishNode(mod, "TSModuleDeclaration");
						}
						break;
					default: return this.tsParseDeclaration(node, expr.name, false);
				}
			}
			tsParseModuleReference() {
				return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
			}
			tsIsExportDefaultSpecifier() {
				const { type } = this;
				const isAsync = this.isAsyncFunction();
				const isLet = this.isLet();
				if (tokenIsIdentifier(type)) {
					if (isAsync && !this.containsEsc || isLet) return false;
					if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
						const ahead = this.lookahead();
						if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) return false;
					}
				} else if (!this.match(tt._default)) return false;
				const next = this.nextTokenStart();
				const hasFrom = this.isUnparsedContextual(next, "from");
				if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) return true;
				if (this.match(tt._default) && hasFrom) {
					const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
					return nextAfterFrom === 34 || nextAfterFrom === 39;
				}
				return false;
			}
			tsInAmbientContext(cb) {
				const oldIsAmbientContext = this.isAmbientContext;
				this.isAmbientContext = true;
				try {
					return cb();
				} finally {
					this.isAmbientContext = oldIsAmbientContext;
				}
			}
			tsCheckLineTerminator(next) {
				if (next) {
					if (this.hasFollowingLineBreak()) return false;
					this.next();
					return true;
				}
				return !this.isLineTerminator();
			}
			tsParseModuleOrNamespaceDeclaration(node, nested = false) {
				node.id = this.parseIdent();
				if (!nested) this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);
				if (this.eat(tt.dot)) {
					const inner = this.startNode();
					this.tsParseModuleOrNamespaceDeclaration(inner, true);
					node.body = inner;
				} else {
					this.enterScope(TS_SCOPE_TS_MODULE);
					node.body = this.tsParseModuleBlock();
					super.exitScope();
				}
				return this.finishNode(node, "TSModuleDeclaration");
			}
			checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
				if (expr.type === "TSNonNullExpression" || expr.type === "TSAsExpression") expr = expr.expression;
				return super.checkLValSimple(expr, bindingType, checkClashes);
			}
			tsParseTypeAliasDeclaration(node) {
				node.id = this.parseIdent();
				this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);
				node.typeAnnotation = this.tsInType(() => {
					node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
					this.expect(tt.eq);
					if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt.dot) {
						const node2 = this.startNode();
						this.next();
						return this.finishNode(node2, "TSIntrinsicKeyword");
					}
					return this.tsParseType();
				});
				this.semicolon();
				return this.finishNode(node, "TSTypeAliasDeclaration");
			}
			tsParseDeclaration(node, value, next) {
				switch (value) {
					case "abstract":
						if (this.tsCheckLineTerminator(next) && (this.match(tt._class) || tokenIsIdentifier(this.type))) return this.tsParseAbstractDeclaration(node);
						break;
					case "module":
						if (this.tsCheckLineTerminator(next)) {
							if (this.match(tt.string)) return this.tsParseAmbientExternalModuleDeclaration(node);
							else if (tokenIsIdentifier(this.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
						}
						break;
					case "namespace":
						if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
						break;
					case "type":
						if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) return this.tsParseTypeAliasDeclaration(node);
						break;
				}
			}
			tsTryParseExportDeclaration() {
				return this.tsParseDeclaration(this.startNode(), this.value, true);
			}
			tsParseImportEqualsDeclaration(node, isExport) {
				node.isExport = isExport || false;
				node.id = this.parseIdent();
				this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);
				super.expect(tt.eq);
				const moduleReference = this.tsParseModuleReference();
				if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);
				node.moduleReference = moduleReference;
				super.semicolon();
				return this.finishNode(node, "TSImportEqualsDeclaration");
			}
			isExportDefaultSpecifier() {
				if (this.tsIsDeclarationStart()) return false;
				const { type } = this;
				if (tokenIsIdentifier(type)) {
					if (this.isContextual("async") || this.isContextual("let")) return false;
					if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
						const ahead = this.lookahead();
						if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) return false;
					}
				} else if (!this.match(tt._default)) return false;
				const next = this.nextTokenStart();
				const hasFrom = this.isUnparsedContextual(next, "from");
				if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) return true;
				if (this.match(tt._default) && hasFrom) {
					const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
					return nextAfterFrom === 34 || nextAfterFrom === 39;
				}
				return false;
			}
			parseTemplate({ isTagged = false } = {}) {
				let node = this.startNode();
				this.next();
				node.expressions = [];
				let curElt = this.parseTemplateElement({ isTagged });
				node.quasis = [curElt];
				while (!curElt.tail) {
					if (this.type === tt.eof) this.raise(this.pos, "Unterminated template literal");
					this.expect(tt.dollarBraceL);
					node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());
					this.expect(tt.braceR);
					node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
				}
				this.next();
				return this.finishNode(node, "TemplateLiteral");
			}
			parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {
				this.initFunction(node);
				if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {
					if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
					node.generator = this.eat(tt.star);
				}
				if (this.ecmaVersion >= 8) node.async = !!isAsync;
				if (statement & FUNC_STATEMENT) node.id = statement & FUNC_NULLABLE_ID && this.type !== tt.name ? null : this.parseIdent();
				let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
				const oldMaybeInArrowParameters = this.maybeInArrowParameters;
				this.maybeInArrowParameters = false;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.enterScope(functionFlags(node.async, node.generator));
				if (!(statement & FUNC_STATEMENT)) node.id = this.type === tt.name ? this.parseIdent() : null;
				this.parseFunctionParams(node);
				const isDeclaration = statement & FUNC_STATEMENT;
				this.parseFunctionBody(node, allowExpressionBody, false, forInit, { isFunctionDeclaration: isDeclaration });
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				if (statement & FUNC_STATEMENT && node.id && !(statement & FUNC_HANGING_STATEMENT)) if (node.body) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION);
				else this.checkLValSimple(node.id, acornScope.BIND_NONE);
				this.maybeInArrowParameters = oldMaybeInArrowParameters;
				return this.finishNode(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
			}
			parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {
				if (this.match(tt.colon)) node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
				const bodilessType = tsConfig?.isFunctionDeclaration ? "TSDeclareFunction" : tsConfig?.isClassMethod ? "TSDeclareMethod" : void 0;
				if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) return this.finishNode(node, bodilessType);
				if (bodilessType === "TSDeclareFunction" && this.isAmbientContext) {
					this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);
					if (node.declare) {
						super.parseFunctionBody(node, isArrowFunction, isMethod, false);
						return this.finishNode(node, bodilessType);
					}
				}
				super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);
				return node;
			}
			parseNew() {
				if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
				let node = this.startNode();
				let meta = this.parseIdent(true);
				if (this.ecmaVersion >= 6 && this.eat(tt.dot)) {
					node.meta = meta;
					let containsEsc = this.containsEsc;
					node.property = this.parseIdent(true);
					if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
					if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
					if (!this["allowNewDotTarget"]) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
					return this.finishNode(node, "MetaProperty");
				}
				let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt._import;
				node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
				if (isImport && node.callee.type === "ImportExpression") this.raise(startPos, "Cannot use new with import()");
				const { callee } = node;
				if (callee.type === "TSInstantiationExpression" && !callee.extra?.parenthesized) {
					node.typeArguments = callee.typeArguments;
					node.callee = callee.expression;
				}
				if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false);
				else node.arguments = [];
				return this.finishNode(node, "NewExpression");
			}
			parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {
				if (tt._in.binop > minPrec && !this.hasPrecedingLineBreak()) {
					let nodeType;
					if (this.isContextual("as")) nodeType = "TSAsExpression";
					if (this.isContextual("satisfies")) nodeType = "TSSatisfiesExpression";
					if (nodeType) {
						const node = this.startNodeAt(leftStartPos, leftStartLoc);
						node.expression = left;
						const _const = this.tsTryNextParseConstantContext();
						if (_const) node.typeAnnotation = _const;
						else node.typeAnnotation = this.tsNextThenParseType();
						this.finishNode(node, nodeType);
						this.reScan_lt_gt();
						return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
					}
				}
				return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);
			}
			parseImportSpecifiers() {
				let nodes = [], first = true;
				if (acornTypeScript.tokenIsIdentifier(this.type)) {
					nodes.push(this.parseImportDefaultSpecifier());
					if (!this.eat(tt.comma)) return nodes;
				}
				if (this.type === tt.star) {
					nodes.push(this.parseImportNamespaceSpecifier());
					return nodes;
				}
				this.expect(tt.braceL);
				while (!this.eat(tt.braceR)) {
					if (!first) {
						this.expect(tt.comma);
						if (this.afterTrailingComma(tt.braceR)) break;
					} else first = false;
					nodes.push(this.parseImportSpecifier());
				}
				return nodes;
			}
			/**
			* @param {Node} node this may be ImportDeclaration |
			* TsImportEqualsDeclaration
			* @returns AnyImport
			* */
			parseImport(node) {
				let enterHead = this.lookahead();
				node.importKind = "value";
				this.importOrExportOuterKind = "value";
				if (tokenIsIdentifier(enterHead.type) || this.match(tt.star) || this.match(tt.braceL)) {
					let ahead = this.lookahead(2);
					if (ahead.type !== tt.comma && !this.isContextualWithState("from", ahead) && ahead.type !== tt.eq && this.ts_eatContextualWithState("type", 1, enterHead)) {
						this.importOrExportOuterKind = "type";
						node.importKind = "type";
						enterHead = this.lookahead();
						ahead = this.lookahead(2);
					}
					if (tokenIsIdentifier(enterHead.type) && ahead.type === tt.eq) {
						this.next();
						const importNode = this.tsParseImportEqualsDeclaration(node);
						this.importOrExportOuterKind = "value";
						return importNode;
					}
				}
				this.next();
				if (this.type === tt.string) {
					node.specifiers = [];
					node.source = this.parseExprAtom();
				} else {
					node.specifiers = this.parseImportSpecifiers();
					this.expectContextual("from");
					node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
				}
				this.parseMaybeImportAttributes(node);
				this.semicolon();
				this.finishNode(node, "ImportDeclaration");
				this.importOrExportOuterKind = "value";
				if (node.importKind === "type" && node.specifiers.length > 1 && node.specifiers[0].type === "ImportDefaultSpecifier") this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);
				return node;
			}
			parseExportDefaultDeclaration() {
				if (this.isAbstractClass()) {
					const cls = this.startNode();
					this.next();
					cls.abstract = true;
					return this.parseClass(cls, true);
				}
				if (this.match(tokTypes2.interface)) {
					const result = this.tsParseInterfaceDeclaration(this.startNode());
					if (result) return result;
				}
				return super.parseExportDefaultDeclaration();
			}
			parseExportAllDeclaration(node, exports$1) {
				if (this.ecmaVersion >= 11) if (this.eatContextual("as")) {
					node.exported = this.parseModuleExportName();
					this.checkExport(exports$1, node.exported, this.lastTokStart);
				} else node.exported = null;
				this.expectContextual("from");
				if (this.type !== tt.string) this.unexpected();
				node.source = this.parseExprAtom();
				this.parseMaybeImportAttributes(node);
				this.semicolon();
				return this.finishNode(node, "ExportAllDeclaration");
			}
			parseDynamicImport(node) {
				this.next();
				node.source = this.parseMaybeAssign();
				if (this.eat(tt.comma)) node.arguments = [this.parseExpression()];
				if (!this.eat(tt.parenR)) {
					const errorPos = this.start;
					if (this.eat(tt.comma) && this.eat(tt.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
					else this.unexpected(errorPos);
				}
				return this.finishNode(node, "ImportExpression");
			}
			parseExport(node, exports$1) {
				let enterHead = this.lookahead();
				if (this.ts_eatWithState(tt._import, 2, enterHead)) {
					if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {
						node.importKind = "type";
						this.importOrExportOuterKind = "type";
						this.next();
					} else {
						node.importKind = "value";
						this.importOrExportOuterKind = "value";
					}
					const exportEqualsNode = this.tsParseImportEqualsDeclaration(node, true);
					this.importOrExportOuterKind = void 0;
					return exportEqualsNode;
				} else if (this.ts_eatWithState(tt.eq, 2, enterHead)) {
					const assign = node;
					assign.expression = this.parseExpression();
					this.semicolon();
					this.importOrExportOuterKind = void 0;
					return this.finishNode(assign, "TSExportAssignment");
				} else if (this.ts_eatContextualWithState("as", 2, enterHead)) {
					const decl$1 = node;
					this.expectContextual("namespace");
					decl$1.id = this.parseIdent();
					this.semicolon();
					this.importOrExportOuterKind = void 0;
					return this.finishNode(decl$1, "TSNamespaceExportDeclaration");
				} else {
					if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && this.lookahead(2).type === tt.braceL) {
						this.next();
						this.importOrExportOuterKind = "type";
						node.exportKind = "type";
					} else {
						this.importOrExportOuterKind = "value";
						node.exportKind = "value";
					}
					this.next();
					if (this.eat(tt.star)) return this.parseExportAllDeclaration(node, exports$1);
					if (this.eat(tt._default)) {
						this.checkExport(exports$1, "default", this.lastTokStart);
						node.declaration = this.parseExportDefaultDeclaration();
						return this.finishNode(node, "ExportDefaultDeclaration");
					}
					if (this.shouldParseExportStatement()) {
						node.declaration = this.parseExportDeclaration(node);
						if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports$1, node.declaration.declarations);
						else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
						node.specifiers = [];
						node.source = null;
					} else {
						node.declaration = null;
						node.specifiers = this.parseExportSpecifiers(exports$1);
						if (this.eatContextual("from")) {
							if (this.type !== tt.string) this.unexpected();
							node.source = this.parseExprAtom();
							this.parseMaybeImportAttributes(node);
						} else {
							for (let spec of node.specifiers) {
								this.checkUnreserved(spec.local);
								this.checkLocalExport(spec.local);
								if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
							}
							node.source = null;
						}
						this.semicolon();
					}
					return this.finishNode(node, "ExportNamedDeclaration");
				}
			}
			checkExport(exports$1, name, _$1) {
				if (!exports$1) return;
				if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
				exports$1[name] = true;
			}
			parseMaybeDefault(startPos, startLoc, left) {
				const node = super.parseMaybeDefault(startPos, startLoc, left);
				if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);
				return node;
			}
			typeCastToParameter(node) {
				node.expression.typeAnnotation = node.typeAnnotation;
				this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc?.end);
				return node.expression;
			}
			toAssignableList(exprList, isBinding) {
				for (let i$1 = 0; i$1 < exprList.length; i$1++) {
					const expr = exprList[i$1];
					if (expr?.type === "TSTypeCastExpression") exprList[i$1] = this.typeCastToParameter(expr);
				}
				return super.toAssignableList(exprList, isBinding);
			}
			reportReservedArrowTypeParam(node) {
				if (node.params.length === 1 && !node.extra?.trailingComma && disallowAmbiguousJSXLike) this.raise(node.start, TypeScriptError.ReservedArrowTypeParam);
			}
			parseExprAtom(refDestructuringErrors, forInit, forNew) {
				if (this.type === tokTypes2.jsxText) return this.jsx_parseText();
				else if (this.type === tokTypes2.jsxTagStart) return this.jsx_parseElement();
				else if (this.type === tokTypes2.at) {
					this.parseDecorators();
					return this.parseExprAtom();
				} else if (tokenIsIdentifier(this.type)) {
					let canBeArrow = this.potentialArrowAt === this.start;
					let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
					let id = this.parseIdent(false);
					if (this.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function)) {
						this.overrideContext(tokContexts.f_expr);
						return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
					}
					if (canBeArrow && !this.canInsertSemicolon()) {
						if (this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
						if (this.ecmaVersion >= 8 && id.name === "async" && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
							id = this.parseIdent(false);
							if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
							return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
						}
					}
					return id;
				} else return super.parseExprAtom(refDestructuringErrors, forInit, forNew);
			}
			parseExprAtomDefault() {
				if (tokenIsIdentifier(this.type)) {
					const canBeArrow = this["potentialArrowAt"] === this.start;
					const containsEsc = this.containsEsc;
					const id = this.parseIdent();
					if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
						const { type } = this;
						if (type === tt._function) {
							this.next();
							return this.parseFunction(this.startNodeAtNode(id), void 0, true, true);
						} else if (tokenIsIdentifier(type)) if (this.lookaheadCharCode() === 61) {
							const paramId = this.parseIdent(false);
							if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
							return this.parseArrowExpression(this.startNodeAtNode(id), [paramId], true);
						} else return id;
					}
					if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {
						this.next();
						return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
					}
					return id;
				} else this.unexpected();
			}
			parseIdentNode() {
				let node = this.startNode();
				if (tokenIsKeywordOrIdentifier(this.type) && !((this.type.keyword === "class" || this.type.keyword === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) node.name = this.value;
				else return super.parseIdentNode();
				return node;
			}
			parseVarStatement(node, kind, allowMissingInitializer = false) {
				const { isAmbientContext } = this;
				this.next();
				super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);
				this.semicolon();
				const declaration = this.finishNode(node, "VariableDeclaration");
				if (!isAmbientContext) return declaration;
				for (const { id, init } of declaration.declarations) {
					if (!init) continue;
					if (kind !== "const" || !!id.typeAnnotation) this.raise(init.start, TypeScriptError.InitializerNotAllowedInAmbientContext);
					else if (init.type !== "StringLiteral" && init.type !== "BooleanLiteral" && init.type !== "NumericLiteral" && init.type !== "BigIntLiteral" && (init.type !== "TemplateLiteral" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) this.raise(init.start, TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference);
				}
				return declaration;
			}
			parseStatement(context, topLevel, exports$1) {
				if (this.match(tokTypes2.at)) this.parseDecorators(true);
				if (this.match(tt._const) && this.isLookaheadContextual("enum")) {
					const node = this.startNode();
					this.expect(tt._const);
					return this.tsParseEnumDeclaration(node, { const: true });
				}
				if (this.ts_isContextual(tokTypes2.enum)) return this.tsParseEnumDeclaration(this.startNode());
				if (this.ts_isContextual(tokTypes2.interface)) {
					const result = this.tsParseInterfaceDeclaration(this.startNode());
					if (result) return result;
				}
				return super.parseStatement(context, topLevel, exports$1);
			}
			parseAccessModifier() {
				return this.tsParseModifier([
					"public",
					"protected",
					"private"
				]);
			}
			parsePostMemberNameModifiers(methodOrProp) {
				if (this.eat(tt.question)) methodOrProp.optional = true;
				if (methodOrProp.readonly && this.match(tt.parenL)) this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);
				if (methodOrProp.declare && this.match(tt.parenL)) this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);
			}
			parseExpressionStatement(node, expr) {
				return (expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0) || super.parseExpressionStatement(node, expr);
			}
			shouldParseExportStatement() {
				if (this.tsIsDeclarationStart()) return true;
				if (this.match(tokTypes2.at)) return true;
				return super.shouldParseExportStatement();
			}
			parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {
				if (this.eat(tt.question)) {
					let node = this.startNodeAt(startPos, startLoc);
					node.test = expr;
					node.consequent = this.parseMaybeAssign();
					this.expect(tt.colon);
					node.alternate = this.parseMaybeAssign(forInit);
					return this.finishNode(node, "ConditionalExpression");
				}
				return expr;
			}
			parseMaybeConditional(forInit, refDestructuringErrors) {
				let startPos = this.start, startLoc = this.startLoc;
				let expr = this.parseExprOps(forInit, refDestructuringErrors);
				if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
				if (!this.maybeInArrowParameters || !this.match(tt.question)) return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);
				const result = this.tryParse(() => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors));
				if (!result.node) {
					if (result.error) this.setOptionalParametersError(refDestructuringErrors, result.error);
					return expr;
				}
				if (result.error) this.setLookaheadState(result.failState);
				return result.node;
			}
			parseParenItem(node) {
				const startPos = this.start;
				const startLoc = this.startLoc;
				node = super.parseParenItem(node);
				if (this.eat(tt.question)) {
					node.optional = true;
					this.resetEndLocation(node);
				}
				if (this.match(tt.colon)) {
					const typeCastNode = this.startNodeAt(startPos, startLoc);
					typeCastNode.expression = node;
					typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
					return this.finishNode(typeCastNode, "TSTypeCastExpression");
				}
				return node;
			}
			parseExportDeclaration(node) {
				if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
				const startPos = this.start;
				const startLoc = this.startLoc;
				const isDeclare = this.eatContextual("declare");
				if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);
				const declaration = tokenIsIdentifier(this.type) && this.tsTryParseExportDeclaration() || this.parseStatement(null);
				if (!declaration) return null;
				if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) node.exportKind = "type";
				if (isDeclare) {
					this.resetStartLocation(declaration, startPos, startLoc);
					declaration.declare = true;
				}
				return declaration;
			}
			parseClassId(node, isStatement) {
				if (!isStatement && this.isContextual("implements")) return;
				super.parseClassId(node, isStatement);
				const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
				if (typeParameters) node.typeParameters = typeParameters;
			}
			parseClassPropertyAnnotation(node) {
				if (!node.optional) {
					if (this.value === "!" && this.eat(tt.prefix)) node.definite = true;
					else if (this.eat(tt.question)) node.optional = true;
				}
				const type = this.tsTryParseTypeAnnotation();
				if (type) node.typeAnnotation = type;
			}
			parseClassField(field) {
				if (field.key.type === "PrivateIdentifier") {
					if (field.abstract) this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);
					if (field.accessibility) this.raise(field.start, TypeScriptError.PrivateElementHasAccessibility({ modifier: field.accessibility }));
					this.parseClassPropertyAnnotation(field);
				} else {
					this.parseClassPropertyAnnotation(field);
					if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt.eq)) this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);
					if (field.abstract && this.match(tt.eq)) {
						const { key } = field;
						this.raise(this.start, TypeScriptError.AbstractPropertyHasInitializer({ propertyName: key.type === "Identifier" && !field.computed ? key.name : `[${this.input.slice(key.start, key.end)}]` }));
					}
				}
				return super.parseClassField(field);
			}
			parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper) {
				const isConstructor = method.kind === "constructor";
				const isPrivate = method.key.type === "PrivateIdentifier";
				const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				if (isPrivate) {
					if (typeParameters) method.typeParameters = typeParameters;
					if (method.accessibility) this.raise(method.start, TypeScriptError.PrivateMethodsHasAccessibility({ modifier: method.accessibility }));
				} else if (typeParameters && isConstructor) this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);
				const { declare = false, kind } = method;
				if (declare && (kind === "get" || kind === "set")) this.raise(method.start, TypeScriptError.DeclareAccessor({ kind }));
				if (typeParameters) method.typeParameters = typeParameters;
				const key = method.key;
				if (method.kind === "constructor") {
					if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
					if (isAsync) this.raise(key.start, "Constructor can't be an async method");
				} else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
				const value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper, true, method);
				if (method.kind === "get" && value["params"].length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
				if (method.kind === "set" && value["params"].length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
				if (method.kind === "set" && value["params"][0].type === "RestElement") this.raiseRecoverable(value["params"][0].start, "Setter cannot use rest params");
				return this.finishNode(method, "MethodDefinition");
			}
			isClassMethod() {
				return this.match(tt.relational);
			}
			parseClassElement(constructorAllowsSuper) {
				if (this.eat(tt.semi)) return null;
				let node = this.startNode();
				let keyName = "";
				let isGenerator = false;
				let isAsync = false;
				let kind = "method";
				let isStatic = false;
				const modifiers = [
					"declare",
					"private",
					"public",
					"protected",
					"accessor",
					"override",
					"abstract",
					"readonly",
					"static"
				];
				const modifierMap = this.tsParseModifiers({
					modified: node,
					allowedModifiers: modifiers,
					disallowedModifiers: ["in", "out"],
					stopOnStartOfClassStaticBlock: true,
					errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
				});
				isStatic = Boolean(modifierMap.static);
				const callParseClassMemberWithIsStatic = () => {
					if (this.tsIsStartOfStaticBlocks()) {
						this.next();
						this.next();
						if (this.tsHasSomeModifiers(node, modifiers)) this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);
						if (this.ecmaVersion >= 13) {
							super.parseClassStaticBlock(node);
							return node;
						}
					} else {
						const idx = this.tsTryParseIndexSignature(node);
						if (idx) {
							if (node.abstract) this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);
							if (node.accessibility) this.raise(node.start, TypeScriptError.IndexSignatureHasAccessibility({ modifier: node.accessibility }));
							if (node.declare) this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);
							if (node.override) this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);
							return idx;
						}
						if (!this.inAbstractClass && node.abstract) this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);
						if (node.override) {
							if (!constructorAllowsSuper) this.raise(node.start, TypeScriptError.OverrideNotInSubClass);
						}
						node.static = isStatic;
						if (isStatic) {
							if (!(this.isClassElementNameStart() || this.type === tt.star)) keyName = "static";
						}
						if (!keyName && this.ecmaVersion >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) isAsync = true;
						else keyName = "async";
						if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) isGenerator = true;
						if (!keyName && !isAsync && !isGenerator) {
							const lastValue = this.value;
							if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
							else keyName = lastValue;
						}
						if (keyName) {
							node.computed = false;
							node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
							node.key.name = keyName;
							this.finishNode(node.key, "Identifier");
						} else this.parseClassElementName(node);
						this.parsePostMemberNameModifiers(node);
						if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt.parenL || kind !== "method" || isGenerator || isAsync) {
							const isConstructor = !node.static && checkKeyName(node, "constructor");
							const allowsDirectSuper = isConstructor && constructorAllowsSuper;
							if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
							node.kind = isConstructor ? "constructor" : kind;
							this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
						} else this.parseClassField(node);
						return node;
					}
				};
				if (node.declare) this.tsInAmbientContext(callParseClassMemberWithIsStatic);
				else callParseClassMemberWithIsStatic();
				return node;
			}
			isClassElementNameStart() {
				if (this.tsIsIdentifier()) return true;
				return super.isClassElementNameStart();
			}
			parseClassSuper(node) {
				super.parseClassSuper(node);
				if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt.bitShift))) node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
				if (this.eatContextual("implements")) node.implements = this.tsParseHeritageClause("implements");
			}
			parseFunctionParams(node) {
				const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				if (typeParameters) node.typeParameters = typeParameters;
				super.parseFunctionParams(node);
			}
			parseVarId(decl$1, kind) {
				super.parseVarId(decl$1, kind);
				if (decl$1.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.value === "!" && this.eat(tt.prefix)) decl$1.definite = true;
				const type = this.tsTryParseTypeAnnotation();
				if (type) {
					decl$1.id.typeAnnotation = type;
					this.resetEndLocation(decl$1.id);
				}
			}
			parseArrowExpression(node, params, isAsync, forInit) {
				if (this.match(tt.colon)) node.returnType = this.tsParseTypeAnnotation();
				let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
				this.enterScope(functionFlags(isAsync, false) | acornScope.SCOPE_ARROW);
				this.initFunction(node);
				const oldMaybeInArrowParameters = this.maybeInArrowParameters;
				if (this.ecmaVersion >= 8) node.async = !!isAsync;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.maybeInArrowParameters = true;
				node.params = this.toAssignableList(params, true);
				this.maybeInArrowParameters = false;
				this.parseFunctionBody(node, true, false, forInit);
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				this.maybeInArrowParameters = oldMaybeInArrowParameters;
				return this.finishNode(node, "ArrowFunctionExpression");
			}
			parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {
				if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
				else this.exprAllowed = false;
				let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
				if (refDestructuringErrors) {
					oldParenAssign = refDestructuringErrors.parenthesizedAssign;
					oldTrailingComma = refDestructuringErrors.trailingComma;
					oldDoubleProto = refDestructuringErrors.doubleProto;
					refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
				} else {
					refDestructuringErrors = new DestructuringErrors();
					ownDestructuringErrors = true;
				}
				let startPos = this.start, startLoc = this.startLoc;
				if (this.type === tt.parenL || tokenIsIdentifier(this.type)) {
					this.potentialArrowAt = this.start;
					this.potentialArrowInForAwait = forInit === "await";
				}
				let left = this.parseMaybeConditional(forInit, refDestructuringErrors);
				if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
				if (this.type.isAssign) {
					let node = this.startNodeAt(startPos, startLoc);
					node.operator = this.value;
					if (this.type === tt.eq) left = this.toAssignable(left, true, refDestructuringErrors);
					if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
					if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
					if (!this.maybeInArrowParameters) if (this.type === tt.eq) this.checkLValPattern(left);
					else this.checkLValSimple(left);
					node.left = left;
					this.next();
					node.right = this.parseMaybeAssign(forInit);
					if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
					return this.finishNode(node, "AssignmentExpression");
				} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
				if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
				if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
				return left;
			}
			parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {
				let state;
				let jsx;
				let typeCast;
				if (options?.jsx && (this.matchJsx("jsxTagStart") || this.tsMatchLeftRelational())) {
					state = this.cloneCurLookaheadState();
					jsx = this.tryParse(() => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse), state);
					if (!jsx.error) return jsx.node;
					const context = this.context;
					const currentContext = context[context.length - 1];
					const lastCurrentContext = context[context.length - 2];
					if (currentContext === acornTypeScript.tokContexts.tc_oTag && lastCurrentContext === acornTypeScript.tokContexts.tc_expr) {
						context.pop();
						context.pop();
					} else if (currentContext === acornTypeScript.tokContexts.tc_oTag || currentContext === acornTypeScript.tokContexts.tc_expr) context.pop();
				}
				if (!jsx?.error && !this.tsMatchLeftRelational()) return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
				if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) state = this.cloneCurLookaheadState();
				let typeParameters;
				const arrow = this.tryParse((abort) => {
					typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
					const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
					if (expr.type !== "ArrowFunctionExpression" || expr.extra?.parenthesized) abort();
					if (typeParameters?.params.length !== 0) this.resetStartLocationFromNode(expr, typeParameters);
					expr.typeParameters = typeParameters;
					return expr;
				}, state);
				if (!arrow.error && !arrow.aborted) {
					if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
					return arrow.node;
				}
				if (!jsx) {
					assert(true);
					typeCast = this.tryParse(() => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse), state);
					if (!typeCast.error) return typeCast.node;
				}
				if (jsx?.node) {
					this.setLookaheadState(jsx.failState);
					return jsx.node;
				}
				if (arrow.node) {
					this.setLookaheadState(arrow.failState);
					if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
					return arrow.node;
				}
				if (typeCast?.node) {
					this.setLookaheadState(typeCast.failState);
					return typeCast.node;
				}
				if (jsx?.thrown) throw jsx.error;
				if (arrow.thrown) throw arrow.error;
				if (typeCast?.thrown) throw typeCast.error;
				throw jsx?.error || arrow.error || typeCast?.error;
			}
			parseAssignableListItem(allowModifiers) {
				const decorators = [];
				while (this.match(tokTypes2.at)) decorators.push(this.parseDecorator());
				const startPos = this.start;
				const startLoc = this.startLoc;
				let accessibility;
				let readonly = false;
				let override = false;
				if (allowModifiers !== void 0) {
					const modified = {};
					this.tsParseModifiers({
						modified,
						allowedModifiers: [
							"public",
							"private",
							"protected",
							"override",
							"readonly"
						]
					});
					accessibility = modified.accessibility;
					override = modified.override;
					readonly = modified.readonly;
					if (allowModifiers === false && (accessibility || readonly || override)) this.raise(startLoc.start, TypeScriptError.UnexpectedParameterModifier);
				}
				const left = this.parseMaybeDefault(startPos, startLoc);
				this.parseBindingListItem(left);
				const elt = this.parseMaybeDefault(left["start"], left["loc"], left);
				if (decorators.length) elt.decorators = decorators;
				if (accessibility || readonly || override) {
					const pp$10 = this.startNodeAt(startPos, startLoc);
					if (accessibility) pp$10.accessibility = accessibility;
					if (readonly) pp$10.readonly = readonly;
					if (override) pp$10.override = override;
					if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") this.raise(pp$10.start, TypeScriptError.UnsupportedParameterPropertyKind);
					pp$10.parameter = elt;
					return this.finishNode(pp$10, "TSParameterProperty");
				}
				return elt;
			}
			checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
				switch (expr.type) {
					case "TSParameterProperty":
						this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);
						break;
					default:
						super.checkLValInnerPattern(expr, bindingType, checkClashes);
						break;
				}
			}
			parseBindingListItem(param) {
				if (this.eat(tt.question)) {
					if (param.type !== "Identifier" && !this.isAmbientContext && !this.inType) this.raise(param.start, TypeScriptError.PatternIsOptional);
					param.optional = true;
				}
				const type = this.tsTryParseTypeAnnotation();
				if (type) param.typeAnnotation = type;
				this.resetEndLocation(param);
				return param;
			}
			isAssignable(node, isBinding) {
				switch (node.type) {
					case "TSTypeCastExpression": return this.isAssignable(node.expression, isBinding);
					case "TSParameterProperty": return true;
					case "Identifier":
					case "ObjectPattern":
					case "ArrayPattern":
					case "AssignmentPattern":
					case "RestElement": return true;
					case "ObjectExpression": {
						const last = node.properties.length - 1;
						return node.properties.every((prop, i$1) => {
							return prop.type !== "ObjectMethod" && (i$1 === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
						});
					}
					case "Property":
					case "ObjectProperty": return this.isAssignable(node.value);
					case "SpreadElement": return this.isAssignable(node.argument);
					case "ArrayExpression": return node.elements.every((element) => element === null || this.isAssignable(element));
					case "AssignmentExpression": return node.operator === "=";
					case "ParenthesizedExpression": return this.isAssignable(node.expression);
					case "MemberExpression":
					case "OptionalMemberExpression": return !isBinding;
					default: return false;
				}
			}
			toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors()) {
				switch (node.type) {
					case "ParenthesizedExpression": return this.toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors);
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSNonNullExpression":
					case "TSTypeAssertion":
						if (isBinding) {} else this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);
						return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
					case "MemberExpression": break;
					case "AssignmentExpression":
						if (!isBinding && node.left.type === "TSTypeCastExpression") node.left = this.typeCastToParameter(node.left);
						return super.toAssignable(node, isBinding, refDestructuringErrors);
					case "TSTypeCastExpression": return this.typeCastToParameter(node);
					default: return super.toAssignable(node, isBinding, refDestructuringErrors);
				}
				return node;
			}
			toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {
				switch (node.expression.type) {
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSNonNullExpression":
					case "TSTypeAssertion":
					case "ParenthesizedExpression": return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
					default: return super.toAssignable(node, isBinding, refDestructuringErrors);
				}
			}
			parseBindingAtom() {
				switch (this.type) {
					case tt._this: return this.parseIdent(true);
					default: return super.parseBindingAtom();
				}
			}
			shouldParseArrow(exprList) {
				let shouldParseArrowRes;
				if (this.match(tt.colon)) shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));
				else shouldParseArrowRes = !this.canInsertSemicolon();
				if (shouldParseArrowRes) {
					if (this.match(tt.colon)) {
						const result = this.tryParse((abort) => {
							const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
							if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
							return returnType;
						});
						if (result.aborted) {
							this.shouldParseArrowReturnType = void 0;
							return false;
						}
						if (!result.thrown) {
							if (result.error) this.setLookaheadState(result.failState);
							this.shouldParseArrowReturnType = result.node;
						}
					}
					if (!this.match(tt.arrow)) {
						this.shouldParseArrowReturnType = void 0;
						return false;
					}
					return true;
				}
				this.shouldParseArrowReturnType = void 0;
				return shouldParseArrowRes;
			}
			parseParenArrowList(startPos, startLoc, exprList, forInit) {
				const node = this.startNodeAt(startPos, startLoc);
				node.returnType = this.shouldParseArrowReturnType;
				this.shouldParseArrowReturnType = void 0;
				return this.parseArrowExpression(node, exprList, false, forInit);
			}
			parseParenAndDistinguishExpression(canBeArrow, forInit) {
				let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;
				if (this.ecmaVersion >= 6) {
					const oldMaybeInArrowParameters = this.maybeInArrowParameters;
					this.maybeInArrowParameters = true;
					this.next();
					let innerStartPos = this.start, innerStartLoc = this.startLoc;
					let exprList = [], first = true, lastIsComma = false;
					let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
					this.yieldPos = 0;
					this.awaitPos = 0;
					while (this.type !== tt.parenR) {
						first ? first = false : this.expect(tt.comma);
						if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {
							lastIsComma = true;
							break;
						} else if (this.type === tt.ellipsis) {
							spreadStart = this.start;
							exprList.push(this.parseParenItem(this.parseRestBinding()));
							if (this.type === tt.comma) this.raise(this.start, "Comma is not permitted after the rest element");
							break;
						} else exprList.push(this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem));
					}
					let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
					this.expect(tt.parenR);
					this.maybeInArrowParameters = oldMaybeInArrowParameters;
					if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {
						this.checkPatternErrors(refDestructuringErrors, false);
						this.checkYieldAwaitInDefaultParams();
						this.yieldPos = oldYieldPos;
						this.awaitPos = oldAwaitPos;
						return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
					}
					if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
					if (spreadStart) this.unexpected(spreadStart);
					this.checkExpressionErrors(refDestructuringErrors, true);
					this.yieldPos = oldYieldPos || this.yieldPos;
					this.awaitPos = oldAwaitPos || this.awaitPos;
					if (exprList.length > 1) {
						val = this.startNodeAt(innerStartPos, innerStartLoc);
						val.expressions = exprList;
						this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
					} else val = exprList[0];
				} else val = this.parseParenExpression();
				if (this.options.preserveParens) {
					let par = this.startNodeAt(startPos, startLoc);
					par.expression = val;
					return this.finishNode(par, "ParenthesizedExpression");
				} else return val;
			}
			parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {
				const node = this.startNodeAt(startPos, startLoc);
				node.tag = base;
				node.quasi = this.parseTemplate({ isTagged: true });
				if (optionalChainMember) this.raise(startPos, "Tagged Template Literals are not allowed in optionalChain.");
				return this.finishNode(node, "TaggedTemplateExpression");
			}
			shouldParseAsyncArrow() {
				if (this.match(tt.colon)) {
					const result = this.tryParse((abort) => {
						const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
						if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
						return returnType;
					});
					if (result.aborted) {
						this.shouldParseAsyncArrowReturnType = void 0;
						return false;
					}
					if (!result.thrown) {
						if (result.error) this.setLookaheadState(result.failState);
						this.shouldParseAsyncArrowReturnType = result.node;
						return !this.canInsertSemicolon() && this.eat(tt.arrow);
					}
				} else return !this.canInsertSemicolon() && this.eat(tt.arrow);
			}
			parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {
				const arrN = this.startNodeAt(startPos, startLoc);
				arrN.returnType = this.shouldParseAsyncArrowReturnType;
				this.shouldParseAsyncArrowReturnType = void 0;
				return this.parseArrowExpression(arrN, exprList, true, forInit);
			}
			parseExprList(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
				let elts = [], first = true;
				while (!this.eat(close)) {
					if (!first) {
						this.expect(tt.comma);
						if (allowTrailingComma && this.afterTrailingComma(close)) break;
					} else first = false;
					let elt;
					if (allowEmpty && this.type === tt.comma) elt = null;
					else if (this.type === tt.ellipsis) {
						elt = this.parseSpread(refDestructuringErrors);
						if (this.maybeInArrowParameters && this.match(tt.colon)) elt.typeAnnotation = this.tsParseTypeAnnotation();
						if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
					} else elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);
					elts.push(elt);
				}
				return elts;
			}
			parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
				let _optionalChained = optionalChained;
				if (!this.hasPrecedingLineBreak() && this.value === "!" && this.match(tt.prefix)) {
					this.exprAllowed = false;
					this.next();
					const nonNullExpression = this.startNodeAt(startPos, startLoc);
					nonNullExpression.expression = base;
					base = this.finishNode(nonNullExpression, "TSNonNullExpression");
					return base;
				}
				let isOptionalCall = false;
				if (this.match(tt.questionDot) && this.lookaheadCharCode() === 60) {
					if (noCalls) return base;
					base.optional = true;
					_optionalChained = isOptionalCall = true;
					this.next();
				}
				if (this.tsMatchLeftRelational() || this.match(tt.bitShift)) {
					let missingParenErrorLoc;
					const result = this.tsTryParseAndCatch(() => {
						if (!noCalls && this.atPossibleAsyncArrow(base)) {
							const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit);
							if (asyncArrowFn) {
								base = asyncArrowFn;
								return base;
							}
						}
						const typeArguments = this.tsParseTypeArgumentsInExpression();
						if (!typeArguments) return base;
						if (isOptionalCall && !this.match(tt.parenL)) {
							missingParenErrorLoc = this.curPosition();
							return base;
						}
						if (tokenIsTemplate(this.type) || this.type === tt.backQuote) {
							const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, _optionalChained);
							result2.typeArguments = typeArguments;
							return result2;
						}
						if (!noCalls && this.eat(tt.parenL)) {
							let refDestructuringErrors = new DestructuringErrors();
							const node2 = this.startNodeAt(startPos, startLoc);
							node2.callee = base;
							node2.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false, refDestructuringErrors);
							this.tsCheckForInvalidTypeCasts(node2.arguments);
							node2.typeArguments = typeArguments;
							if (_optionalChained) node2.optional = isOptionalCall;
							this.checkExpressionErrors(refDestructuringErrors, true);
							base = this.finishNode(node2, "CallExpression");
							return base;
						}
						const tokenType$1 = this.type;
						if (this.tsMatchRightRelational() || tokenType$1 === tt.bitShift || tokenType$1 !== tt.parenL && tokenCanStartExpression(tokenType$1) && !this.hasPrecedingLineBreak()) return;
						const node = this.startNodeAt(startPos, startLoc);
						node.expression = base;
						node.typeArguments = typeArguments;
						return this.finishNode(node, "TSInstantiationExpression");
					});
					if (missingParenErrorLoc) this.unexpected(missingParenErrorLoc);
					if (result) {
						if (result.type === "TSInstantiationExpression" && (this.match(tt.dot) || this.match(tt.questionDot) && this.lookaheadCharCode() !== 40)) this.raise(this.start, TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression);
						base = result;
						return base;
					}
				}
				let optionalSupported = this.ecmaVersion >= 11;
				let optional = optionalSupported && this.eat(tt.questionDot);
				if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
				let computed = this.eat(tt.bracketL);
				if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {
					let node = this.startNodeAt(startPos, startLoc);
					node.object = base;
					if (computed) {
						node.property = this.parseExpression();
						this.expect(tt.bracketR);
					} else if (this.type === tt.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
					else node.property = this.parseIdent(this.options.allowReserved !== "never");
					node.computed = !!computed;
					if (optionalSupported) node.optional = optional;
					base = this.finishNode(node, "MemberExpression");
				} else if (!noCalls && this.eat(tt.parenL)) {
					const oldMaybeInArrowParameters = this.maybeInArrowParameters;
					this.maybeInArrowParameters = true;
					let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
					this.yieldPos = 0;
					this.awaitPos = 0;
					this.awaitIdentPos = 0;
					let exprList = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false, refDestructuringErrors);
					if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
						this.checkPatternErrors(refDestructuringErrors, false);
						this.checkYieldAwaitInDefaultParams();
						if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
						this.yieldPos = oldYieldPos;
						this.awaitPos = oldAwaitPos;
						this.awaitIdentPos = oldAwaitIdentPos;
						base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
					} else {
						this.checkExpressionErrors(refDestructuringErrors, true);
						this.yieldPos = oldYieldPos || this.yieldPos;
						this.awaitPos = oldAwaitPos || this.awaitPos;
						this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
						let node = this.startNodeAt(startPos, startLoc);
						node.callee = base;
						node.arguments = exprList;
						if (optionalSupported) node.optional = optional;
						base = this.finishNode(node, "CallExpression");
					}
					this.maybeInArrowParameters = oldMaybeInArrowParameters;
				} else if (this.type === tt.backQuote) {
					if (optional || _optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
					let node = this.startNodeAt(startPos, startLoc);
					node.tag = base;
					node.quasi = this.parseTemplate({ isTagged: true });
					base = this.finishNode(node, "TaggedTemplateExpression");
				}
				return base;
			}
			parseGetterSetter(prop) {
				prop.kind = prop.key.name;
				this.parsePropertyName(prop);
				prop.value = this.parseMethod(false);
				let paramCount = prop.kind === "get" ? 0 : 1;
				const firstParam = prop.value.params[0];
				paramCount = firstParam && this.isThisParam(firstParam) ? paramCount + 1 : paramCount;
				if (prop.value.params.length !== paramCount) {
					let start = prop.value.start;
					if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
					else this.raiseRecoverable(start, "setter should have exactly one param");
				} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
			}
			parseProperty(isPattern, refDestructuringErrors) {
				if (!isPattern) {
					let decorators = [];
					if (this.match(tokTypes2.at)) while (this.match(tokTypes2.at)) decorators.push(this.parseDecorator());
					const property = super.parseProperty(isPattern, refDestructuringErrors);
					if (property.type === "SpreadElement") {
						if (decorators.length) this.raise(property.start, DecoratorsError.SpreadElementDecorator);
					}
					if (decorators.length) {
						property.decorators = decorators;
						decorators = [];
					}
					return property;
				}
				return super.parseProperty(isPattern, refDestructuringErrors);
			}
			parseCatchClauseParam() {
				const param = this.parseBindingAtom();
				let simple = param.type === "Identifier";
				this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);
				this.checkLValPattern(param, simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL);
				const type = this.tsTryParseTypeAnnotation();
				if (type) {
					param.typeAnnotation = type;
					this.resetEndLocation(param);
				}
				this.expect(tt.parenR);
				return param;
			}
			parseClass(node, isStatement) {
				const oldInAbstractClass = this.inAbstractClass;
				this.inAbstractClass = !!node.abstract;
				try {
					this.next();
					this.takeDecorators(node);
					const oldStrict = this.strict;
					this.strict = true;
					this.parseClassId(node, isStatement);
					this.parseClassSuper(node);
					const privateNameMap = this.enterClassBody();
					const classBody = this.startNode();
					let hadConstructor = false;
					classBody.body = [];
					let decorators = [];
					this.expect(tt.braceL);
					while (this.type !== tt.braceR) {
						if (this.match(tokTypes2.at)) {
							decorators.push(this.parseDecorator());
							continue;
						}
						const element = this.parseClassElement(node.superClass !== null);
						if (decorators.length) {
							element.decorators = decorators;
							this.resetStartLocationFromNode(element, decorators[0]);
							decorators = [];
						}
						if (element) {
							classBody.body.push(element);
							if (element.type === "MethodDefinition" && element.kind === "constructor" && element.value.type === "FunctionExpression") {
								if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
								hadConstructor = true;
								if (element.decorators && element.decorators.length > 0) this.raise(element.start, DecoratorsError.DecoratorConstructor);
							} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, `Identifier '#${element.key.name}' has already been declared`);
						}
					}
					this.strict = oldStrict;
					this.next();
					if (decorators.length) this.raise(this.start, DecoratorsError.TrailingDecorator);
					node.body = this.finishNode(classBody, "ClassBody");
					this.exitClassBody();
					return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
				} finally {
					this.inAbstractClass = oldInAbstractClass;
				}
			}
			parseClassFunctionParams() {
				const typeParameters = this.tsTryParseTypeParameters();
				let params = this.parseBindingList(tt.parenR, false, this.ecmaVersion >= 8, true);
				if (typeParameters) params.typeParameters = typeParameters;
				return params;
			}
			parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method) {
				let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
				this.initFunction(node);
				if (this.ecmaVersion >= 6) node.generator = isGenerator;
				if (this.ecmaVersion >= 8) node.async = !!isAsync;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.enterScope(functionFlags(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0));
				this.expect(tt.parenL);
				node.params = this.parseClassFunctionParams();
				this.checkYieldAwaitInDefaultParams();
				this.parseFunctionBody(node, false, true, false, { isClassMethod: inClassScope });
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				if (method && method.abstract) {
					if (!!node.body) {
						const { key } = method;
						this.raise(method.start, TypeScriptError.AbstractMethodHasImplementation({ methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]` }));
					}
				}
				return this.finishNode(node, "FunctionExpression");
			}
			static parse(input, options2) {
				if (options2.locations === false) throw new Error(`You have to enable options.locations while using acorn-typescript`);
				else options2.locations = true;
				const parser$2 = new this(options2, input);
				if (dts) parser$2.isAmbientContext = true;
				return parser$2.parse();
			}
			static parseExpressionAt(input, pos, options2) {
				if (options2.locations === false) throw new Error(`You have to enable options.locations while using acorn-typescript`);
				else options2.locations = true;
				const parser$2 = new this(options2, input, pos);
				if (dts) parser$2.isAmbientContext = true;
				parser$2.nextToken();
				return parser$2.parseExpression();
			}
			parseImportSpecifier() {
				if (this.ts_isContextual(tokTypes2.type)) {
					let node = this.startNode();
					node.imported = this.parseModuleExportName();
					this.parseTypeOnlyImportExportSpecifier(node, true, this.importOrExportOuterKind === "type");
					return this.finishNode(node, "ImportSpecifier");
				} else {
					const node = super.parseImportSpecifier();
					node.importKind = "value";
					return node;
				}
			}
			parseExportSpecifier(exports$1) {
				const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
				if (!this.match(tt.string) && isMaybeTypeOnly) {
					let node = this.startNode();
					node.local = this.parseModuleExportName();
					this.parseTypeOnlyImportExportSpecifier(node, false, this.importOrExportOuterKind === "type");
					this.finishNode(node, "ExportSpecifier");
					this.checkExport(exports$1, node.exported, node.exported.start);
					return node;
				} else {
					const node = super.parseExportSpecifier(exports$1);
					node.exportKind = "value";
					return node;
				}
			}
			parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
				const leftOfAsKey = isImport ? "imported" : "local";
				const rightOfAsKey = isImport ? "local" : "exported";
				let leftOfAs = node[leftOfAsKey];
				let rightOfAs;
				let hasTypeSpecifier = false;
				let canParseAsKeyword = true;
				const loc = leftOfAs.start;
				if (this.isContextual("as")) {
					const firstAs = this.parseIdent();
					if (this.isContextual("as")) {
						const secondAs = this.parseIdent();
						if (tokenIsKeywordOrIdentifier(this.type)) {
							hasTypeSpecifier = true;
							leftOfAs = firstAs;
							rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
							canParseAsKeyword = false;
						} else {
							rightOfAs = secondAs;
							canParseAsKeyword = false;
						}
					} else if (tokenIsKeywordOrIdentifier(this.type)) {
						canParseAsKeyword = false;
						rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
					} else {
						hasTypeSpecifier = true;
						leftOfAs = firstAs;
					}
				} else if (tokenIsKeywordOrIdentifier(this.type)) {
					hasTypeSpecifier = true;
					if (isImport) {
						leftOfAs = super.parseIdent(true);
						if (!this.isContextual("as")) this.checkUnreserved(leftOfAs);
					} else leftOfAs = this.parseModuleExportName();
				}
				if (hasTypeSpecifier && isInTypeOnlyImportExport) this.raise(loc, isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports);
				node[leftOfAsKey] = leftOfAs;
				node[rightOfAsKey] = rightOfAs;
				const kindKey = isImport ? "importKind" : "exportKind";
				node[kindKey] = hasTypeSpecifier ? "type" : "value";
				if (canParseAsKeyword && this.eatContextual("as")) node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();
				if (!node[rightOfAsKey]) node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);
				if (isImport) this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);
			}
			raiseCommonCheck(pos, message, recoverable) {
				switch (message) {
					case "Comma is not permitted after the rest element": if (this.isAmbientContext && this.match(tt.comma) && this.lookaheadCharCode() === 41) {
						this.next();
						return;
					} else return super.raise(pos, message);
				}
				return recoverable ? super.raiseRecoverable(pos, message) : super.raise(pos, message);
			}
			raiseRecoverable(pos, message) {
				return this.raiseCommonCheck(pos, message, true);
			}
			raise(pos, message) {
				return this.raiseCommonCheck(pos, message, true);
			}
			updateContext(prevType) {
				const { type } = this;
				if (type == tt.braceL) {
					var curContext = this.curContext();
					if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);
					else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);
					else super.updateContext(prevType);
					this.exprAllowed = true;
				} else if (type === tt.slash && prevType === tokTypes2.jsxTagStart) {
					this.context.length -= 2;
					this.context.push(tsTokContexts.tc_cTag);
					this.exprAllowed = false;
				} else return super.updateContext(prevType);
			}
			jsx_parseOpeningElementAt(startPos, startLoc) {
				let node = this.startNodeAt(startPos, startLoc);
				let nodeName = this.jsx_parseElementName();
				if (nodeName) node.name = nodeName;
				if (this.match(tt.relational) || this.match(tt.bitShift)) {
					const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
					if (typeArguments) node.typeArguments = typeArguments;
				}
				node.attributes = [];
				while (this.type !== tt.slash && this.type !== tokTypes2.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());
				node.selfClosing = this.eat(tt.slash);
				this.expect(tokTypes2.jsxTagEnd);
				return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
			}
			enterScope(flags) {
				if (flags === TS_SCOPE_TS_MODULE) this.importsStack.push([]);
				super.enterScope(flags);
				const scope = super.currentScope();
				scope.types = [];
				scope.enums = [];
				scope.constEnums = [];
				scope.classes = [];
				scope.exportOnlyBindings = [];
			}
			exitScope() {
				if (super.currentScope().flags === TS_SCOPE_TS_MODULE) this.importsStack.pop();
				super.exitScope();
			}
			hasImport(name, allowShadow) {
				const len = this.importsStack.length;
				if (this.importsStack[len - 1].indexOf(name) > -1) return true;
				if (!allowShadow && len > 1) {
					for (let i$1 = 0; i$1 < len - 1; i$1++) if (this.importsStack[i$1].indexOf(name) > -1) return true;
				}
				return false;
			}
			maybeExportDefined(scope, name) {
				if (this.inModule && scope.flags & acornScope.SCOPE_TOP) this.undefinedExports.delete(name);
			}
			declareName(name, bindingType, pos) {
				if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {
					if (this.hasImport(name, true)) this.raise(pos, `Identifier '${name}' has already been declared.`);
					this.importsStack[this.importsStack.length - 1].push(name);
					return;
				}
				const scope = this.currentScope();
				if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {
					this.maybeExportDefined(scope, name);
					scope.exportOnlyBindings.push(name);
					return;
				}
				if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {
					if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name)) this.raise(pos, `type '${name}' has already been declared.`);
					scope.types.push(name);
				} else super.declareName(name, bindingType, pos);
				if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name);
				if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
				if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name);
			}
			checkLocalExport(id) {
				const { name } = id;
				if (this.hasImport(name)) return;
				const len = this.scopeStack.length;
				for (let i$1 = len - 1; i$1 >= 0; i$1--) {
					const scope = this.scopeStack[i$1];
					if (scope.types.indexOf(name) > -1 || scope.exportOnlyBindings.indexOf(name) > -1) return;
				}
				super.checkLocalExport(id);
			}
		}
		return TypeScriptParser;
	};
}

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/identity.js
var require_identity = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/identity.js": ((exports) => {
	const ALIAS = Symbol.for("yaml.alias");
	const DOC = Symbol.for("yaml.document");
	const MAP = Symbol.for("yaml.map");
	const PAIR = Symbol.for("yaml.pair");
	const SCALAR$1 = Symbol.for("yaml.scalar");
	const SEQ = Symbol.for("yaml.seq");
	const NODE_TYPE = Symbol.for("yaml.node.type");
	const isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
	const isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
	const isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
	const isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
	const isScalar$1 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR$1;
	const isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
	function isCollection$1(node) {
		if (node && typeof node === "object") switch (node[NODE_TYPE]) {
			case MAP:
			case SEQ: return true;
		}
		return false;
	}
	function isNode(node) {
		if (node && typeof node === "object") switch (node[NODE_TYPE]) {
			case ALIAS:
			case MAP:
			case SCALAR$1:
			case SEQ: return true;
		}
		return false;
	}
	const hasAnchor = (node) => (isScalar$1(node) || isCollection$1(node)) && !!node.anchor;
	exports.ALIAS = ALIAS;
	exports.DOC = DOC;
	exports.MAP = MAP;
	exports.NODE_TYPE = NODE_TYPE;
	exports.PAIR = PAIR;
	exports.SCALAR = SCALAR$1;
	exports.SEQ = SEQ;
	exports.hasAnchor = hasAnchor;
	exports.isAlias = isAlias;
	exports.isCollection = isCollection$1;
	exports.isDocument = isDocument;
	exports.isMap = isMap;
	exports.isNode = isNode;
	exports.isPair = isPair;
	exports.isScalar = isScalar$1;
	exports.isSeq = isSeq;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/visit.js
var require_visit = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/visit.js": ((exports) => {
	var identity$33 = require_identity();
	const BREAK$1 = Symbol("break visit");
	const SKIP$1 = Symbol("skip children");
	const REMOVE$1 = Symbol("remove node");
	/**
	* Apply a visitor to an AST node or document.
	*
	* Walks through the tree (depth-first) starting from `node`, calling a
	* `visitor` function with three arguments:
	*   - `key`: For sequence values and map `Pair`, the node's index in the
	*     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
	*     `null` for the root node.
	*   - `node`: The current node.
	*   - `path`: The ancestry of the current node.
	*
	* The return value of the visitor may be used to control the traversal:
	*   - `undefined` (default): Do nothing and continue
	*   - `visit.SKIP`: Do not visit the children of this node, continue with next
	*     sibling
	*   - `visit.BREAK`: Terminate traversal completely
	*   - `visit.REMOVE`: Remove the current node, then continue with the next one
	*   - `Node`: Replace the current node, then continue by visiting it
	*   - `number`: While iterating the items of a sequence or map, set the index
	*     of the next step. This is useful especially if the index of the current
	*     node has changed.
	*
	* If `visitor` is a single function, it will be called with all values
	* encountered in the tree, including e.g. `null` values. Alternatively,
	* separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
	* `Alias` and `Scalar` node. To define the same visitor function for more than
	* one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
	* and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
	* specific defined one will be used for each node.
	*/
	function visit$5(node, visitor) {
		const visitor_ = initVisitor(visitor);
		if (identity$33.isDocument(node)) {
			if (visit_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE$1) node.contents = null;
		} else visit_(null, node, visitor_, Object.freeze([]));
	}
	/** Terminate visit traversal completely */
	visit$5.BREAK = BREAK$1;
	/** Do not visit the children of the current node */
	visit$5.SKIP = SKIP$1;
	/** Remove the current node */
	visit$5.REMOVE = REMOVE$1;
	function visit_(key, node, visitor, path$2) {
		const ctrl = callVisitor(key, node, visitor, path$2);
		if (identity$33.isNode(ctrl) || identity$33.isPair(ctrl)) {
			replaceNode(key, path$2, ctrl);
			return visit_(key, ctrl, visitor, path$2);
		}
		if (typeof ctrl !== "symbol") {
			if (identity$33.isCollection(node)) {
				path$2 = Object.freeze(path$2.concat(node));
				for (let i$1 = 0; i$1 < node.items.length; ++i$1) {
					const ci = visit_(i$1, node.items[i$1], visitor, path$2);
					if (typeof ci === "number") i$1 = ci - 1;
					else if (ci === BREAK$1) return BREAK$1;
					else if (ci === REMOVE$1) {
						node.items.splice(i$1, 1);
						i$1 -= 1;
					}
				}
			} else if (identity$33.isPair(node)) {
				path$2 = Object.freeze(path$2.concat(node));
				const ck = visit_("key", node.key, visitor, path$2);
				if (ck === BREAK$1) return BREAK$1;
				else if (ck === REMOVE$1) node.key = null;
				const cv = visit_("value", node.value, visitor, path$2);
				if (cv === BREAK$1) return BREAK$1;
				else if (cv === REMOVE$1) node.value = null;
			}
		}
		return ctrl;
	}
	/**
	* Apply an async visitor to an AST node or document.
	*
	* Walks through the tree (depth-first) starting from `node`, calling a
	* `visitor` function with three arguments:
	*   - `key`: For sequence values and map `Pair`, the node's index in the
	*     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
	*     `null` for the root node.
	*   - `node`: The current node.
	*   - `path`: The ancestry of the current node.
	*
	* The return value of the visitor may be used to control the traversal:
	*   - `Promise`: Must resolve to one of the following values
	*   - `undefined` (default): Do nothing and continue
	*   - `visit.SKIP`: Do not visit the children of this node, continue with next
	*     sibling
	*   - `visit.BREAK`: Terminate traversal completely
	*   - `visit.REMOVE`: Remove the current node, then continue with the next one
	*   - `Node`: Replace the current node, then continue by visiting it
	*   - `number`: While iterating the items of a sequence or map, set the index
	*     of the next step. This is useful especially if the index of the current
	*     node has changed.
	*
	* If `visitor` is a single function, it will be called with all values
	* encountered in the tree, including e.g. `null` values. Alternatively,
	* separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
	* `Alias` and `Scalar` node. To define the same visitor function for more than
	* one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
	* and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
	* specific defined one will be used for each node.
	*/
	async function visitAsync(node, visitor) {
		const visitor_ = initVisitor(visitor);
		if (identity$33.isDocument(node)) {
			if (await visitAsync_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE$1) node.contents = null;
		} else await visitAsync_(null, node, visitor_, Object.freeze([]));
	}
	/** Terminate visit traversal completely */
	visitAsync.BREAK = BREAK$1;
	/** Do not visit the children of the current node */
	visitAsync.SKIP = SKIP$1;
	/** Remove the current node */
	visitAsync.REMOVE = REMOVE$1;
	async function visitAsync_(key, node, visitor, path$2) {
		const ctrl = await callVisitor(key, node, visitor, path$2);
		if (identity$33.isNode(ctrl) || identity$33.isPair(ctrl)) {
			replaceNode(key, path$2, ctrl);
			return visitAsync_(key, ctrl, visitor, path$2);
		}
		if (typeof ctrl !== "symbol") {
			if (identity$33.isCollection(node)) {
				path$2 = Object.freeze(path$2.concat(node));
				for (let i$1 = 0; i$1 < node.items.length; ++i$1) {
					const ci = await visitAsync_(i$1, node.items[i$1], visitor, path$2);
					if (typeof ci === "number") i$1 = ci - 1;
					else if (ci === BREAK$1) return BREAK$1;
					else if (ci === REMOVE$1) {
						node.items.splice(i$1, 1);
						i$1 -= 1;
					}
				}
			} else if (identity$33.isPair(node)) {
				path$2 = Object.freeze(path$2.concat(node));
				const ck = await visitAsync_("key", node.key, visitor, path$2);
				if (ck === BREAK$1) return BREAK$1;
				else if (ck === REMOVE$1) node.key = null;
				const cv = await visitAsync_("value", node.value, visitor, path$2);
				if (cv === BREAK$1) return BREAK$1;
				else if (cv === REMOVE$1) node.value = null;
			}
		}
		return ctrl;
	}
	function initVisitor(visitor) {
		if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) return Object.assign({
			Alias: visitor.Node,
			Map: visitor.Node,
			Scalar: visitor.Node,
			Seq: visitor.Node
		}, visitor.Value && {
			Map: visitor.Value,
			Scalar: visitor.Value,
			Seq: visitor.Value
		}, visitor.Collection && {
			Map: visitor.Collection,
			Seq: visitor.Collection
		}, visitor);
		return visitor;
	}
	function callVisitor(key, node, visitor, path$2) {
		if (typeof visitor === "function") return visitor(key, node, path$2);
		if (identity$33.isMap(node)) return visitor.Map?.(key, node, path$2);
		if (identity$33.isSeq(node)) return visitor.Seq?.(key, node, path$2);
		if (identity$33.isPair(node)) return visitor.Pair?.(key, node, path$2);
		if (identity$33.isScalar(node)) return visitor.Scalar?.(key, node, path$2);
		if (identity$33.isAlias(node)) return visitor.Alias?.(key, node, path$2);
	}
	function replaceNode(key, path$2, node) {
		const parent = path$2[path$2.length - 1];
		if (identity$33.isCollection(parent)) parent.items[key] = node;
		else if (identity$33.isPair(parent)) if (key === "key") parent.key = node;
		else parent.value = node;
		else if (identity$33.isDocument(parent)) parent.contents = node;
		else {
			const pt = identity$33.isAlias(parent) ? "alias" : "scalar";
			throw new Error(`Cannot replace node with ${pt} parent`);
		}
	}
	exports.visit = visit$5;
	exports.visitAsync = visitAsync;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/directives.js
var require_directives = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/directives.js": ((exports) => {
	var identity$32 = require_identity();
	var visit$4 = require_visit();
	const escapeChars = {
		"!": "%21",
		",": "%2C",
		"[": "%5B",
		"]": "%5D",
		"{": "%7B",
		"}": "%7D"
	};
	const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
	var Directives = class Directives {
		constructor(yaml, tags$1) {
			/**
			* The directives-end/doc-start marker `---`. If `null`, a marker may still be
			* included in the document's stringified representation.
			*/
			this.docStart = null;
			/** The doc-end marker `...`.  */
			this.docEnd = false;
			this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
			this.tags = Object.assign({}, Directives.defaultTags, tags$1);
		}
		clone() {
			const copy$1 = new Directives(this.yaml, this.tags);
			copy$1.docStart = this.docStart;
			return copy$1;
		}
		/**
		* During parsing, get a Directives instance for the current document and
		* update the stream state according to the current version's spec.
		*/
		atDocument() {
			const res = new Directives(this.yaml, this.tags);
			switch (this.yaml.version) {
				case "1.1":
					this.atNextDocument = true;
					break;
				case "1.2":
					this.atNextDocument = false;
					this.yaml = {
						explicit: Directives.defaultYaml.explicit,
						version: "1.2"
					};
					this.tags = Object.assign({}, Directives.defaultTags);
					break;
			}
			return res;
		}
		/**
		* @param onError - May be called even if the action was successful
		* @returns `true` on success
		*/
		add(line, onError) {
			if (this.atNextDocument) {
				this.yaml = {
					explicit: Directives.defaultYaml.explicit,
					version: "1.1"
				};
				this.tags = Object.assign({}, Directives.defaultTags);
				this.atNextDocument = false;
			}
			const parts = line.trim().split(/[ \t]+/);
			const name = parts.shift();
			switch (name) {
				case "%TAG": {
					if (parts.length !== 2) {
						onError(0, "%TAG directive should contain exactly two parts");
						if (parts.length < 2) return false;
					}
					const [handle$1, prefix] = parts;
					this.tags[handle$1] = prefix;
					return true;
				}
				case "%YAML": {
					this.yaml.explicit = true;
					if (parts.length !== 1) {
						onError(0, "%YAML directive should contain exactly one part");
						return false;
					}
					const [version$1] = parts;
					if (version$1 === "1.1" || version$1 === "1.2") {
						this.yaml.version = version$1;
						return true;
					} else {
						const isValid = /^\d+\.\d+$/.test(version$1);
						onError(6, `Unsupported YAML version ${version$1}`, isValid);
						return false;
					}
				}
				default:
					onError(0, `Unknown directive ${name}`, true);
					return false;
			}
		}
		/**
		* Resolves a tag, matching handles to those defined in %TAG directives.
		*
		* @returns Resolved tag, which may also be the non-specific tag `'!'` or a
		*   `'!local'` tag, or `null` if unresolvable.
		*/
		tagName(source, onError) {
			if (source === "!") return "!";
			if (source[0] !== "!") {
				onError(`Not a valid tag: ${source}`);
				return null;
			}
			if (source[1] === "<") {
				const verbatim = source.slice(2, -1);
				if (verbatim === "!" || verbatim === "!!") {
					onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
					return null;
				}
				if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
				return verbatim;
			}
			const [, handle$1, suffix] = source.match(/^(.*!)([^!]*)$/s);
			if (!suffix) onError(`The ${source} tag has no suffix`);
			const prefix = this.tags[handle$1];
			if (prefix) try {
				return prefix + decodeURIComponent(suffix);
			} catch (error) {
				onError(String(error));
				return null;
			}
			if (handle$1 === "!") return source;
			onError(`Could not resolve tag: ${source}`);
			return null;
		}
		/**
		* Given a fully resolved tag, returns its printable string form,
		* taking into account current tag prefixes and defaults.
		*/
		tagString(tag) {
			for (const [handle$1, prefix] of Object.entries(this.tags)) if (tag.startsWith(prefix)) return handle$1 + escapeTagName(tag.substring(prefix.length));
			return tag[0] === "!" ? tag : `!<${tag}>`;
		}
		toString(doc) {
			const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
			const tagEntries = Object.entries(this.tags);
			let tagNames;
			if (doc && tagEntries.length > 0 && identity$32.isNode(doc.contents)) {
				const tags$1 = {};
				visit$4.visit(doc.contents, (_key, node) => {
					if (identity$32.isNode(node) && node.tag) tags$1[node.tag] = true;
				});
				tagNames = Object.keys(tags$1);
			} else tagNames = [];
			for (const [handle$1, prefix] of tagEntries) {
				if (handle$1 === "!!" && prefix === "tag:yaml.org,2002:") continue;
				if (!doc || tagNames.some((tn) => tn.startsWith(prefix))) lines.push(`%TAG ${handle$1} ${prefix}`);
			}
			return lines.join("\n");
		}
	};
	Directives.defaultYaml = {
		explicit: false,
		version: "1.2"
	};
	Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
	exports.Directives = Directives;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/anchors.js
var require_anchors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/anchors.js": ((exports) => {
	var identity$31 = require_identity();
	var visit$3 = require_visit();
	/**
	* Verify that the input string is a valid anchor.
	*
	* Will throw on errors.
	*/
	function anchorIsValid(anchor) {
		if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
			const msg = `Anchor must not contain whitespace or control characters: ${JSON.stringify(anchor)}`;
			throw new Error(msg);
		}
		return true;
	}
	function anchorNames(root$1) {
		const anchors$3 = /* @__PURE__ */ new Set();
		visit$3.visit(root$1, { Value(_key, node) {
			if (node.anchor) anchors$3.add(node.anchor);
		} });
		return anchors$3;
	}
	/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
	function findNewAnchor(prefix, exclude) {
		for (let i$1 = 1;; ++i$1) {
			const name = `${prefix}${i$1}`;
			if (!exclude.has(name)) return name;
		}
	}
	function createNodeAnchors(doc, prefix) {
		const aliasObjects = [];
		const sourceObjects = /* @__PURE__ */ new Map();
		let prevAnchors = null;
		return {
			onAnchor: (source) => {
				aliasObjects.push(source);
				prevAnchors ?? (prevAnchors = anchorNames(doc));
				const anchor = findNewAnchor(prefix, prevAnchors);
				prevAnchors.add(anchor);
				return anchor;
			},
			setAnchors: () => {
				for (const source of aliasObjects) {
					const ref$1 = sourceObjects.get(source);
					if (typeof ref$1 === "object" && ref$1.anchor && (identity$31.isScalar(ref$1.node) || identity$31.isCollection(ref$1.node))) ref$1.node.anchor = ref$1.anchor;
					else {
						const error = /* @__PURE__ */ new Error("Failed to resolve repeated object (this should not happen)");
						error.source = source;
						throw error;
					}
				}
			},
			sourceObjects
		};
	}
	exports.anchorIsValid = anchorIsValid;
	exports.anchorNames = anchorNames;
	exports.createNodeAnchors = createNodeAnchors;
	exports.findNewAnchor = findNewAnchor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/applyReviver.js": ((exports) => {
	/**
	* Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
	* in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
	* 2021 edition: https://tc39.es/ecma262/#sec-json.parse
	*
	* Includes extensions for handling Map and Set objects.
	*/
	function applyReviver$2(reviver, obj, key, val) {
		if (val && typeof val === "object") if (Array.isArray(val)) for (let i$1 = 0, len = val.length; i$1 < len; ++i$1) {
			const v0 = val[i$1];
			const v1 = applyReviver$2(reviver, val, String(i$1), v0);
			if (v1 === void 0) delete val[i$1];
			else if (v1 !== v0) val[i$1] = v1;
		}
		else if (val instanceof Map) for (const k$2 of Array.from(val.keys())) {
			const v0 = val.get(k$2);
			const v1 = applyReviver$2(reviver, val, k$2, v0);
			if (v1 === void 0) val.delete(k$2);
			else if (v1 !== v0) val.set(k$2, v1);
		}
		else if (val instanceof Set) for (const v0 of Array.from(val)) {
			const v1 = applyReviver$2(reviver, val, v0, v0);
			if (v1 === void 0) val.delete(v0);
			else if (v1 !== v0) {
				val.delete(v0);
				val.add(v1);
			}
		}
		else for (const [k$2, v0] of Object.entries(val)) {
			const v1 = applyReviver$2(reviver, val, k$2, v0);
			if (v1 === void 0) delete val[k$2];
			else if (v1 !== v0) val[k$2] = v1;
		}
		return reviver.call(obj, key, val);
	}
	exports.applyReviver = applyReviver$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/toJS.js": ((exports) => {
	var identity$30 = require_identity();
	/**
	* Recursively convert any node or its contents to native JavaScript
	*
	* @param value - The input value
	* @param arg - If `value` defines a `toJSON()` method, use this
	*   as its first argument
	* @param ctx - Conversion context, originally set in Document#toJS(). If
	*   `{ keep: true }` is not set, output should be suitable for JSON
	*   stringification.
	*/
	function toJS$7(value, arg, ctx) {
		if (Array.isArray(value)) return value.map((v$2, i$1) => toJS$7(v$2, String(i$1), ctx));
		if (value && typeof value.toJSON === "function") {
			if (!ctx || !identity$30.hasAnchor(value)) return value.toJSON(arg, ctx);
			const data$1 = {
				aliasCount: 0,
				count: 1,
				res: void 0
			};
			ctx.anchors.set(value, data$1);
			ctx.onCreate = (res$1) => {
				data$1.res = res$1;
				delete ctx.onCreate;
			};
			const res = value.toJSON(arg, ctx);
			if (ctx.onCreate) ctx.onCreate(res);
			return res;
		}
		if (typeof value === "bigint" && !ctx?.keep) return Number(value);
		return value;
	}
	exports.toJS = toJS$7;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Node.js
var require_Node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Node.js": ((exports) => {
	var applyReviver$1 = require_applyReviver();
	var identity$29 = require_identity();
	var toJS$6 = require_toJS();
	var NodeBase = class {
		constructor(type) {
			Object.defineProperty(this, identity$29.NODE_TYPE, { value: type });
		}
		/** Create a copy of this node.  */
		clone() {
			const copy$1 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
			if (this.range) copy$1.range = this.range.slice();
			return copy$1;
		}
		/** A plain JavaScript representation of this node. */
		toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
			if (!identity$29.isDocument(doc)) throw new TypeError("A document argument is required");
			const ctx = {
				anchors: /* @__PURE__ */ new Map(),
				doc,
				keep: true,
				mapAsMap: mapAsMap === true,
				mapKeyWarned: false,
				maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
			};
			const res = toJS$6.toJS(this, "", ctx);
			if (typeof onAnchor === "function") for (const { count, res: res$1 } of ctx.anchors.values()) onAnchor(res$1, count);
			return typeof reviver === "function" ? applyReviver$1.applyReviver(reviver, { "": res }, "", res) : res;
		}
	};
	exports.NodeBase = NodeBase;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Alias.js": ((exports) => {
	var anchors$2 = require_anchors();
	var visit$2 = require_visit();
	var identity$28 = require_identity();
	var Node$2 = require_Node();
	var toJS$5 = require_toJS();
	var Alias$4 = class extends Node$2.NodeBase {
		constructor(source) {
			super(identity$28.ALIAS);
			this.source = source;
			Object.defineProperty(this, "tag", { set() {
				throw new Error("Alias nodes cannot have tags");
			} });
		}
		/**
		* Resolve the value of this alias within `doc`, finding the last
		* instance of the `source` anchor before this node.
		*/
		resolve(doc, ctx) {
			let nodes;
			if (ctx?.aliasResolveCache) nodes = ctx.aliasResolveCache;
			else {
				nodes = [];
				visit$2.visit(doc, { Node: (_key, node) => {
					if (identity$28.isAlias(node) || identity$28.hasAnchor(node)) nodes.push(node);
				} });
				if (ctx) ctx.aliasResolveCache = nodes;
			}
			let found = void 0;
			for (const node of nodes) {
				if (node === this) break;
				if (node.anchor === this.source) found = node;
			}
			return found;
		}
		toJSON(_arg, ctx) {
			if (!ctx) return { source: this.source };
			const { anchors: anchors$3, doc, maxAliasCount } = ctx;
			const source = this.resolve(doc, ctx);
			if (!source) {
				const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
				throw new ReferenceError(msg);
			}
			let data$1 = anchors$3.get(source);
			if (!data$1) {
				toJS$5.toJS(source, null, ctx);
				data$1 = anchors$3.get(source);
			}
			/* istanbul ignore if */
			if (!data$1 || data$1.res === void 0) throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
			if (maxAliasCount >= 0) {
				data$1.count += 1;
				if (data$1.aliasCount === 0) data$1.aliasCount = getAliasCount(doc, source, anchors$3);
				if (data$1.count * data$1.aliasCount > maxAliasCount) throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
			}
			return data$1.res;
		}
		toString(ctx, _onComment, _onChompKeep) {
			const src = `*${this.source}`;
			if (ctx) {
				anchors$2.anchorIsValid(this.source);
				if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
					const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
					throw new Error(msg);
				}
				if (ctx.implicitKey) return `${src} `;
			}
			return src;
		}
	};
	function getAliasCount(doc, node, anchors$3) {
		if (identity$28.isAlias(node)) {
			const source = node.resolve(doc);
			const anchor = anchors$3 && source && anchors$3.get(source);
			return anchor ? anchor.count * anchor.aliasCount : 0;
		} else if (identity$28.isCollection(node)) {
			let count = 0;
			for (const item of node.items) {
				const c$2 = getAliasCount(doc, item, anchors$3);
				if (c$2 > count) count = c$2;
			}
			return count;
		} else if (identity$28.isPair(node)) {
			const kc = getAliasCount(doc, node.key, anchors$3);
			const vc = getAliasCount(doc, node.value, anchors$3);
			return Math.max(kc, vc);
		}
		return 1;
	}
	exports.Alias = Alias$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Scalar.js": ((exports) => {
	var identity$27 = require_identity();
	var Node$1 = require_Node();
	var toJS$4 = require_toJS();
	const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
	var Scalar$19 = class extends Node$1.NodeBase {
		constructor(value) {
			super(identity$27.SCALAR);
			this.value = value;
		}
		toJSON(arg, ctx) {
			return ctx?.keep ? this.value : toJS$4.toJS(this.value, arg, ctx);
		}
		toString() {
			return String(this.value);
		}
	};
	Scalar$19.BLOCK_FOLDED = "BLOCK_FOLDED";
	Scalar$19.BLOCK_LITERAL = "BLOCK_LITERAL";
	Scalar$19.PLAIN = "PLAIN";
	Scalar$19.QUOTE_DOUBLE = "QUOTE_DOUBLE";
	Scalar$19.QUOTE_SINGLE = "QUOTE_SINGLE";
	exports.Scalar = Scalar$19;
	exports.isScalarValue = isScalarValue;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/createNode.js
var require_createNode = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/createNode.js": ((exports) => {
	var Alias$3 = require_Alias();
	var identity$26 = require_identity();
	var Scalar$18 = require_Scalar();
	const defaultTagPrefix = "tag:yaml.org,2002:";
	function findTagObject(value, tagName, tags$1) {
		if (tagName) {
			const match = tags$1.filter((t) => t.tag === tagName);
			const tagObj = match.find((t) => !t.format) ?? match[0];
			if (!tagObj) throw new Error(`Tag ${tagName} not found`);
			return tagObj;
		}
		return tags$1.find((t) => t.identify?.(value) && !t.format);
	}
	function createNode$4(value, tagName, ctx) {
		if (identity$26.isDocument(value)) value = value.contents;
		if (identity$26.isNode(value)) return value;
		if (identity$26.isPair(value)) {
			const map$6 = ctx.schema[identity$26.MAP].createNode?.(ctx.schema, null, ctx);
			map$6.items.push(value);
			return map$6;
		}
		if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) value = value.valueOf();
		const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema$6, sourceObjects } = ctx;
		let ref$1 = void 0;
		if (aliasDuplicateObjects && value && typeof value === "object") {
			ref$1 = sourceObjects.get(value);
			if (ref$1) {
				ref$1.anchor ?? (ref$1.anchor = onAnchor(value));
				return new Alias$3.Alias(ref$1.anchor);
			} else {
				ref$1 = {
					anchor: null,
					node: null
				};
				sourceObjects.set(value, ref$1);
			}
		}
		if (tagName?.startsWith("!!")) tagName = defaultTagPrefix + tagName.slice(2);
		let tagObj = findTagObject(value, tagName, schema$6.tags);
		if (!tagObj) {
			if (value && typeof value.toJSON === "function") value = value.toJSON();
			if (!value || typeof value !== "object") {
				const node$1 = new Scalar$18.Scalar(value);
				if (ref$1) ref$1.node = node$1;
				return node$1;
			}
			tagObj = value instanceof Map ? schema$6[identity$26.MAP] : Symbol.iterator in Object(value) ? schema$6[identity$26.SEQ] : schema$6[identity$26.MAP];
		}
		if (onTagObj) {
			onTagObj(tagObj);
			delete ctx.onTagObj;
		}
		const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar$18.Scalar(value);
		if (tagName) node.tag = tagName;
		else if (!tagObj.default) node.tag = tagObj.tag;
		if (ref$1) ref$1.node = node;
		return node;
	}
	exports.createNode = createNode$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Collection.js": ((exports) => {
	var createNode$3 = require_createNode();
	var identity$25 = require_identity();
	var Node = require_Node();
	function collectionFromPath(schema$6, path$2, value) {
		let v$2 = value;
		for (let i$1 = path$2.length - 1; i$1 >= 0; --i$1) {
			const k$2 = path$2[i$1];
			if (typeof k$2 === "number" && Number.isInteger(k$2) && k$2 >= 0) {
				const a = [];
				a[k$2] = v$2;
				v$2 = a;
			} else v$2 = new Map([[k$2, v$2]]);
		}
		return createNode$3.createNode(v$2, void 0, {
			aliasDuplicateObjects: false,
			keepUndefined: false,
			onAnchor: () => {
				throw new Error("This should not happen, please report a bug.");
			},
			schema: schema$6,
			sourceObjects: /* @__PURE__ */ new Map()
		});
	}
	const isEmptyPath = (path$2) => path$2 == null || typeof path$2 === "object" && !!path$2[Symbol.iterator]().next().done;
	var Collection$3 = class extends Node.NodeBase {
		constructor(type, schema$6) {
			super(type);
			Object.defineProperty(this, "schema", {
				value: schema$6,
				configurable: true,
				enumerable: false,
				writable: true
			});
		}
		/**
		* Create a copy of this collection.
		*
		* @param schema - If defined, overwrites the original's schema
		*/
		clone(schema$6) {
			const copy$1 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
			if (schema$6) copy$1.schema = schema$6;
			copy$1.items = copy$1.items.map((it) => identity$25.isNode(it) || identity$25.isPair(it) ? it.clone(schema$6) : it);
			if (this.range) copy$1.range = this.range.slice();
			return copy$1;
		}
		/**
		* Adds a value to the collection. For `!!map` and `!!omap` the value must
		* be a Pair instance or a `{ key, value }` object, which may not have a key
		* that already exists in the map.
		*/
		addIn(path$2, value) {
			if (isEmptyPath(path$2)) this.add(value);
			else {
				const [key, ...rest] = path$2;
				const node = this.get(key, true);
				if (identity$25.isCollection(node)) node.addIn(rest, value);
				else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
				else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
			}
		}
		/**
		* Removes a value from the collection.
		* @returns `true` if the item was found and removed.
		*/
		deleteIn(path$2) {
			const [key, ...rest] = path$2;
			if (rest.length === 0) return this.delete(key);
			const node = this.get(key, true);
			if (identity$25.isCollection(node)) return node.deleteIn(rest);
			else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
		}
		/**
		* Returns item at `key`, or `undefined` if not found. By default unwraps
		* scalar values from their surrounding node; to disable set `keepScalar` to
		* `true` (collections are always returned intact).
		*/
		getIn(path$2, keepScalar) {
			const [key, ...rest] = path$2;
			const node = this.get(key, true);
			if (rest.length === 0) return !keepScalar && identity$25.isScalar(node) ? node.value : node;
			else return identity$25.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
		}
		hasAllNullValues(allowScalar) {
			return this.items.every((node) => {
				if (!identity$25.isPair(node)) return false;
				const n$1 = node.value;
				return n$1 == null || allowScalar && identity$25.isScalar(n$1) && n$1.value == null && !n$1.commentBefore && !n$1.comment && !n$1.tag;
			});
		}
		/**
		* Checks if the collection includes a value with the key `key`.
		*/
		hasIn(path$2) {
			const [key, ...rest] = path$2;
			if (rest.length === 0) return this.has(key);
			const node = this.get(key, true);
			return identity$25.isCollection(node) ? node.hasIn(rest) : false;
		}
		/**
		* Sets a value in this collection. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*/
		setIn(path$2, value) {
			const [key, ...rest] = path$2;
			if (rest.length === 0) this.set(key, value);
			else {
				const node = this.get(key, true);
				if (identity$25.isCollection(node)) node.setIn(rest, value);
				else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
				else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
			}
		}
	};
	exports.Collection = Collection$3;
	exports.collectionFromPath = collectionFromPath;
	exports.isEmptyPath = isEmptyPath;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyComment.js": ((exports) => {
	/**
	* Stringifies a comment.
	*
	* Empty comment lines are left empty,
	* lines consisting of a single space are replaced by `#`,
	* and all other lines are prefixed with a `#`.
	*/
	const stringifyComment$4 = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
	function indentComment(comment$1, indent$2) {
		if (/^\n+$/.test(comment$1)) return comment$1.substring(1);
		return indent$2 ? comment$1.replace(/^(?! *$)/gm, indent$2) : comment$1;
	}
	const lineComment = (str, indent$2, comment$1) => str.endsWith("\n") ? indentComment(comment$1, indent$2) : comment$1.includes("\n") ? "\n" + indentComment(comment$1, indent$2) : (str.endsWith(" ") ? "" : " ") + comment$1;
	exports.indentComment = indentComment;
	exports.lineComment = lineComment;
	exports.stringifyComment = stringifyComment$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/foldFlowLines.js": ((exports) => {
	const FOLD_FLOW = "flow";
	const FOLD_BLOCK = "block";
	const FOLD_QUOTED = "quoted";
	/**
	* Tries to keep input at up to `lineWidth` characters, splitting only on spaces
	* not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
	* terminated with `\n` and started with `indent`.
	*/
	function foldFlowLines$1(text, indent$2, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
		if (!lineWidth || lineWidth < 0) return text;
		if (lineWidth < minContentWidth) minContentWidth = 0;
		const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent$2.length);
		if (text.length <= endStep) return text;
		const folds = [];
		const escapedFolds = {};
		let end = lineWidth - indent$2.length;
		if (typeof indentAtStart === "number") if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
		else end = lineWidth - indentAtStart;
		let split = void 0;
		let prev = void 0;
		let overflow = false;
		let i$1 = -1;
		let escStart = -1;
		let escEnd = -1;
		if (mode === FOLD_BLOCK) {
			i$1 = consumeMoreIndentedLines(text, i$1, indent$2.length);
			if (i$1 !== -1) end = i$1 + endStep;
		}
		for (let ch; ch = text[i$1 += 1];) {
			if (mode === FOLD_QUOTED && ch === "\\") {
				escStart = i$1;
				switch (text[i$1 + 1]) {
					case "x":
						i$1 += 3;
						break;
					case "u":
						i$1 += 5;
						break;
					case "U":
						i$1 += 9;
						break;
					default: i$1 += 1;
				}
				escEnd = i$1;
			}
			if (ch === "\n") {
				if (mode === FOLD_BLOCK) i$1 = consumeMoreIndentedLines(text, i$1, indent$2.length);
				end = i$1 + indent$2.length + endStep;
				split = void 0;
			} else {
				if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
					const next = text[i$1 + 1];
					if (next && next !== " " && next !== "\n" && next !== "	") split = i$1;
				}
				if (i$1 >= end) if (split) {
					folds.push(split);
					end = split + endStep;
					split = void 0;
				} else if (mode === FOLD_QUOTED) {
					while (prev === " " || prev === "	") {
						prev = ch;
						ch = text[i$1 += 1];
						overflow = true;
					}
					const j$2 = i$1 > escEnd + 1 ? i$1 - 2 : escStart - 1;
					if (escapedFolds[j$2]) return text;
					folds.push(j$2);
					escapedFolds[j$2] = true;
					end = j$2 + endStep;
					split = void 0;
				} else overflow = true;
			}
			prev = ch;
		}
		if (overflow && onOverflow) onOverflow();
		if (folds.length === 0) return text;
		if (onFold) onFold();
		let res = text.slice(0, folds[0]);
		for (let i$2 = 0; i$2 < folds.length; ++i$2) {
			const fold = folds[i$2];
			const end$1 = folds[i$2 + 1] || text.length;
			if (fold === 0) res = `\n${indent$2}${text.slice(0, end$1)}`;
			else {
				if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
				res += `\n${indent$2}${text.slice(fold + 1, end$1)}`;
			}
		}
		return res;
	}
	/**
	* Presumes `i + 1` is at the start of a line
	* @returns index of last newline in more-indented block
	*/
	function consumeMoreIndentedLines(text, i$1, indent$2) {
		let end = i$1;
		let start = i$1 + 1;
		let ch = text[start];
		while (ch === " " || ch === "	") if (i$1 < start + indent$2) ch = text[++i$1];
		else {
			do
				ch = text[++i$1];
			while (ch && ch !== "\n");
			end = i$1;
			start = i$1 + 1;
			ch = text[start];
		}
		return end;
	}
	exports.FOLD_BLOCK = FOLD_BLOCK;
	exports.FOLD_FLOW = FOLD_FLOW;
	exports.FOLD_QUOTED = FOLD_QUOTED;
	exports.foldFlowLines = foldFlowLines$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyString.js": ((exports) => {
	var Scalar$17 = require_Scalar();
	var foldFlowLines = require_foldFlowLines();
	const getFoldOptions = (ctx, isBlock$1) => ({
		indentAtStart: isBlock$1 ? ctx.indent.length : ctx.indentAtStart,
		lineWidth: ctx.options.lineWidth,
		minContentWidth: ctx.options.minContentWidth
	});
	const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
	function lineLengthOverLimit(str, lineWidth, indentLength) {
		if (!lineWidth || lineWidth < 0) return false;
		const limit = lineWidth - indentLength;
		const strLen = str.length;
		if (strLen <= limit) return false;
		for (let i$1 = 0, start = 0; i$1 < strLen; ++i$1) if (str[i$1] === "\n") {
			if (i$1 - start > limit) return true;
			start = i$1 + 1;
			if (strLen - start <= limit) return false;
		}
		return true;
	}
	function doubleQuotedString(value, ctx) {
		const json = JSON.stringify(value);
		if (ctx.options.doubleQuotedAsJSON) return json;
		const { implicitKey } = ctx;
		const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
		const indent$2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
		let str = "";
		let start = 0;
		for (let i$1 = 0, ch = json[i$1]; ch; ch = json[++i$1]) {
			if (ch === " " && json[i$1 + 1] === "\\" && json[i$1 + 2] === "n") {
				str += json.slice(start, i$1) + "\\ ";
				i$1 += 1;
				start = i$1;
				ch = "\\";
			}
			if (ch === "\\") switch (json[i$1 + 1]) {
				case "u":
					{
						str += json.slice(start, i$1);
						const code = json.substr(i$1 + 2, 4);
						switch (code) {
							case "0000":
								str += "\\0";
								break;
							case "0007":
								str += "\\a";
								break;
							case "000b":
								str += "\\v";
								break;
							case "001b":
								str += "\\e";
								break;
							case "0085":
								str += "\\N";
								break;
							case "00a0":
								str += "\\_";
								break;
							case "2028":
								str += "\\L";
								break;
							case "2029":
								str += "\\P";
								break;
							default: if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
							else str += json.substr(i$1, 6);
						}
						i$1 += 5;
						start = i$1 + 1;
					}
					break;
				case "n":
					if (implicitKey || json[i$1 + 2] === "\"" || json.length < minMultiLineLength) i$1 += 1;
					else {
						str += json.slice(start, i$1) + "\n\n";
						while (json[i$1 + 2] === "\\" && json[i$1 + 3] === "n" && json[i$1 + 4] !== "\"") {
							str += "\n";
							i$1 += 2;
						}
						str += indent$2;
						if (json[i$1 + 2] === " ") str += "\\";
						i$1 += 1;
						start = i$1 + 1;
					}
					break;
				default: i$1 += 1;
			}
		}
		str = start ? str + json.slice(start) : json;
		return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent$2, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
	}
	function singleQuotedString(value, ctx) {
		if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
		const indent$2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
		const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent$2}`) + "'";
		return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent$2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
	}
	function quotedString(value, ctx) {
		const { singleQuote } = ctx.options;
		let qs;
		if (singleQuote === false) qs = doubleQuotedString;
		else {
			const hasDouble = value.includes("\"");
			const hasSingle = value.includes("'");
			if (hasDouble && !hasSingle) qs = singleQuotedString;
			else if (hasSingle && !hasDouble) qs = doubleQuotedString;
			else qs = singleQuote ? singleQuotedString : doubleQuotedString;
		}
		return qs(value, ctx);
	}
	let blockEndNewlines;
	try {
		blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
	} catch {
		blockEndNewlines = /\n+(?!\n|$)/g;
	}
	function blockString({ comment: comment$1, type, value }, ctx, onComment, onChompKeep) {
		const { blockQuote, commentString, lineWidth } = ctx.options;
		if (!blockQuote || /\n[\t ]+$/.test(value)) return quotedString(value, ctx);
		const indent$2 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
		const literal$1 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar$17.Scalar.BLOCK_FOLDED ? false : type === Scalar$17.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent$2.length);
		if (!value) return literal$1 ? "|\n" : ">\n";
		let chomp;
		let endStart;
		for (endStart = value.length; endStart > 0; --endStart) {
			const ch = value[endStart - 1];
			if (ch !== "\n" && ch !== "	" && ch !== " ") break;
		}
		let end = value.substring(endStart);
		const endNlPos = end.indexOf("\n");
		if (endNlPos === -1) chomp = "-";
		else if (value === end || endNlPos !== end.length - 1) {
			chomp = "+";
			if (onChompKeep) onChompKeep();
		} else chomp = "";
		if (end) {
			value = value.slice(0, -end.length);
			if (end[end.length - 1] === "\n") end = end.slice(0, -1);
			end = end.replace(blockEndNewlines, `$&${indent$2}`);
		}
		let startWithSpace = false;
		let startEnd;
		let startNlPos = -1;
		for (startEnd = 0; startEnd < value.length; ++startEnd) {
			const ch = value[startEnd];
			if (ch === " ") startWithSpace = true;
			else if (ch === "\n") startNlPos = startEnd;
			else break;
		}
		let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
		if (start) {
			value = value.substring(start.length);
			start = start.replace(/\n+/g, `$&${indent$2}`);
		}
		let header = (startWithSpace ? indent$2 ? "2" : "1" : "") + chomp;
		if (comment$1) {
			header += " " + commentString(comment$1.replace(/ ?[\r\n]+/g, " "));
			if (onComment) onComment();
		}
		if (!literal$1) {
			const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent$2}`);
			let literalFallback = false;
			const foldOptions = getFoldOptions(ctx, true);
			if (blockQuote !== "folded" && type !== Scalar$17.Scalar.BLOCK_FOLDED) foldOptions.onOverflow = () => {
				literalFallback = true;
			};
			const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent$2, foldFlowLines.FOLD_BLOCK, foldOptions);
			if (!literalFallback) return `>${header}\n${indent$2}${body}`;
		}
		value = value.replace(/\n+/g, `$&${indent$2}`);
		return `|${header}\n${indent$2}${start}${value}${end}`;
	}
	function plainString(item, ctx, onComment, onChompKeep) {
		const { type, value } = item;
		const { actualString, implicitKey, indent: indent$2, indentStep, inFlow } = ctx;
		if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return quotedString(value, ctx);
		if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
		if (!implicitKey && !inFlow && type !== Scalar$17.Scalar.PLAIN && value.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
		if (containsDocumentMarker(value)) {
			if (indent$2 === "") {
				ctx.forceBlockIndent = true;
				return blockString(item, ctx, onComment, onChompKeep);
			} else if (implicitKey && indent$2 === indentStep) return quotedString(value, ctx);
		}
		const str = value.replace(/\n+/g, `$&\n${indent$2}`);
		if (actualString) {
			const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
			const { compat, tags: tags$1 } = ctx.doc.schema;
			if (tags$1.some(test) || compat?.some(test)) return quotedString(value, ctx);
		}
		return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent$2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
	}
	function stringifyString$4(item, ctx, onComment, onChompKeep) {
		const { implicitKey, inFlow } = ctx;
		const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
		let { type } = item;
		if (type !== Scalar$17.Scalar.QUOTE_DOUBLE) {
			if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar$17.Scalar.QUOTE_DOUBLE;
		}
		const _stringify = (_type) => {
			switch (_type) {
				case Scalar$17.Scalar.BLOCK_FOLDED:
				case Scalar$17.Scalar.BLOCK_LITERAL: return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
				case Scalar$17.Scalar.QUOTE_DOUBLE: return doubleQuotedString(ss.value, ctx);
				case Scalar$17.Scalar.QUOTE_SINGLE: return singleQuotedString(ss.value, ctx);
				case Scalar$17.Scalar.PLAIN: return plainString(ss, ctx, onComment, onChompKeep);
				default: return null;
			}
		};
		let res = _stringify(type);
		if (res === null) {
			const { defaultKeyType, defaultStringType } = ctx.options;
			const t = implicitKey && defaultKeyType || defaultStringType;
			res = _stringify(t);
			if (res === null) throw new Error(`Unsupported default string type ${t}`);
		}
		return res;
	}
	exports.stringifyString = stringifyString$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringify.js
var require_stringify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringify.js": ((exports) => {
	var anchors$1 = require_anchors();
	var identity$24 = require_identity();
	var stringifyComment$3 = require_stringifyComment();
	var stringifyString$3 = require_stringifyString();
	function createStringifyContext(doc, options) {
		const opt = Object.assign({
			blockQuote: true,
			commentString: stringifyComment$3.stringifyComment,
			defaultKeyType: null,
			defaultStringType: "PLAIN",
			directives: null,
			doubleQuotedAsJSON: false,
			doubleQuotedMinMultiLineLength: 40,
			falseStr: "false",
			flowCollectionPadding: true,
			indentSeq: true,
			lineWidth: 80,
			minContentWidth: 20,
			nullStr: "null",
			simpleKeys: false,
			singleQuote: null,
			trueStr: "true",
			verifyAliasOrder: true
		}, doc.schema.toStringOptions, options);
		let inFlow;
		switch (opt.collectionStyle) {
			case "block":
				inFlow = false;
				break;
			case "flow":
				inFlow = true;
				break;
			default: inFlow = null;
		}
		return {
			anchors: /* @__PURE__ */ new Set(),
			doc,
			flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
			indent: "",
			indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
			inFlow,
			options: opt
		};
	}
	function getTagObject(tags$1, item) {
		if (item.tag) {
			const match = tags$1.filter((t) => t.tag === item.tag);
			if (match.length > 0) return match.find((t) => t.format === item.format) ?? match[0];
		}
		let tagObj = void 0;
		let obj;
		if (identity$24.isScalar(item)) {
			obj = item.value;
			let match = tags$1.filter((t) => t.identify?.(obj));
			if (match.length > 1) {
				const testMatch = match.filter((t) => t.test);
				if (testMatch.length > 0) match = testMatch;
			}
			tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
		} else {
			obj = item;
			tagObj = tags$1.find((t) => t.nodeClass && obj instanceof t.nodeClass);
		}
		if (!tagObj) {
			const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
			throw new Error(`Tag not resolved for ${name} value`);
		}
		return tagObj;
	}
	function stringifyProps(node, tagObj, { anchors: anchors$1$1, doc }) {
		if (!doc.directives) return "";
		const props = [];
		const anchor = (identity$24.isScalar(node) || identity$24.isCollection(node)) && node.anchor;
		if (anchor && anchors$1.anchorIsValid(anchor)) {
			anchors$1$1.add(anchor);
			props.push(`&${anchor}`);
		}
		const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
		if (tag) props.push(doc.directives.tagString(tag));
		return props.join(" ");
	}
	function stringify$6(item, ctx, onComment, onChompKeep) {
		if (identity$24.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
		if (identity$24.isAlias(item)) {
			if (ctx.doc.directives) return item.toString(ctx);
			if (ctx.resolvedAliases?.has(item)) throw new TypeError(`Cannot stringify circular structure without alias nodes`);
			else {
				if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
				else ctx.resolvedAliases = new Set([item]);
				item = item.resolve(ctx.doc);
			}
		}
		let tagObj = void 0;
		const node = identity$24.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o$1) => tagObj = o$1 });
		tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
		const props = stringifyProps(node, tagObj, ctx);
		if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
		const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity$24.isScalar(node) ? stringifyString$3.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
		if (!props) return str;
		return identity$24.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
	}
	exports.createStringifyContext = createStringifyContext;
	exports.stringify = stringify$6;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyPair.js": ((exports) => {
	var identity$23 = require_identity();
	var Scalar$16 = require_Scalar();
	var stringify$5 = require_stringify();
	var stringifyComment$2 = require_stringifyComment();
	function stringifyPair$1({ key, value }, ctx, onComment, onChompKeep) {
		const { allNullValues, doc, indent: indent$2, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
		let keyComment = identity$23.isNode(key) && key.comment || null;
		if (simpleKeys) {
			if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
			if (identity$23.isCollection(key) || !identity$23.isNode(key) && typeof key === "object") throw new Error("With simple keys, collection cannot be used as a key value");
		}
		let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity$23.isCollection(key) || (identity$23.isScalar(key) ? key.type === Scalar$16.Scalar.BLOCK_FOLDED || key.type === Scalar$16.Scalar.BLOCK_LITERAL : typeof key === "object"));
		ctx = Object.assign({}, ctx, {
			allNullValues: false,
			implicitKey: !explicitKey && (simpleKeys || !allNullValues),
			indent: indent$2 + indentStep
		});
		let keyCommentDone = false;
		let chompKeep = false;
		let str = stringify$5.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
		if (!explicitKey && !ctx.inFlow && str.length > 1024) {
			if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
			explicitKey = true;
		}
		if (ctx.inFlow) {
			if (allNullValues || value == null) {
				if (keyCommentDone && onComment) onComment();
				return str === "" ? "?" : explicitKey ? `? ${str}` : str;
			}
		} else if (allNullValues && !simpleKeys || value == null && explicitKey) {
			str = `? ${str}`;
			if (keyComment && !keyCommentDone) str += stringifyComment$2.lineComment(str, ctx.indent, commentString(keyComment));
			else if (chompKeep && onChompKeep) onChompKeep();
			return str;
		}
		if (keyCommentDone) keyComment = null;
		if (explicitKey) {
			if (keyComment) str += stringifyComment$2.lineComment(str, ctx.indent, commentString(keyComment));
			str = `? ${str}\n${indent$2}:`;
		} else {
			str = `${str}:`;
			if (keyComment) str += stringifyComment$2.lineComment(str, ctx.indent, commentString(keyComment));
		}
		let vsb, vcb, valueComment;
		if (identity$23.isNode(value)) {
			vsb = !!value.spaceBefore;
			vcb = value.commentBefore;
			valueComment = value.comment;
		} else {
			vsb = false;
			vcb = null;
			valueComment = null;
			if (value && typeof value === "object") value = doc.createNode(value);
		}
		ctx.implicitKey = false;
		if (!explicitKey && !keyComment && identity$23.isScalar(value)) ctx.indentAtStart = str.length + 1;
		chompKeep = false;
		if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity$23.isSeq(value) && !value.flow && !value.tag && !value.anchor) ctx.indent = ctx.indent.substring(2);
		let valueCommentDone = false;
		const valueStr = stringify$5.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
		let ws = " ";
		if (keyComment || vsb || vcb) {
			ws = vsb ? "\n" : "";
			if (vcb) {
				const cs = commentString(vcb);
				ws += `\n${stringifyComment$2.indentComment(cs, ctx.indent)}`;
			}
			if (valueStr === "" && !ctx.inFlow) {
				if (ws === "\n") ws = "\n\n";
			} else ws += `\n${ctx.indent}`;
		} else if (!explicitKey && identity$23.isCollection(value)) {
			const vs0 = valueStr[0];
			const nl0 = valueStr.indexOf("\n");
			const hasNewline = nl0 !== -1;
			const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
			if (hasNewline || !flow) {
				let hasPropsLine = false;
				if (hasNewline && (vs0 === "&" || vs0 === "!")) {
					let sp0 = valueStr.indexOf(" ");
					if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") sp0 = valueStr.indexOf(" ", sp0 + 1);
					if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
				}
				if (!hasPropsLine) ws = `\n${ctx.indent}`;
			}
		} else if (valueStr === "" || valueStr[0] === "\n") ws = "";
		str += ws + valueStr;
		if (ctx.inFlow) {
			if (valueCommentDone && onComment) onComment();
		} else if (valueComment && !valueCommentDone) str += stringifyComment$2.lineComment(str, ctx.indent, commentString(valueComment));
		else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	exports.stringifyPair = stringifyPair$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/log.js
var require_log = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/log.js": ((exports) => {
	var node_process$2 = __require("process");
	function debug(logLevel, ...messages) {
		if (logLevel === "debug") console.log(...messages);
	}
	function warn(logLevel, warning) {
		if (logLevel === "debug" || logLevel === "warn") if (typeof node_process$2.emitWarning === "function") node_process$2.emitWarning(warning);
		else console.warn(warning);
	}
	exports.debug = debug;
	exports.warn = warn;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js": ((exports) => {
	var identity$22 = require_identity();
	var Scalar$15 = require_Scalar();
	const MERGE_KEY = "<<";
	const merge$4 = {
		identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
		default: "key",
		tag: "tag:yaml.org,2002:merge",
		test: /^<<$/,
		resolve: () => Object.assign(new Scalar$15.Scalar(Symbol(MERGE_KEY)), { addToJSMap: addMergeToJSMap }),
		stringify: () => MERGE_KEY
	};
	const isMergeKey = (ctx, key) => (merge$4.identify(key) || identity$22.isScalar(key) && (!key.type || key.type === Scalar$15.Scalar.PLAIN) && merge$4.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge$4.tag && tag.default);
	function addMergeToJSMap(ctx, map$6, value) {
		value = ctx && identity$22.isAlias(value) ? value.resolve(ctx.doc) : value;
		if (identity$22.isSeq(value)) for (const it of value.items) mergeValue(ctx, map$6, it);
		else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map$6, it);
		else mergeValue(ctx, map$6, value);
	}
	function mergeValue(ctx, map$6, value) {
		const source = ctx && identity$22.isAlias(value) ? value.resolve(ctx.doc) : value;
		if (!identity$22.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
		const srcMap = source.toJSON(null, ctx, Map);
		for (const [key, value$1] of srcMap) if (map$6 instanceof Map) {
			if (!map$6.has(key)) map$6.set(key, value$1);
		} else if (map$6 instanceof Set) map$6.add(key);
		else if (!Object.prototype.hasOwnProperty.call(map$6, key)) Object.defineProperty(map$6, key, {
			value: value$1,
			writable: true,
			enumerable: true,
			configurable: true
		});
		return map$6;
	}
	exports.addMergeToJSMap = addMergeToJSMap;
	exports.isMergeKey = isMergeKey;
	exports.merge = merge$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/addPairToJSMap.js": ((exports) => {
	var log$1 = require_log();
	var merge$3 = require_merge();
	var stringify$4 = require_stringify();
	var identity$21 = require_identity();
	var toJS$3 = require_toJS();
	function addPairToJSMap$2(ctx, map$6, { key, value }) {
		if (identity$21.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map$6, value);
		else if (merge$3.isMergeKey(ctx, key)) merge$3.addMergeToJSMap(ctx, map$6, value);
		else {
			const jsKey = toJS$3.toJS(key, "", ctx);
			if (map$6 instanceof Map) map$6.set(jsKey, toJS$3.toJS(value, jsKey, ctx));
			else if (map$6 instanceof Set) map$6.add(jsKey);
			else {
				const stringKey = stringifyKey(key, jsKey, ctx);
				const jsValue = toJS$3.toJS(value, stringKey, ctx);
				if (stringKey in map$6) Object.defineProperty(map$6, stringKey, {
					value: jsValue,
					writable: true,
					enumerable: true,
					configurable: true
				});
				else map$6[stringKey] = jsValue;
			}
		}
		return map$6;
	}
	function stringifyKey(key, jsKey, ctx) {
		if (jsKey === null) return "";
		if (typeof jsKey !== "object") return String(jsKey);
		if (identity$21.isNode(key) && ctx?.doc) {
			const strCtx = stringify$4.createStringifyContext(ctx.doc, {});
			strCtx.anchors = /* @__PURE__ */ new Set();
			for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
			strCtx.inFlow = true;
			strCtx.inStringifyKey = true;
			const strKey = key.toString(strCtx);
			if (!ctx.mapKeyWarned) {
				let jsonStr = JSON.stringify(strKey);
				if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + "...\"";
				log$1.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
				ctx.mapKeyWarned = true;
			}
			return strKey;
		}
		return JSON.stringify(jsKey);
	}
	exports.addPairToJSMap = addPairToJSMap$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Pair.js": ((exports) => {
	var createNode$2 = require_createNode();
	var stringifyPair = require_stringifyPair();
	var addPairToJSMap$1 = require_addPairToJSMap();
	var identity$20 = require_identity();
	function createPair(key, value, ctx) {
		const k$2 = createNode$2.createNode(key, void 0, ctx);
		const v$2 = createNode$2.createNode(value, void 0, ctx);
		return new Pair$7(k$2, v$2);
	}
	var Pair$7 = class Pair$7 {
		constructor(key, value = null) {
			Object.defineProperty(this, identity$20.NODE_TYPE, { value: identity$20.PAIR });
			this.key = key;
			this.value = value;
		}
		clone(schema$6) {
			let { key, value } = this;
			if (identity$20.isNode(key)) key = key.clone(schema$6);
			if (identity$20.isNode(value)) value = value.clone(schema$6);
			return new Pair$7(key, value);
		}
		toJSON(_$1, ctx) {
			const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
			return addPairToJSMap$1.addPairToJSMap(ctx, pair, this);
		}
		toString(ctx, onComment, onChompKeep) {
			return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
		}
	};
	exports.Pair = Pair$7;
	exports.createPair = createPair;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyCollection.js": ((exports) => {
	var identity$19 = require_identity();
	var stringify$3 = require_stringify();
	var stringifyComment$1 = require_stringifyComment();
	function stringifyCollection$2(collection, ctx, options) {
		return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
	}
	function stringifyBlockCollection({ comment: comment$1, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
		const { indent: indent$2, options: { commentString } } = ctx;
		const itemCtx = Object.assign({}, ctx, {
			indent: itemIndent,
			type: null
		});
		let chompKeep = false;
		const lines = [];
		for (let i$1 = 0; i$1 < items.length; ++i$1) {
			const item = items[i$1];
			let comment$2 = null;
			if (identity$19.isNode(item)) {
				if (!chompKeep && item.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
				if (item.comment) comment$2 = item.comment;
			} else if (identity$19.isPair(item)) {
				const ik = identity$19.isNode(item.key) ? item.key : null;
				if (ik) {
					if (!chompKeep && ik.spaceBefore) lines.push("");
					addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
				}
			}
			chompKeep = false;
			let str$1 = stringify$3.stringify(item, itemCtx, () => comment$2 = null, () => chompKeep = true);
			if (comment$2) str$1 += stringifyComment$1.lineComment(str$1, itemIndent, commentString(comment$2));
			if (chompKeep && comment$2) chompKeep = false;
			lines.push(blockItemPrefix + str$1);
		}
		let str;
		if (lines.length === 0) str = flowChars.start + flowChars.end;
		else {
			str = lines[0];
			for (let i$1 = 1; i$1 < lines.length; ++i$1) {
				const line = lines[i$1];
				str += line ? `\n${indent$2}${line}` : "\n";
			}
		}
		if (comment$1) {
			str += "\n" + stringifyComment$1.indentComment(commentString(comment$1), indent$2);
			if (onComment) onComment();
		} else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
		const { indent: indent$2, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
		itemIndent += indentStep;
		const itemCtx = Object.assign({}, ctx, {
			indent: itemIndent,
			inFlow: true,
			type: null
		});
		let reqNewline = false;
		let linesAtValue = 0;
		const lines = [];
		for (let i$1 = 0; i$1 < items.length; ++i$1) {
			const item = items[i$1];
			let comment$1 = null;
			if (identity$19.isNode(item)) {
				if (item.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, item.commentBefore, false);
				if (item.comment) comment$1 = item.comment;
			} else if (identity$19.isPair(item)) {
				const ik = identity$19.isNode(item.key) ? item.key : null;
				if (ik) {
					if (ik.spaceBefore) lines.push("");
					addCommentBefore(ctx, lines, ik.commentBefore, false);
					if (ik.comment) reqNewline = true;
				}
				const iv = identity$19.isNode(item.value) ? item.value : null;
				if (iv) {
					if (iv.comment) comment$1 = iv.comment;
					if (iv.commentBefore) reqNewline = true;
				} else if (item.value == null && ik?.comment) comment$1 = ik.comment;
			}
			if (comment$1) reqNewline = true;
			let str = stringify$3.stringify(item, itemCtx, () => comment$1 = null);
			if (i$1 < items.length - 1) str += ",";
			if (comment$1) str += stringifyComment$1.lineComment(str, itemIndent, commentString(comment$1));
			if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
			lines.push(str);
			linesAtValue = lines.length;
		}
		const { start, end } = flowChars;
		if (lines.length === 0) return start + end;
		else {
			if (!reqNewline) {
				const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
				reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
			}
			if (reqNewline) {
				let str = start;
				for (const line of lines) str += line ? `\n${indentStep}${indent$2}${line}` : "\n";
				return `${str}\n${indent$2}${end}`;
			} else return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
		}
	}
	function addCommentBefore({ indent: indent$2, options: { commentString } }, lines, comment$1, chompKeep) {
		if (comment$1 && chompKeep) comment$1 = comment$1.replace(/^\n+/, "");
		if (comment$1) {
			const ic = stringifyComment$1.indentComment(commentString(comment$1), indent$2);
			lines.push(ic.trimStart());
		}
	}
	exports.stringifyCollection = stringifyCollection$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLMap.js": ((exports) => {
	var stringifyCollection$1 = require_stringifyCollection();
	var addPairToJSMap = require_addPairToJSMap();
	var Collection$2 = require_Collection();
	var identity$18 = require_identity();
	var Pair$6 = require_Pair();
	var Scalar$14 = require_Scalar();
	function findPair(items, key) {
		const k$2 = identity$18.isScalar(key) ? key.value : key;
		for (const it of items) if (identity$18.isPair(it)) {
			if (it.key === key || it.key === k$2) return it;
			if (identity$18.isScalar(it.key) && it.key.value === k$2) return it;
		}
	}
	var YAMLMap$7 = class extends Collection$2.Collection {
		static get tagName() {
			return "tag:yaml.org,2002:map";
		}
		constructor(schema$6) {
			super(identity$18.MAP, schema$6);
			this.items = [];
		}
		/**
		* A generic collection parsing method that can be extended
		* to other node classes that inherit from YAMLMap
		*/
		static from(schema$6, obj, ctx) {
			const { keepUndefined, replacer } = ctx;
			const map$6 = new this(schema$6);
			const add = (key, value) => {
				if (typeof replacer === "function") value = replacer.call(obj, key, value);
				else if (Array.isArray(replacer) && !replacer.includes(key)) return;
				if (value !== void 0 || keepUndefined) map$6.items.push(Pair$6.createPair(key, value, ctx));
			};
			if (obj instanceof Map) for (const [key, value] of obj) add(key, value);
			else if (obj && typeof obj === "object") for (const key of Object.keys(obj)) add(key, obj[key]);
			if (typeof schema$6.sortMapEntries === "function") map$6.items.sort(schema$6.sortMapEntries);
			return map$6;
		}
		/**
		* Adds a value to the collection.
		*
		* @param overwrite - If not set `true`, using a key that is already in the
		*   collection will throw. Otherwise, overwrites the previous value.
		*/
		add(pair, overwrite) {
			let _pair;
			if (identity$18.isPair(pair)) _pair = pair;
			else if (!pair || typeof pair !== "object" || !("key" in pair)) _pair = new Pair$6.Pair(pair, pair?.value);
			else _pair = new Pair$6.Pair(pair.key, pair.value);
			const prev = findPair(this.items, _pair.key);
			const sortEntries = this.schema?.sortMapEntries;
			if (prev) {
				if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
				if (identity$18.isScalar(prev.value) && Scalar$14.isScalarValue(_pair.value)) prev.value.value = _pair.value;
				else prev.value = _pair.value;
			} else if (sortEntries) {
				const i$1 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
				if (i$1 === -1) this.items.push(_pair);
				else this.items.splice(i$1, 0, _pair);
			} else this.items.push(_pair);
		}
		delete(key) {
			const it = findPair(this.items, key);
			if (!it) return false;
			return this.items.splice(this.items.indexOf(it), 1).length > 0;
		}
		get(key, keepScalar) {
			const node = findPair(this.items, key)?.value;
			return (!keepScalar && identity$18.isScalar(node) ? node.value : node) ?? void 0;
		}
		has(key) {
			return !!findPair(this.items, key);
		}
		set(key, value) {
			this.add(new Pair$6.Pair(key, value), true);
		}
		/**
		* @param ctx - Conversion context, originally set in Document#toJS()
		* @param {Class} Type - If set, forces the returned collection type
		* @returns Instance of Type, Map, or Object
		*/
		toJSON(_$1, ctx, Type) {
			const map$6 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
			if (ctx?.onCreate) ctx.onCreate(map$6);
			for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map$6, item);
			return map$6;
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			for (const item of this.items) if (!identity$18.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
			if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, { allNullValues: true });
			return stringifyCollection$1.stringifyCollection(this, ctx, {
				blockItemPrefix: "",
				flowChars: {
					start: "{",
					end: "}"
				},
				itemIndent: ctx.indent || "",
				onChompKeep,
				onComment
			});
		}
	};
	exports.YAMLMap = YAMLMap$7;
	exports.findPair = findPair;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/map.js
var require_map = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/map.js": ((exports) => {
	var identity$17 = require_identity();
	var YAMLMap$6 = require_YAMLMap();
	const map$5 = {
		collection: "map",
		default: true,
		nodeClass: YAMLMap$6.YAMLMap,
		tag: "tag:yaml.org,2002:map",
		resolve(map$6, onError) {
			if (!identity$17.isMap(map$6)) onError("Expected a mapping for this tag");
			return map$6;
		},
		createNode: (schema$6, obj, ctx) => YAMLMap$6.YAMLMap.from(schema$6, obj, ctx)
	};
	exports.map = map$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLSeq.js": ((exports) => {
	var createNode$1 = require_createNode();
	var stringifyCollection = require_stringifyCollection();
	var Collection$1 = require_Collection();
	var identity$16 = require_identity();
	var Scalar$13 = require_Scalar();
	var toJS$2 = require_toJS();
	var YAMLSeq$7 = class extends Collection$1.Collection {
		static get tagName() {
			return "tag:yaml.org,2002:seq";
		}
		constructor(schema$6) {
			super(identity$16.SEQ, schema$6);
			this.items = [];
		}
		add(value) {
			this.items.push(value);
		}
		/**
		* Removes a value from the collection.
		*
		* `key` must contain a representation of an integer for this to succeed.
		* It may be wrapped in a `Scalar`.
		*
		* @returns `true` if the item was found and removed.
		*/
		delete(key) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") return false;
			return this.items.splice(idx, 1).length > 0;
		}
		get(key, keepScalar) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") return void 0;
			const it = this.items[idx];
			return !keepScalar && identity$16.isScalar(it) ? it.value : it;
		}
		/**
		* Checks if the collection includes a value with the key `key`.
		*
		* `key` must contain a representation of an integer for this to succeed.
		* It may be wrapped in a `Scalar`.
		*/
		has(key) {
			const idx = asItemIndex(key);
			return typeof idx === "number" && idx < this.items.length;
		}
		/**
		* Sets a value in this collection. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*
		* If `key` does not contain a representation of an integer, this will throw.
		* It may be wrapped in a `Scalar`.
		*/
		set(key, value) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
			const prev = this.items[idx];
			if (identity$16.isScalar(prev) && Scalar$13.isScalarValue(value)) prev.value = value;
			else this.items[idx] = value;
		}
		toJSON(_$1, ctx) {
			const seq$6 = [];
			if (ctx?.onCreate) ctx.onCreate(seq$6);
			let i$1 = 0;
			for (const item of this.items) seq$6.push(toJS$2.toJS(item, String(i$1++), ctx));
			return seq$6;
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			return stringifyCollection.stringifyCollection(this, ctx, {
				blockItemPrefix: "- ",
				flowChars: {
					start: "[",
					end: "]"
				},
				itemIndent: (ctx.indent || "") + "  ",
				onChompKeep,
				onComment
			});
		}
		static from(schema$6, obj, ctx) {
			const { replacer } = ctx;
			const seq$6 = new this(schema$6);
			if (obj && Symbol.iterator in Object(obj)) {
				let i$1 = 0;
				for (let it of obj) {
					if (typeof replacer === "function") {
						const key = obj instanceof Set ? it : String(i$1++);
						it = replacer.call(obj, key, it);
					}
					seq$6.items.push(createNode$1.createNode(it, void 0, ctx));
				}
			}
			return seq$6;
		}
	};
	function asItemIndex(key) {
		let idx = identity$16.isScalar(key) ? key.value : key;
		if (idx && typeof idx === "string") idx = Number(idx);
		return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
	}
	exports.YAMLSeq = YAMLSeq$7;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/seq.js
var require_seq = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/seq.js": ((exports) => {
	var identity$15 = require_identity();
	var YAMLSeq$6 = require_YAMLSeq();
	const seq$5 = {
		collection: "seq",
		default: true,
		nodeClass: YAMLSeq$6.YAMLSeq,
		tag: "tag:yaml.org,2002:seq",
		resolve(seq$6, onError) {
			if (!identity$15.isSeq(seq$6)) onError("Expected a sequence for this tag");
			return seq$6;
		},
		createNode: (schema$6, obj, ctx) => YAMLSeq$6.YAMLSeq.from(schema$6, obj, ctx)
	};
	exports.seq = seq$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/string.js
var require_string = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/string.js": ((exports) => {
	var stringifyString$2 = require_stringifyString();
	const string$4 = {
		identify: (value) => typeof value === "string",
		default: true,
		tag: "tag:yaml.org,2002:str",
		resolve: (str) => str,
		stringify(item, ctx, onComment, onChompKeep) {
			ctx = Object.assign({ actualString: true }, ctx);
			return stringifyString$2.stringifyString(item, ctx, onComment, onChompKeep);
		}
	};
	exports.string = string$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/null.js
var require_null = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/null.js": ((exports) => {
	var Scalar$12 = require_Scalar();
	const nullTag = {
		identify: (value) => value == null,
		createNode: () => new Scalar$12.Scalar(null),
		default: true,
		tag: "tag:yaml.org,2002:null",
		test: /^(?:~|[Nn]ull|NULL)?$/,
		resolve: () => new Scalar$12.Scalar(null),
		stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
	};
	exports.nullTag = nullTag;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/bool.js
var require_bool$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/bool.js": ((exports) => {
	var Scalar$11 = require_Scalar();
	const boolTag = {
		identify: (value) => typeof value === "boolean",
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
		resolve: (str) => new Scalar$11.Scalar(str[0] === "t" || str[0] === "T"),
		stringify({ source, value }, ctx) {
			if (source && boolTag.test.test(source)) {
				const sv = source[0] === "t" || source[0] === "T";
				if (value === sv) return source;
			}
			return value ? ctx.options.trueStr : ctx.options.falseStr;
		}
	};
	exports.boolTag = boolTag;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyNumber.js": ((exports) => {
	function stringifyNumber$5({ format, minFractionDigits, tag, value }) {
		if (typeof value === "bigint") return String(value);
		const num = typeof value === "number" ? value : Number(value);
		if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
		let n$1 = JSON.stringify(value);
		if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n$1)) {
			let i$1 = n$1.indexOf(".");
			if (i$1 < 0) {
				i$1 = n$1.length;
				n$1 += ".";
			}
			let d$1 = minFractionDigits - (n$1.length - i$1 - 1);
			while (d$1-- > 0) n$1 += "0";
		}
		return n$1;
	}
	exports.stringifyNumber = stringifyNumber$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/float.js
var require_float$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/float.js": ((exports) => {
	var Scalar$10 = require_Scalar();
	var stringifyNumber$4 = require_stringifyNumber();
	const floatNaN$1 = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
		resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
		stringify: stringifyNumber$4.stringifyNumber
	};
	const floatExp$1 = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "EXP",
		test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
		resolve: (str) => parseFloat(str),
		stringify(node) {
			const num = Number(node.value);
			return isFinite(num) ? num.toExponential() : stringifyNumber$4.stringifyNumber(node);
		}
	};
	const float$4 = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
		resolve(str) {
			const node = new Scalar$10.Scalar(parseFloat(str));
			const dot = str.indexOf(".");
			if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
			return node;
		},
		stringify: stringifyNumber$4.stringifyNumber
	};
	exports.float = float$4;
	exports.floatExp = floatExp$1;
	exports.floatNaN = floatNaN$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/int.js
var require_int$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/int.js": ((exports) => {
	var stringifyNumber$3 = require_stringifyNumber();
	const intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
	const intResolve$1 = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
	function intStringify$1(node, radix, prefix) {
		const { value } = node;
		if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
		return stringifyNumber$3.stringifyNumber(node);
	}
	const intOct$1 = {
		identify: (value) => intIdentify$2(value) && value >= 0,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "OCT",
		test: /^0o[0-7]+$/,
		resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
		stringify: (node) => intStringify$1(node, 8, "0o")
	};
	const int$4 = {
		identify: intIdentify$2,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^[-+]?[0-9]+$/,
		resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
		stringify: stringifyNumber$3.stringifyNumber
	};
	const intHex$1 = {
		identify: (value) => intIdentify$2(value) && value >= 0,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "HEX",
		test: /^0x[0-9a-fA-F]+$/,
		resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
		stringify: (node) => intStringify$1(node, 16, "0x")
	};
	exports.int = int$4;
	exports.intHex = intHex$1;
	exports.intOct = intOct$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/schema.js
var require_schema$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/schema.js": ((exports) => {
	var map$4 = require_map();
	var _null$2 = require_null();
	var seq$4 = require_seq();
	var string$3 = require_string();
	var bool$2 = require_bool$1();
	var float$3 = require_float$1();
	var int$3 = require_int$1();
	const schema$5 = [
		map$4.map,
		seq$4.seq,
		string$3.string,
		_null$2.nullTag,
		bool$2.boolTag,
		int$3.intOct,
		int$3.int,
		int$3.intHex,
		float$3.floatNaN,
		float$3.floatExp,
		float$3.float
	];
	exports.schema = schema$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/json/schema.js
var require_schema$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/json/schema.js": ((exports) => {
	var Scalar$9 = require_Scalar();
	var map$3 = require_map();
	var seq$3 = require_seq();
	function intIdentify$1(value) {
		return typeof value === "bigint" || Number.isInteger(value);
	}
	const stringifyJSON = ({ value }) => JSON.stringify(value);
	const jsonScalars = [
		{
			identify: (value) => typeof value === "string",
			default: true,
			tag: "tag:yaml.org,2002:str",
			resolve: (str) => str,
			stringify: stringifyJSON
		},
		{
			identify: (value) => value == null,
			createNode: () => new Scalar$9.Scalar(null),
			default: true,
			tag: "tag:yaml.org,2002:null",
			test: /^null$/,
			resolve: () => null,
			stringify: stringifyJSON
		},
		{
			identify: (value) => typeof value === "boolean",
			default: true,
			tag: "tag:yaml.org,2002:bool",
			test: /^true$|^false$/,
			resolve: (str) => str === "true",
			stringify: stringifyJSON
		},
		{
			identify: intIdentify$1,
			default: true,
			tag: "tag:yaml.org,2002:int",
			test: /^-?(?:0|[1-9][0-9]*)$/,
			resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
			stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
		},
		{
			identify: (value) => typeof value === "number",
			default: true,
			tag: "tag:yaml.org,2002:float",
			test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
			resolve: (str) => parseFloat(str),
			stringify: stringifyJSON
		}
	];
	const schema$4 = [map$3.map, seq$3.seq].concat(jsonScalars, {
		default: true,
		tag: "",
		test: /^/,
		resolve(str, onError) {
			onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
			return str;
		}
	});
	exports.schema = schema$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js": ((exports) => {
	var node_buffer = __require("buffer");
	var Scalar$8 = require_Scalar();
	var stringifyString$1 = require_stringifyString();
	const binary$2 = {
		identify: (value) => value instanceof Uint8Array,
		default: false,
		tag: "tag:yaml.org,2002:binary",
		resolve(src, onError) {
			if (typeof node_buffer.Buffer === "function") return node_buffer.Buffer.from(src, "base64");
			else if (typeof atob === "function") {
				const str = atob(src.replace(/[\n\r]/g, ""));
				const buffer = new Uint8Array(str.length);
				for (let i$1 = 0; i$1 < str.length; ++i$1) buffer[i$1] = str.charCodeAt(i$1);
				return buffer;
			} else {
				onError("This environment does not support reading binary tags; either Buffer or atob is required");
				return src;
			}
		},
		stringify({ comment: comment$1, type, value }, ctx, onComment, onChompKeep) {
			if (!value) return "";
			const buf = value;
			let str;
			if (typeof node_buffer.Buffer === "function") str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
			else if (typeof btoa === "function") {
				let s = "";
				for (let i$1 = 0; i$1 < buf.length; ++i$1) s += String.fromCharCode(buf[i$1]);
				str = btoa(s);
			} else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
			type ?? (type = Scalar$8.Scalar.BLOCK_LITERAL);
			if (type !== Scalar$8.Scalar.QUOTE_DOUBLE) {
				const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
				const n$1 = Math.ceil(str.length / lineWidth);
				const lines = new Array(n$1);
				for (let i$1 = 0, o$1 = 0; i$1 < n$1; ++i$1, o$1 += lineWidth) lines[i$1] = str.substr(o$1, lineWidth);
				str = lines.join(type === Scalar$8.Scalar.BLOCK_LITERAL ? "\n" : " ");
			}
			return stringifyString$1.stringifyString({
				comment: comment$1,
				type,
				value: str
			}, ctx, onComment, onChompKeep);
		}
	};
	exports.binary = binary$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js": ((exports) => {
	var identity$14 = require_identity();
	var Pair$5 = require_Pair();
	var Scalar$7 = require_Scalar();
	var YAMLSeq$5 = require_YAMLSeq();
	function resolvePairs(seq$6, onError) {
		if (identity$14.isSeq(seq$6)) for (let i$1 = 0; i$1 < seq$6.items.length; ++i$1) {
			let item = seq$6.items[i$1];
			if (identity$14.isPair(item)) continue;
			else if (identity$14.isMap(item)) {
				if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
				const pair = item.items[0] || new Pair$5.Pair(new Scalar$7.Scalar(null));
				if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
				if (item.comment) {
					const cn = pair.value ?? pair.key;
					cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
				}
				item = pair;
			}
			seq$6.items[i$1] = identity$14.isPair(item) ? item : new Pair$5.Pair(item);
		}
		else onError("Expected a sequence for this tag");
		return seq$6;
	}
	function createPairs(schema$6, iterable, ctx) {
		const { replacer } = ctx;
		const pairs$4 = new YAMLSeq$5.YAMLSeq(schema$6);
		pairs$4.tag = "tag:yaml.org,2002:pairs";
		let i$1 = 0;
		if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
			if (typeof replacer === "function") it = replacer.call(iterable, String(i$1++), it);
			let key, value;
			if (Array.isArray(it)) if (it.length === 2) {
				key = it[0];
				value = it[1];
			} else throw new TypeError(`Expected [key, value] tuple: ${it}`);
			else if (it && it instanceof Object) {
				const keys = Object.keys(it);
				if (keys.length === 1) {
					key = keys[0];
					value = it[key];
				} else throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
			} else key = it;
			pairs$4.items.push(Pair$5.createPair(key, value, ctx));
		}
		return pairs$4;
	}
	const pairs$3 = {
		collection: "seq",
		default: false,
		tag: "tag:yaml.org,2002:pairs",
		resolve: resolvePairs,
		createNode: createPairs
	};
	exports.createPairs = createPairs;
	exports.pairs = pairs$3;
	exports.resolvePairs = resolvePairs;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js": ((exports) => {
	var identity$13 = require_identity();
	var toJS$1 = require_toJS();
	var YAMLMap$5 = require_YAMLMap();
	var YAMLSeq$4 = require_YAMLSeq();
	var pairs$2 = require_pairs();
	var YAMLOMap = class YAMLOMap extends YAMLSeq$4.YAMLSeq {
		constructor() {
			super();
			this.add = YAMLMap$5.YAMLMap.prototype.add.bind(this);
			this.delete = YAMLMap$5.YAMLMap.prototype.delete.bind(this);
			this.get = YAMLMap$5.YAMLMap.prototype.get.bind(this);
			this.has = YAMLMap$5.YAMLMap.prototype.has.bind(this);
			this.set = YAMLMap$5.YAMLMap.prototype.set.bind(this);
			this.tag = YAMLOMap.tag;
		}
		/**
		* If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
		* but TypeScript won't allow widening the signature of a child method.
		*/
		toJSON(_$1, ctx) {
			if (!ctx) return super.toJSON(_$1);
			const map$6 = /* @__PURE__ */ new Map();
			if (ctx?.onCreate) ctx.onCreate(map$6);
			for (const pair of this.items) {
				let key, value;
				if (identity$13.isPair(pair)) {
					key = toJS$1.toJS(pair.key, "", ctx);
					value = toJS$1.toJS(pair.value, key, ctx);
				} else key = toJS$1.toJS(pair, "", ctx);
				if (map$6.has(key)) throw new Error("Ordered maps must not include duplicate keys");
				map$6.set(key, value);
			}
			return map$6;
		}
		static from(schema$6, iterable, ctx) {
			const pairs$1$1 = pairs$2.createPairs(schema$6, iterable, ctx);
			const omap$3 = new this();
			omap$3.items = pairs$1$1.items;
			return omap$3;
		}
	};
	YAMLOMap.tag = "tag:yaml.org,2002:omap";
	const omap$2 = {
		collection: "seq",
		identify: (value) => value instanceof Map,
		nodeClass: YAMLOMap,
		default: false,
		tag: "tag:yaml.org,2002:omap",
		resolve(seq$6, onError) {
			const pairs$1$1 = pairs$2.resolvePairs(seq$6, onError);
			const seenKeys = [];
			for (const { key } of pairs$1$1.items) if (identity$13.isScalar(key)) if (seenKeys.includes(key.value)) onError(`Ordered maps must not include duplicate keys: ${key.value}`);
			else seenKeys.push(key.value);
			return Object.assign(new YAMLOMap(), pairs$1$1);
		},
		createNode: (schema$6, iterable, ctx) => YAMLOMap.from(schema$6, iterable, ctx)
	};
	exports.YAMLOMap = YAMLOMap;
	exports.omap = omap$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js": ((exports) => {
	var Scalar$6 = require_Scalar();
	function boolStringify({ value, source }, ctx) {
		if (source && (value ? trueTag : falseTag).test.test(source)) return source;
		return value ? ctx.options.trueStr : ctx.options.falseStr;
	}
	const trueTag = {
		identify: (value) => value === true,
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
		resolve: () => new Scalar$6.Scalar(true),
		stringify: boolStringify
	};
	const falseTag = {
		identify: (value) => value === false,
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
		resolve: () => new Scalar$6.Scalar(false),
		stringify: boolStringify
	};
	exports.falseTag = falseTag;
	exports.trueTag = trueTag;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/float.js": ((exports) => {
	var Scalar$5 = require_Scalar();
	var stringifyNumber$2 = require_stringifyNumber();
	const floatNaN = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
		resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
		stringify: stringifyNumber$2.stringifyNumber
	};
	const floatExp = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "EXP",
		test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
		resolve: (str) => parseFloat(str.replace(/_/g, "")),
		stringify(node) {
			const num = Number(node.value);
			return isFinite(num) ? num.toExponential() : stringifyNumber$2.stringifyNumber(node);
		}
	};
	const float$2 = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
		resolve(str) {
			const node = new Scalar$5.Scalar(parseFloat(str.replace(/_/g, "")));
			const dot = str.indexOf(".");
			if (dot !== -1) {
				const f$2 = str.substring(dot + 1).replace(/_/g, "");
				if (f$2[f$2.length - 1] === "0") node.minFractionDigits = f$2.length;
			}
			return node;
		},
		stringify: stringifyNumber$2.stringifyNumber
	};
	exports.float = float$2;
	exports.floatExp = floatExp;
	exports.floatNaN = floatNaN;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/int.js": ((exports) => {
	var stringifyNumber$1 = require_stringifyNumber();
	const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
	function intResolve(str, offset, radix, { intAsBigInt }) {
		const sign = str[0];
		if (sign === "-" || sign === "+") offset += 1;
		str = str.substring(offset).replace(/_/g, "");
		if (intAsBigInt) {
			switch (radix) {
				case 2:
					str = `0b${str}`;
					break;
				case 8:
					str = `0o${str}`;
					break;
				case 16:
					str = `0x${str}`;
					break;
			}
			const n$2 = BigInt(str);
			return sign === "-" ? BigInt(-1) * n$2 : n$2;
		}
		const n$1 = parseInt(str, radix);
		return sign === "-" ? -1 * n$1 : n$1;
	}
	function intStringify(node, radix, prefix) {
		const { value } = node;
		if (intIdentify(value)) {
			const str = value.toString(radix);
			return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
		}
		return stringifyNumber$1.stringifyNumber(node);
	}
	const intBin = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "BIN",
		test: /^[-+]?0b[0-1_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
		stringify: (node) => intStringify(node, 2, "0b")
	};
	const intOct = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "OCT",
		test: /^[-+]?0[0-7_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
		stringify: (node) => intStringify(node, 8, "0")
	};
	const int$2 = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^[-+]?[0-9][0-9_]*$/,
		resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
		stringify: stringifyNumber$1.stringifyNumber
	};
	const intHex = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "HEX",
		test: /^[-+]?0x[0-9a-fA-F_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
		stringify: (node) => intStringify(node, 16, "0x")
	};
	exports.int = int$2;
	exports.intBin = intBin;
	exports.intHex = intHex;
	exports.intOct = intOct;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/set.js": ((exports) => {
	var identity$12 = require_identity();
	var Pair$4 = require_Pair();
	var YAMLMap$4 = require_YAMLMap();
	var YAMLSet = class YAMLSet extends YAMLMap$4.YAMLMap {
		constructor(schema$6) {
			super(schema$6);
			this.tag = YAMLSet.tag;
		}
		add(key) {
			let pair;
			if (identity$12.isPair(key)) pair = key;
			else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new Pair$4.Pair(key.key, null);
			else pair = new Pair$4.Pair(key, null);
			if (!YAMLMap$4.findPair(this.items, pair.key)) this.items.push(pair);
		}
		/**
		* If `keepPair` is `true`, returns the Pair matching `key`.
		* Otherwise, returns the value of that Pair's key.
		*/
		get(key, keepPair) {
			const pair = YAMLMap$4.findPair(this.items, key);
			return !keepPair && identity$12.isPair(pair) ? identity$12.isScalar(pair.key) ? pair.key.value : pair.key : pair;
		}
		set(key, value) {
			if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
			const prev = YAMLMap$4.findPair(this.items, key);
			if (prev && !value) this.items.splice(this.items.indexOf(prev), 1);
			else if (!prev && value) this.items.push(new Pair$4.Pair(key));
		}
		toJSON(_$1, ctx) {
			return super.toJSON(_$1, ctx, Set);
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
			else throw new Error("Set items must all have null values");
		}
		static from(schema$6, iterable, ctx) {
			const { replacer } = ctx;
			const set$3 = new this(schema$6);
			if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) {
				if (typeof replacer === "function") value = replacer.call(iterable, value, value);
				set$3.items.push(Pair$4.createPair(value, null, ctx));
			}
			return set$3;
		}
	};
	YAMLSet.tag = "tag:yaml.org,2002:set";
	const set$2 = {
		collection: "map",
		identify: (value) => value instanceof Set,
		nodeClass: YAMLSet,
		default: false,
		tag: "tag:yaml.org,2002:set",
		createNode: (schema$6, iterable, ctx) => YAMLSet.from(schema$6, iterable, ctx),
		resolve(map$6, onError) {
			if (identity$12.isMap(map$6)) if (map$6.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map$6);
			else onError("Set items must all have null values");
			else onError("Expected a mapping for this tag");
			return map$6;
		}
	};
	exports.YAMLSet = YAMLSet;
	exports.set = set$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js": ((exports) => {
	var stringifyNumber = require_stringifyNumber();
	/** Internal types handle bigint as number, because TS can't figure it out. */
	function parseSexagesimal(str, asBigInt) {
		const sign = str[0];
		const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
		const num = (n$1) => asBigInt ? BigInt(n$1) : Number(n$1);
		const res = parts.replace(/_/g, "").split(":").reduce((res$1, p$2) => res$1 * num(60) + num(p$2), num(0));
		return sign === "-" ? num(-1) * res : res;
	}
	/**
	* hhhh:mm:ss.sss
	*
	* Internal types handle bigint as number, because TS can't figure it out.
	*/
	function stringifySexagesimal(node) {
		let { value } = node;
		let num = (n$1) => n$1;
		if (typeof value === "bigint") num = (n$1) => BigInt(n$1);
		else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
		let sign = "";
		if (value < 0) {
			sign = "-";
			value *= num(-1);
		}
		const _60 = num(60);
		const parts = [value % _60];
		if (value < 60) parts.unshift(0);
		else {
			value = (value - parts[0]) / _60;
			parts.unshift(value % _60);
			if (value >= 60) {
				value = (value - parts[0]) / _60;
				parts.unshift(value);
			}
		}
		return sign + parts.map((n$1) => String(n$1).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
	}
	const intTime = {
		identify: (value) => typeof value === "bigint" || Number.isInteger(value),
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "TIME",
		test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
		resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
		stringify: stringifySexagesimal
	};
	const floatTime = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "TIME",
		test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
		resolve: (str) => parseSexagesimal(str, false),
		stringify: stringifySexagesimal
	};
	const timestamp$2 = {
		identify: (value) => value instanceof Date,
		default: true,
		tag: "tag:yaml.org,2002:timestamp",
		test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
		resolve(str) {
			const match = str.match(timestamp$2.test);
			if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
			const [, year, month, day, hour, minute, second] = match.map(Number);
			const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
			let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
			const tz = match[8];
			if (tz && tz !== "Z") {
				let d$1 = parseSexagesimal(tz, false);
				if (Math.abs(d$1) < 30) d$1 *= 60;
				date -= 6e4 * d$1;
			}
			return new Date(date);
		},
		stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
	};
	exports.floatTime = floatTime;
	exports.intTime = intTime;
	exports.timestamp = timestamp$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js": ((exports) => {
	var map$2 = require_map();
	var _null$1 = require_null();
	var seq$2 = require_seq();
	var string$2 = require_string();
	var binary$1 = require_binary();
	var bool$1 = require_bool();
	var float$1 = require_float();
	var int$1 = require_int();
	var merge$2 = require_merge();
	var omap$1 = require_omap();
	var pairs$1 = require_pairs();
	var set$1 = require_set();
	var timestamp$1 = require_timestamp();
	const schema$3 = [
		map$2.map,
		seq$2.seq,
		string$2.string,
		_null$1.nullTag,
		bool$1.trueTag,
		bool$1.falseTag,
		int$1.intBin,
		int$1.intOct,
		int$1.int,
		int$1.intHex,
		float$1.floatNaN,
		float$1.floatExp,
		float$1.float,
		binary$1.binary,
		merge$2.merge,
		omap$1.omap,
		pairs$1.pairs,
		set$1.set,
		timestamp$1.intTime,
		timestamp$1.floatTime,
		timestamp$1.timestamp
	];
	exports.schema = schema$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/tags.js
var require_tags = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/tags.js": ((exports) => {
	var map$1 = require_map();
	var _null = require_null();
	var seq$1 = require_seq();
	var string$1 = require_string();
	var bool = require_bool$1();
	var float = require_float$1();
	var int = require_int$1();
	var schema = require_schema$2();
	var schema$1 = require_schema$1();
	var binary = require_binary();
	var merge$1 = require_merge();
	var omap = require_omap();
	var pairs = require_pairs();
	var schema$2 = require_schema();
	var set = require_set();
	var timestamp = require_timestamp();
	const schemas = new Map([
		["core", schema.schema],
		["failsafe", [
			map$1.map,
			seq$1.seq,
			string$1.string
		]],
		["json", schema$1.schema],
		["yaml11", schema$2.schema],
		["yaml-1.1", schema$2.schema]
	]);
	const tagsByName = {
		binary: binary.binary,
		bool: bool.boolTag,
		float: float.float,
		floatExp: float.floatExp,
		floatNaN: float.floatNaN,
		floatTime: timestamp.floatTime,
		int: int.int,
		intHex: int.intHex,
		intOct: int.intOct,
		intTime: timestamp.intTime,
		map: map$1.map,
		merge: merge$1.merge,
		null: _null.nullTag,
		omap: omap.omap,
		pairs: pairs.pairs,
		seq: seq$1.seq,
		set: set.set,
		timestamp: timestamp.timestamp
	};
	const coreKnownTags = {
		"tag:yaml.org,2002:binary": binary.binary,
		"tag:yaml.org,2002:merge": merge$1.merge,
		"tag:yaml.org,2002:omap": omap.omap,
		"tag:yaml.org,2002:pairs": pairs.pairs,
		"tag:yaml.org,2002:set": set.set,
		"tag:yaml.org,2002:timestamp": timestamp.timestamp
	};
	function getTags(customTags, schemaName, addMergeTag) {
		const schemaTags = schemas.get(schemaName);
		if (schemaTags && !customTags) return addMergeTag && !schemaTags.includes(merge$1.merge) ? schemaTags.concat(merge$1.merge) : schemaTags.slice();
		let tags$1 = schemaTags;
		if (!tags$1) if (Array.isArray(customTags)) tags$1 = [];
		else {
			const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
			throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
		}
		if (Array.isArray(customTags)) for (const tag of customTags) tags$1 = tags$1.concat(tag);
		else if (typeof customTags === "function") tags$1 = customTags(tags$1.slice());
		if (addMergeTag) tags$1 = tags$1.concat(merge$1.merge);
		return tags$1.reduce((tags$2, tag) => {
			const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
			if (!tagObj) {
				const tagName = JSON.stringify(tag);
				const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
				throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
			}
			if (!tags$2.includes(tagObj)) tags$2.push(tagObj);
			return tags$2;
		}, []);
	}
	exports.coreKnownTags = coreKnownTags;
	exports.getTags = getTags;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/Schema.js
var require_Schema = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/Schema.js": ((exports) => {
	var identity$11 = require_identity();
	var map = require_map();
	var seq = require_seq();
	var string = require_string();
	var tags = require_tags();
	const sortMapEntriesByKey = (a, b$1) => a.key < b$1.key ? -1 : a.key > b$1.key ? 1 : 0;
	var Schema$2 = class Schema$2 {
		constructor({ compat, customTags, merge: merge$5, resolveKnownTags, schema: schema$6, sortMapEntries, toStringDefaults }) {
			this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
			this.name = typeof schema$6 === "string" && schema$6 || "core";
			this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
			this.tags = tags.getTags(customTags, this.name, merge$5);
			this.toStringOptions = toStringDefaults ?? null;
			Object.defineProperty(this, identity$11.MAP, { value: map.map });
			Object.defineProperty(this, identity$11.SCALAR, { value: string.string });
			Object.defineProperty(this, identity$11.SEQ, { value: seq.seq });
			this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
		}
		clone() {
			const copy$1 = Object.create(Schema$2.prototype, Object.getOwnPropertyDescriptors(this));
			copy$1.tags = this.tags.slice();
			return copy$1;
		}
	};
	exports.Schema = Schema$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyDocument.js": ((exports) => {
	var identity$10 = require_identity();
	var stringify$2 = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyDocument$1(doc, options) {
		const lines = [];
		let hasDirectives = options.directives === true;
		if (options.directives !== false && doc.directives) {
			const dir = doc.directives.toString(doc);
			if (dir) {
				lines.push(dir);
				hasDirectives = true;
			} else if (doc.directives.docStart) hasDirectives = true;
		}
		if (hasDirectives) lines.push("---");
		const ctx = stringify$2.createStringifyContext(doc, options);
		const { commentString } = ctx.options;
		if (doc.commentBefore) {
			if (lines.length !== 1) lines.unshift("");
			const cs = commentString(doc.commentBefore);
			lines.unshift(stringifyComment.indentComment(cs, ""));
		}
		let chompKeep = false;
		let contentComment = null;
		if (doc.contents) {
			if (identity$10.isNode(doc.contents)) {
				if (doc.contents.spaceBefore && hasDirectives) lines.push("");
				if (doc.contents.commentBefore) {
					const cs = commentString(doc.contents.commentBefore);
					lines.push(stringifyComment.indentComment(cs, ""));
				}
				ctx.forceBlockIndent = !!doc.comment;
				contentComment = doc.contents.comment;
			}
			const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
			let body = stringify$2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
			if (contentComment) body += stringifyComment.lineComment(body, "", commentString(contentComment));
			if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") lines[lines.length - 1] = `--- ${body}`;
			else lines.push(body);
		} else lines.push(stringify$2.stringify(doc.contents, ctx));
		if (doc.directives?.docEnd) if (doc.comment) {
			const cs = commentString(doc.comment);
			if (cs.includes("\n")) {
				lines.push("...");
				lines.push(stringifyComment.indentComment(cs, ""));
			} else lines.push(`... ${cs}`);
		} else lines.push("...");
		else {
			let dc = doc.comment;
			if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
			if (dc) {
				if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
				lines.push(stringifyComment.indentComment(commentString(dc), ""));
			}
		}
		return lines.join("\n") + "\n";
	}
	exports.stringifyDocument = stringifyDocument$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/Document.js
var require_Document = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/Document.js": ((exports) => {
	var Alias$2 = require_Alias();
	var Collection = require_Collection();
	var identity$9 = require_identity();
	var Pair$3 = require_Pair();
	var toJS = require_toJS();
	var Schema$1 = require_Schema();
	var stringifyDocument = require_stringifyDocument();
	var anchors = require_anchors();
	var applyReviver = require_applyReviver();
	var createNode = require_createNode();
	var directives$1 = require_directives();
	var Document$5 = class Document$5 {
		constructor(value, replacer, options) {
			/** A comment before this Document */
			this.commentBefore = null;
			/** A comment immediately after this Document */
			this.comment = null;
			/** Errors encountered during parsing. */
			this.errors = [];
			/** Warnings encountered during parsing. */
			this.warnings = [];
			Object.defineProperty(this, identity$9.NODE_TYPE, { value: identity$9.DOC });
			let _replacer = null;
			if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
			else if (options === void 0 && replacer) {
				options = replacer;
				replacer = void 0;
			}
			const opt = Object.assign({
				intAsBigInt: false,
				keepSourceTokens: false,
				logLevel: "warn",
				prettyErrors: true,
				strict: true,
				stringKeys: false,
				uniqueKeys: true,
				version: "1.2"
			}, options);
			this.options = opt;
			let { version: version$1 } = opt;
			if (options?._directives) {
				this.directives = options._directives.atDocument();
				if (this.directives.yaml.explicit) version$1 = this.directives.yaml.version;
			} else this.directives = new directives$1.Directives({ version: version$1 });
			this.setSchema(version$1, options);
			this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
		}
		/**
		* Create a deep copy of this Document and its contents.
		*
		* Custom Node values that inherit from `Object` still refer to their original instances.
		*/
		clone() {
			const copy$1 = Object.create(Document$5.prototype, { [identity$9.NODE_TYPE]: { value: identity$9.DOC } });
			copy$1.commentBefore = this.commentBefore;
			copy$1.comment = this.comment;
			copy$1.errors = this.errors.slice();
			copy$1.warnings = this.warnings.slice();
			copy$1.options = Object.assign({}, this.options);
			if (this.directives) copy$1.directives = this.directives.clone();
			copy$1.schema = this.schema.clone();
			copy$1.contents = identity$9.isNode(this.contents) ? this.contents.clone(copy$1.schema) : this.contents;
			if (this.range) copy$1.range = this.range.slice();
			return copy$1;
		}
		/** Adds a value to the document. */
		add(value) {
			if (assertCollection(this.contents)) this.contents.add(value);
		}
		/** Adds a value to the document. */
		addIn(path$2, value) {
			if (assertCollection(this.contents)) this.contents.addIn(path$2, value);
		}
		/**
		* Create a new `Alias` node, ensuring that the target `node` has the required anchor.
		*
		* If `node` already has an anchor, `name` is ignored.
		* Otherwise, the `node.anchor` value will be set to `name`,
		* or if an anchor with that name is already present in the document,
		* `name` will be used as a prefix for a new unique anchor.
		* If `name` is undefined, the generated anchor will use 'a' as a prefix.
		*/
		createAlias(node, name) {
			if (!node.anchor) {
				const prev = anchors.anchorNames(this);
				node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
			}
			return new Alias$2.Alias(node.anchor);
		}
		createNode(value, replacer, options) {
			let _replacer = void 0;
			if (typeof replacer === "function") {
				value = replacer.call({ "": value }, "", value);
				_replacer = replacer;
			} else if (Array.isArray(replacer)) {
				const keyToStr = (v$2) => typeof v$2 === "number" || v$2 instanceof String || v$2 instanceof Number;
				const asStr = replacer.filter(keyToStr).map(String);
				if (asStr.length > 0) replacer = replacer.concat(asStr);
				_replacer = replacer;
			} else if (options === void 0 && replacer) {
				options = replacer;
				replacer = void 0;
			}
			const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
			const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
			const ctx = {
				aliasDuplicateObjects: aliasDuplicateObjects ?? true,
				keepUndefined: keepUndefined ?? false,
				onAnchor,
				onTagObj,
				replacer: _replacer,
				schema: this.schema,
				sourceObjects
			};
			const node = createNode.createNode(value, tag, ctx);
			if (flow && identity$9.isCollection(node)) node.flow = true;
			setAnchors();
			return node;
		}
		/**
		* Convert a key and a value into a `Pair` using the current schema,
		* recursively wrapping all values as `Scalar` or `Collection` nodes.
		*/
		createPair(key, value, options = {}) {
			const k$2 = this.createNode(key, null, options);
			const v$2 = this.createNode(value, null, options);
			return new Pair$3.Pair(k$2, v$2);
		}
		/**
		* Removes a value from the document.
		* @returns `true` if the item was found and removed.
		*/
		delete(key) {
			return assertCollection(this.contents) ? this.contents.delete(key) : false;
		}
		/**
		* Removes a value from the document.
		* @returns `true` if the item was found and removed.
		*/
		deleteIn(path$2) {
			if (Collection.isEmptyPath(path$2)) {
				if (this.contents == null) return false;
				this.contents = null;
				return true;
			}
			return assertCollection(this.contents) ? this.contents.deleteIn(path$2) : false;
		}
		/**
		* Returns item at `key`, or `undefined` if not found. By default unwraps
		* scalar values from their surrounding node; to disable set `keepScalar` to
		* `true` (collections are always returned intact).
		*/
		get(key, keepScalar) {
			return identity$9.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
		}
		/**
		* Returns item at `path`, or `undefined` if not found. By default unwraps
		* scalar values from their surrounding node; to disable set `keepScalar` to
		* `true` (collections are always returned intact).
		*/
		getIn(path$2, keepScalar) {
			if (Collection.isEmptyPath(path$2)) return !keepScalar && identity$9.isScalar(this.contents) ? this.contents.value : this.contents;
			return identity$9.isCollection(this.contents) ? this.contents.getIn(path$2, keepScalar) : void 0;
		}
		/**
		* Checks if the document includes a value with the key `key`.
		*/
		has(key) {
			return identity$9.isCollection(this.contents) ? this.contents.has(key) : false;
		}
		/**
		* Checks if the document includes a value at `path`.
		*/
		hasIn(path$2) {
			if (Collection.isEmptyPath(path$2)) return this.contents !== void 0;
			return identity$9.isCollection(this.contents) ? this.contents.hasIn(path$2) : false;
		}
		/**
		* Sets a value in this document. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*/
		set(key, value) {
			if (this.contents == null) this.contents = Collection.collectionFromPath(this.schema, [key], value);
			else if (assertCollection(this.contents)) this.contents.set(key, value);
		}
		/**
		* Sets a value in this document. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*/
		setIn(path$2, value) {
			if (Collection.isEmptyPath(path$2)) this.contents = value;
			else if (this.contents == null) this.contents = Collection.collectionFromPath(this.schema, Array.from(path$2), value);
			else if (assertCollection(this.contents)) this.contents.setIn(path$2, value);
		}
		/**
		* Change the YAML version and schema used by the document.
		* A `null` version disables support for directives, explicit tags, anchors, and aliases.
		* It also requires the `schema` option to be given as a `Schema` instance value.
		*
		* Overrides all previously set schema options.
		*/
		setSchema(version$1, options = {}) {
			if (typeof version$1 === "number") version$1 = String(version$1);
			let opt;
			switch (version$1) {
				case "1.1":
					if (this.directives) this.directives.yaml.version = "1.1";
					else this.directives = new directives$1.Directives({ version: "1.1" });
					opt = {
						resolveKnownTags: false,
						schema: "yaml-1.1"
					};
					break;
				case "1.2":
				case "next":
					if (this.directives) this.directives.yaml.version = version$1;
					else this.directives = new directives$1.Directives({ version: version$1 });
					opt = {
						resolveKnownTags: true,
						schema: "core"
					};
					break;
				case null:
					if (this.directives) delete this.directives;
					opt = null;
					break;
				default: {
					const sv = JSON.stringify(version$1);
					throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
				}
			}
			if (options.schema instanceof Object) this.schema = options.schema;
			else if (opt) this.schema = new Schema$1.Schema(Object.assign(opt, options));
			else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
		}
		toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
			const ctx = {
				anchors: /* @__PURE__ */ new Map(),
				doc: this,
				keep: !json,
				mapAsMap: mapAsMap === true,
				mapKeyWarned: false,
				maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
			};
			const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
			if (typeof onAnchor === "function") for (const { count, res: res$1 } of ctx.anchors.values()) onAnchor(res$1, count);
			return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
		}
		/**
		* A JSON representation of the document `contents`.
		*
		* @param jsonArg Used by `JSON.stringify` to indicate the array index or
		*   property name.
		*/
		toJSON(jsonArg, onAnchor) {
			return this.toJS({
				json: true,
				jsonArg,
				mapAsMap: false,
				onAnchor
			});
		}
		/** A YAML representation of the document. */
		toString(options = {}) {
			if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
			if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
				const s = JSON.stringify(options.indent);
				throw new Error(`"indent" option must be a positive integer, not ${s}`);
			}
			return stringifyDocument.stringifyDocument(this, options);
		}
	};
	function assertCollection(contents) {
		if (identity$9.isCollection(contents)) return true;
		throw new Error("Expected a YAML collection as document contents");
	}
	exports.Document = Document$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/errors.js
var require_errors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/errors.js": ((exports) => {
	var YAMLError = class extends Error {
		constructor(name, pos, code, message) {
			super();
			this.name = name;
			this.code = code;
			this.message = message;
			this.pos = pos;
		}
	};
	var YAMLParseError = class extends YAMLError {
		constructor(pos, code, message) {
			super("YAMLParseError", pos, code, message);
		}
	};
	var YAMLWarning = class extends YAMLError {
		constructor(pos, code, message) {
			super("YAMLWarning", pos, code, message);
		}
	};
	const prettifyError = (src, lc) => (error) => {
		if (error.pos[0] === -1) return;
		error.linePos = error.pos.map((pos) => lc.linePos(pos));
		const { line, col } = error.linePos[0];
		error.message += ` at line ${line}, column ${col}`;
		let ci = col - 1;
		let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
		if (ci >= 60 && lineStr.length > 80) {
			const trimStart = Math.min(ci - 39, lineStr.length - 79);
			lineStr = "" + lineStr.substring(trimStart);
			ci -= trimStart - 1;
		}
		if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "";
		if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
			let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
			if (prev.length > 80) prev = prev.substring(0, 79) + "\n";
			lineStr = prev + lineStr;
		}
		if (/[^ ]/.test(lineStr)) {
			let count = 1;
			const end = error.linePos[1];
			if (end && end.line === line && end.col > col) count = Math.max(1, Math.min(end.col - col, 80 - ci));
			const pointer = " ".repeat(ci) + "^".repeat(count);
			error.message += `:\n\n${lineStr}\n${pointer}\n`;
		}
	};
	exports.YAMLError = YAMLError;
	exports.YAMLParseError = YAMLParseError;
	exports.YAMLWarning = YAMLWarning;
	exports.prettifyError = prettifyError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-props.js": ((exports) => {
	function resolveProps$4(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
		let spaceBefore = false;
		let atNewline = startOnNewline;
		let hasSpace = startOnNewline;
		let comment$1 = "";
		let commentSep = "";
		let hasNewline = false;
		let reqSpace = false;
		let tab = null;
		let anchor = null;
		let tag = null;
		let newlineAfterProp = null;
		let comma$1 = null;
		let found = null;
		let start = null;
		for (const token of tokens) {
			if (reqSpace) {
				if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
				reqSpace = false;
			}
			if (tab) {
				if (atNewline && token.type !== "comment" && token.type !== "newline") onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
				tab = null;
			}
			switch (token.type) {
				case "space":
					if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) tab = token;
					hasSpace = true;
					break;
				case "comment": {
					if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					const cb = token.source.substring(1) || " ";
					if (!comment$1) comment$1 = cb;
					else comment$1 += commentSep + cb;
					commentSep = "";
					atNewline = false;
					break;
				}
				case "newline":
					if (atNewline) {
						if (comment$1) comment$1 += token.source;
						else if (!found || indicator !== "seq-item-ind") spaceBefore = true;
					} else commentSep += token.source;
					atNewline = true;
					hasNewline = true;
					if (anchor || tag) newlineAfterProp = token;
					hasSpace = true;
					break;
				case "anchor":
					if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
					if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
					anchor = token;
					start ?? (start = token.offset);
					atNewline = false;
					hasSpace = false;
					reqSpace = true;
					break;
				case "tag":
					if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
					tag = token;
					start ?? (start = token.offset);
					atNewline = false;
					hasSpace = false;
					reqSpace = true;
					break;
				case indicator:
					if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
					if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
					found = token;
					atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
					hasSpace = false;
					break;
				case "comma": if (flow) {
					if (comma$1) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
					comma$1 = token;
					atNewline = false;
					hasSpace = false;
					break;
				}
				default:
					onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
					atNewline = false;
					hasSpace = false;
			}
		}
		const last = tokens[tokens.length - 1];
		const end = last ? last.offset + last.source.length : offset;
		if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
		if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq")) onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
		return {
			comma: comma$1,
			found,
			spaceBefore,
			comment: comment$1,
			hasNewline,
			anchor,
			tag,
			newlineAfterProp,
			end,
			start: start ?? end
		};
	}
	exports.resolveProps = resolveProps$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-contains-newline.js": ((exports) => {
	function containsNewline(key) {
		if (!key) return null;
		switch (key.type) {
			case "alias":
			case "scalar":
			case "double-quoted-scalar":
			case "single-quoted-scalar":
				if (key.source.includes("\n")) return true;
				if (key.end) {
					for (const st of key.end) if (st.type === "newline") return true;
				}
				return false;
			case "flow-collection":
				for (const it of key.items) {
					for (const st of it.start) if (st.type === "newline") return true;
					if (it.sep) {
						for (const st of it.sep) if (st.type === "newline") return true;
					}
					if (containsNewline(it.key) || containsNewline(it.value)) return true;
				}
				return false;
			default: return true;
		}
	}
	exports.containsNewline = containsNewline;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-flow-indent-check.js": ((exports) => {
	var utilContainsNewline$2 = require_util_contains_newline();
	function flowIndentCheck(indent$2, fc, onError) {
		if (fc?.type === "flow-collection") {
			const end = fc.end[0];
			if (end.indent === indent$2 && (end.source === "]" || end.source === "}") && utilContainsNewline$2.containsNewline(fc)) onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
		}
	}
	exports.flowIndentCheck = flowIndentCheck;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-map-includes.js": ((exports) => {
	var identity$8 = require_identity();
	function mapIncludes(ctx, items, search) {
		const { uniqueKeys } = ctx.options;
		if (uniqueKeys === false) return false;
		const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b$1) => a === b$1 || identity$8.isScalar(a) && identity$8.isScalar(b$1) && a.value === b$1.value;
		return items.some((pair) => isEqual(pair.key, search));
	}
	exports.mapIncludes = mapIncludes;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-map.js": ((exports) => {
	var Pair$2 = require_Pair();
	var YAMLMap$3 = require_YAMLMap();
	var resolveProps$3 = require_resolve_props();
	var utilContainsNewline$1 = require_util_contains_newline();
	var utilFlowIndentCheck$1 = require_util_flow_indent_check();
	var utilMapIncludes$1 = require_util_map_includes();
	const startColMsg = "All mapping items must start at the same column";
	function resolveBlockMap$1({ composeNode: composeNode$2, composeEmptyNode: composeEmptyNode$1 }, ctx, bm, onError, tag) {
		const map$6 = new (tag?.nodeClass ?? YAMLMap$3.YAMLMap)(ctx.schema);
		if (ctx.atRoot) ctx.atRoot = false;
		let offset = bm.offset;
		let commentEnd = null;
		for (const collItem of bm.items) {
			const { start, key, sep: sep$1, value } = collItem;
			const keyProps = resolveProps$3.resolveProps(start, {
				indicator: "explicit-key-ind",
				next: key ?? sep$1?.[0],
				offset,
				onError,
				parentIndent: bm.indent,
				startOnNewline: true
			});
			const implicitKey = !keyProps.found;
			if (implicitKey) {
				if (key) {
					if (key.type === "block-seq") onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
					else if ("indent" in key && key.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
				}
				if (!keyProps.anchor && !keyProps.tag && !sep$1) {
					commentEnd = keyProps.end;
					if (keyProps.comment) if (map$6.comment) map$6.comment += "\n" + keyProps.comment;
					else map$6.comment = keyProps.comment;
					continue;
				}
				if (keyProps.newlineAfterProp || utilContainsNewline$1.containsNewline(key)) onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
			} else if (keyProps.found?.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
			ctx.atKey = true;
			const keyStart = keyProps.end;
			const keyNode = key ? composeNode$2(ctx, key, keyProps, onError) : composeEmptyNode$1(ctx, keyStart, start, null, keyProps, onError);
			if (ctx.schema.compat) utilFlowIndentCheck$1.flowIndentCheck(bm.indent, key, onError);
			ctx.atKey = false;
			if (utilMapIncludes$1.mapIncludes(ctx, map$6.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
			const valueProps = resolveProps$3.resolveProps(sep$1 ?? [], {
				indicator: "map-value-ind",
				next: value,
				offset: keyNode.range[2],
				onError,
				parentIndent: bm.indent,
				startOnNewline: !key || key.type === "block-scalar"
			});
			offset = valueProps.end;
			if (valueProps.found) {
				if (implicitKey) {
					if (value?.type === "block-map" && !valueProps.hasNewline) onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
					if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
				}
				const valueNode = value ? composeNode$2(ctx, value, valueProps, onError) : composeEmptyNode$1(ctx, offset, sep$1, null, valueProps, onError);
				if (ctx.schema.compat) utilFlowIndentCheck$1.flowIndentCheck(bm.indent, value, onError);
				offset = valueNode.range[2];
				const pair = new Pair$2.Pair(keyNode, valueNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				map$6.items.push(pair);
			} else {
				if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
				if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
				else keyNode.comment = valueProps.comment;
				const pair = new Pair$2.Pair(keyNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				map$6.items.push(pair);
			}
		}
		if (commentEnd && commentEnd < offset) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
		map$6.range = [
			bm.offset,
			offset,
			commentEnd ?? offset
		];
		return map$6;
	}
	exports.resolveBlockMap = resolveBlockMap$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-seq.js": ((exports) => {
	var YAMLSeq$3 = require_YAMLSeq();
	var resolveProps$2 = require_resolve_props();
	var utilFlowIndentCheck = require_util_flow_indent_check();
	function resolveBlockSeq$1({ composeNode: composeNode$2, composeEmptyNode: composeEmptyNode$1 }, ctx, bs, onError, tag) {
		const seq$6 = new (tag?.nodeClass ?? YAMLSeq$3.YAMLSeq)(ctx.schema);
		if (ctx.atRoot) ctx.atRoot = false;
		if (ctx.atKey) ctx.atKey = false;
		let offset = bs.offset;
		let commentEnd = null;
		for (const { start, value } of bs.items) {
			const props = resolveProps$2.resolveProps(start, {
				indicator: "seq-item-ind",
				next: value,
				offset,
				onError,
				parentIndent: bs.indent,
				startOnNewline: true
			});
			if (!props.found) if (props.anchor || props.tag || value) if (value && value.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
			else onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
			else {
				commentEnd = props.end;
				if (props.comment) seq$6.comment = props.comment;
				continue;
			}
			const node = value ? composeNode$2(ctx, value, props, onError) : composeEmptyNode$1(ctx, props.end, start, null, props, onError);
			if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
			offset = node.range[2];
			seq$6.items.push(node);
		}
		seq$6.range = [
			bs.offset,
			offset,
			commentEnd ?? offset
		];
		return seq$6;
	}
	exports.resolveBlockSeq = resolveBlockSeq$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-end.js": ((exports) => {
	function resolveEnd$5(end, offset, reqSpace, onError) {
		let comment$1 = "";
		if (end) {
			let hasSpace = false;
			let sep$1 = "";
			for (const token of end) {
				const { source, type } = token;
				switch (type) {
					case "space":
						hasSpace = true;
						break;
					case "comment": {
						if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
						const cb = source.substring(1) || " ";
						if (!comment$1) comment$1 = cb;
						else comment$1 += sep$1 + cb;
						sep$1 = "";
						break;
					}
					case "newline":
						if (comment$1) sep$1 += source;
						hasSpace = true;
						break;
					default: onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
				}
				offset += source.length;
			}
		}
		return {
			comment: comment$1,
			offset
		};
	}
	exports.resolveEnd = resolveEnd$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-collection.js": ((exports) => {
	var identity$7 = require_identity();
	var Pair$1 = require_Pair();
	var YAMLMap$2 = require_YAMLMap();
	var YAMLSeq$2 = require_YAMLSeq();
	var resolveEnd$4 = require_resolve_end();
	var resolveProps$1 = require_resolve_props();
	var utilContainsNewline = require_util_contains_newline();
	var utilMapIncludes = require_util_map_includes();
	const blockMsg = "Block collections are not allowed within flow collections";
	const isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
	function resolveFlowCollection$1({ composeNode: composeNode$2, composeEmptyNode: composeEmptyNode$1 }, ctx, fc, onError, tag) {
		const isMap$1 = fc.start.source === "{";
		const fcName = isMap$1 ? "flow map" : "flow sequence";
		const coll = new (tag?.nodeClass ?? (isMap$1 ? YAMLMap$2.YAMLMap : YAMLSeq$2.YAMLSeq))(ctx.schema);
		coll.flow = true;
		const atRoot = ctx.atRoot;
		if (atRoot) ctx.atRoot = false;
		if (ctx.atKey) ctx.atKey = false;
		let offset = fc.offset + fc.start.source.length;
		for (let i$1 = 0; i$1 < fc.items.length; ++i$1) {
			const collItem = fc.items[i$1];
			const { start, key, sep: sep$1, value } = collItem;
			const props = resolveProps$1.resolveProps(start, {
				flow: fcName,
				indicator: "explicit-key-ind",
				next: key ?? sep$1?.[0],
				offset,
				onError,
				parentIndent: fc.indent,
				startOnNewline: false
			});
			if (!props.found) {
				if (!props.anchor && !props.tag && !sep$1 && !value) {
					if (i$1 === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
					else if (i$1 < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
					if (props.comment) if (coll.comment) coll.comment += "\n" + props.comment;
					else coll.comment = props.comment;
					offset = props.end;
					continue;
				}
				if (!isMap$1 && ctx.options.strict && utilContainsNewline.containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
			}
			if (i$1 === 0) {
				if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
			} else {
				if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
				if (props.comment) {
					let prevItemComment = "";
					loop: for (const st of start) switch (st.type) {
						case "comma":
						case "space": break;
						case "comment":
							prevItemComment = st.source.substring(1);
							break loop;
						default: break loop;
					}
					if (prevItemComment) {
						let prev = coll.items[coll.items.length - 1];
						if (identity$7.isPair(prev)) prev = prev.value ?? prev.key;
						if (prev.comment) prev.comment += "\n" + prevItemComment;
						else prev.comment = prevItemComment;
						props.comment = props.comment.substring(prevItemComment.length + 1);
					}
				}
			}
			if (!isMap$1 && !sep$1 && !props.found) {
				const valueNode = value ? composeNode$2(ctx, value, props, onError) : composeEmptyNode$1(ctx, props.end, sep$1, null, props, onError);
				coll.items.push(valueNode);
				offset = valueNode.range[2];
				if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
			} else {
				ctx.atKey = true;
				const keyStart = props.end;
				const keyNode = key ? composeNode$2(ctx, key, props, onError) : composeEmptyNode$1(ctx, keyStart, start, null, props, onError);
				if (isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
				ctx.atKey = false;
				const valueProps = resolveProps$1.resolveProps(sep$1 ?? [], {
					flow: fcName,
					indicator: "map-value-ind",
					next: value,
					offset: keyNode.range[2],
					onError,
					parentIndent: fc.indent,
					startOnNewline: false
				});
				if (valueProps.found) {
					if (!isMap$1 && !props.found && ctx.options.strict) {
						if (sep$1) for (const st of sep$1) {
							if (st === valueProps.found) break;
							if (st.type === "newline") {
								onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
								break;
							}
						}
						if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
					}
				} else if (value) if ("source" in value && value.source && value.source[0] === ":") onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
				else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
				const valueNode = value ? composeNode$2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode$1(ctx, valueProps.end, sep$1, null, valueProps, onError) : null;
				if (valueNode) {
					if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
				} else if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
				else keyNode.comment = valueProps.comment;
				const pair = new Pair$1.Pair(keyNode, valueNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				if (isMap$1) {
					const map$6 = coll;
					if (utilMapIncludes.mapIncludes(ctx, map$6.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
					map$6.items.push(pair);
				} else {
					const map$6 = new YAMLMap$2.YAMLMap(ctx.schema);
					map$6.flow = true;
					map$6.items.push(pair);
					const endRange = (valueNode ?? keyNode).range;
					map$6.range = [
						keyNode.range[0],
						endRange[1],
						endRange[2]
					];
					coll.items.push(map$6);
				}
				offset = valueNode ? valueNode.range[2] : valueProps.end;
			}
		}
		const expectedEnd = isMap$1 ? "}" : "]";
		const [ce$1, ...ee] = fc.end;
		let cePos = offset;
		if (ce$1 && ce$1.source === expectedEnd) cePos = ce$1.offset + ce$1.source.length;
		else {
			const name = fcName[0].toUpperCase() + fcName.substring(1);
			const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
			onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
			if (ce$1 && ce$1.source.length !== 1) ee.unshift(ce$1);
		}
		if (ee.length > 0) {
			const end = resolveEnd$4.resolveEnd(ee, cePos, ctx.options.strict, onError);
			if (end.comment) if (coll.comment) coll.comment += "\n" + end.comment;
			else coll.comment = end.comment;
			coll.range = [
				fc.offset,
				cePos,
				end.offset
			];
		} else coll.range = [
			fc.offset,
			cePos,
			cePos
		];
		return coll;
	}
	exports.resolveFlowCollection = resolveFlowCollection$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-collection.js": ((exports) => {
	var identity$6 = require_identity();
	var Scalar$4 = require_Scalar();
	var YAMLMap$1 = require_YAMLMap();
	var YAMLSeq$1 = require_YAMLSeq();
	var resolveBlockMap = require_resolve_block_map();
	var resolveBlockSeq = require_resolve_block_seq();
	var resolveFlowCollection = require_resolve_flow_collection();
	function resolveCollection(CN$1, ctx, token, onError, tagName, tag) {
		const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN$1, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN$1, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN$1, ctx, token, onError, tag);
		const Coll = coll.constructor;
		if (tagName === "!" || tagName === Coll.tagName) {
			coll.tag = Coll.tagName;
			return coll;
		}
		if (tagName) coll.tag = tagName;
		return coll;
	}
	function composeCollection$1(CN$1, ctx, token, props, onError) {
		const tagToken = props.tag;
		const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
		if (token.type === "block-seq") {
			const { anchor, newlineAfterProp: nl } = props;
			const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
			if (lastProp && (!nl || nl.offset < lastProp.offset)) onError(lastProp, "MISSING_CHAR", "Missing newline after block sequence props");
		}
		const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
		if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap$1.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq$1.YAMLSeq.tagName && expType === "seq") return resolveCollection(CN$1, ctx, token, onError, tagName);
		let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
		if (!tag) {
			const kt$1 = ctx.schema.knownTags[tagName];
			if (kt$1 && kt$1.collection === expType) {
				ctx.schema.tags.push(Object.assign({}, kt$1, { default: false }));
				tag = kt$1;
			} else {
				if (kt$1) onError(tagToken, "BAD_COLLECTION_TYPE", `${kt$1.tag} used for ${expType} collection, but expects ${kt$1.collection ?? "scalar"}`, true);
				else onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
				return resolveCollection(CN$1, ctx, token, onError, tagName);
			}
		}
		const coll = resolveCollection(CN$1, ctx, token, onError, tagName, tag);
		const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
		const node = identity$6.isNode(res) ? res : new Scalar$4.Scalar(res);
		node.range = coll.range;
		node.tag = tagName;
		if (tag?.format) node.format = tag.format;
		return node;
	}
	exports.composeCollection = composeCollection$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-scalar.js": ((exports) => {
	var Scalar$3 = require_Scalar();
	function resolveBlockScalar$2(ctx, scalar, onError) {
		const start = scalar.offset;
		const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
		if (!header) return {
			value: "",
			type: null,
			comment: "",
			range: [
				start,
				start,
				start
			]
		};
		const type = header.mode === ">" ? Scalar$3.Scalar.BLOCK_FOLDED : Scalar$3.Scalar.BLOCK_LITERAL;
		const lines = scalar.source ? splitLines(scalar.source) : [];
		let chompStart = lines.length;
		for (let i$1 = lines.length - 1; i$1 >= 0; --i$1) {
			const content = lines[i$1][1];
			if (content === "" || content === "\r") chompStart = i$1;
			else break;
		}
		if (chompStart === 0) {
			const value$1 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
			let end$1 = start + header.length;
			if (scalar.source) end$1 += scalar.source.length;
			return {
				value: value$1,
				type,
				comment: header.comment,
				range: [
					start,
					end$1,
					end$1
				]
			};
		}
		let trimIndent = scalar.indent + header.indent;
		let offset = scalar.offset + header.length;
		let contentStart = 0;
		for (let i$1 = 0; i$1 < chompStart; ++i$1) {
			const [indent$2, content] = lines[i$1];
			if (content === "" || content === "\r") {
				if (header.indent === 0 && indent$2.length > trimIndent) trimIndent = indent$2.length;
			} else {
				if (indent$2.length < trimIndent) onError(offset + indent$2.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator");
				if (header.indent === 0) trimIndent = indent$2.length;
				contentStart = i$1;
				if (trimIndent === 0 && !ctx.atRoot) onError(offset, "BAD_INDENT", "Block scalar values in collections must be indented");
				break;
			}
			offset += indent$2.length + content.length + 1;
		}
		for (let i$1 = lines.length - 1; i$1 >= chompStart; --i$1) if (lines[i$1][0].length > trimIndent) chompStart = i$1 + 1;
		let value = "";
		let sep$1 = "";
		let prevMoreIndented = false;
		for (let i$1 = 0; i$1 < contentStart; ++i$1) value += lines[i$1][0].slice(trimIndent) + "\n";
		for (let i$1 = contentStart; i$1 < chompStart; ++i$1) {
			let [indent$2, content] = lines[i$1];
			offset += indent$2.length + content.length + 1;
			const crlf = content[content.length - 1] === "\r";
			if (crlf) content = content.slice(0, -1);
			/* istanbul ignore if already caught in lexer */
			if (content && indent$2.length < trimIndent) {
				const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
				onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
				indent$2 = "";
			}
			if (type === Scalar$3.Scalar.BLOCK_LITERAL) {
				value += sep$1 + indent$2.slice(trimIndent) + content;
				sep$1 = "\n";
			} else if (indent$2.length > trimIndent || content[0] === "	") {
				if (sep$1 === " ") sep$1 = "\n";
				else if (!prevMoreIndented && sep$1 === "\n") sep$1 = "\n\n";
				value += sep$1 + indent$2.slice(trimIndent) + content;
				sep$1 = "\n";
				prevMoreIndented = true;
			} else if (content === "") if (sep$1 === "\n") value += "\n";
			else sep$1 = "\n";
			else {
				value += sep$1 + content;
				sep$1 = " ";
				prevMoreIndented = false;
			}
		}
		switch (header.chomp) {
			case "-": break;
			case "+":
				for (let i$1 = chompStart; i$1 < lines.length; ++i$1) value += "\n" + lines[i$1][0].slice(trimIndent);
				if (value[value.length - 1] !== "\n") value += "\n";
				break;
			default: value += "\n";
		}
		const end = start + header.length + scalar.source.length;
		return {
			value,
			type,
			comment: header.comment,
			range: [
				start,
				end,
				end
			]
		};
	}
	function parseBlockScalarHeader({ offset, props }, strict, onError) {
		/* istanbul ignore if should not happen */
		if (props[0].type !== "block-scalar-header") {
			onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
			return null;
		}
		const { source } = props[0];
		const mode = source[0];
		let indent$2 = 0;
		let chomp = "";
		let error = -1;
		for (let i$1 = 1; i$1 < source.length; ++i$1) {
			const ch = source[i$1];
			if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
			else {
				const n$1 = Number(ch);
				if (!indent$2 && n$1) indent$2 = n$1;
				else if (error === -1) error = offset + i$1;
			}
		}
		if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
		let hasSpace = false;
		let comment$1 = "";
		let length = source.length;
		for (let i$1 = 1; i$1 < props.length; ++i$1) {
			const token = props[i$1];
			switch (token.type) {
				case "space": hasSpace = true;
				case "newline":
					length += token.source.length;
					break;
				case "comment":
					if (strict && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					length += token.source.length;
					comment$1 = token.source.substring(1);
					break;
				case "error":
					onError(token, "UNEXPECTED_TOKEN", token.message);
					length += token.source.length;
					break;
				default: {
					const message = `Unexpected token in block scalar header: ${token.type}`;
					onError(token, "UNEXPECTED_TOKEN", message);
					const ts = token.source;
					if (ts && typeof ts === "string") length += ts.length;
				}
			}
		}
		return {
			mode,
			indent: indent$2,
			chomp,
			comment: comment$1,
			length
		};
	}
	/** @returns Array of lines split up as `[indent, content]` */
	function splitLines(source) {
		const split = source.split(/\n( *)/);
		const first = split[0];
		const m$1 = first.match(/^( *)/);
		const lines = [m$1?.[1] ? [m$1[1], first.slice(m$1[1].length)] : ["", first]];
		for (let i$1 = 1; i$1 < split.length; i$1 += 2) lines.push([split[i$1], split[i$1 + 1]]);
		return lines;
	}
	exports.resolveBlockScalar = resolveBlockScalar$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js": ((exports) => {
	var Scalar$2 = require_Scalar();
	var resolveEnd$3 = require_resolve_end();
	function resolveFlowScalar$2(scalar, strict, onError) {
		const { offset, type, source, end } = scalar;
		let _type;
		let value;
		const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
		switch (type) {
			case "scalar":
				_type = Scalar$2.Scalar.PLAIN;
				value = plainValue(source, _onError);
				break;
			case "single-quoted-scalar":
				_type = Scalar$2.Scalar.QUOTE_SINGLE;
				value = singleQuotedValue(source, _onError);
				break;
			case "double-quoted-scalar":
				_type = Scalar$2.Scalar.QUOTE_DOUBLE;
				value = doubleQuotedValue(source, _onError);
				break;
			default:
				onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
				return {
					value: "",
					type: null,
					comment: "",
					range: [
						offset,
						offset + source.length,
						offset + source.length
					]
				};
		}
		const valueEnd = offset + source.length;
		const re = resolveEnd$3.resolveEnd(end, valueEnd, strict, onError);
		return {
			value,
			type: _type,
			comment: re.comment,
			range: [
				offset,
				valueEnd,
				re.offset
			]
		};
	}
	function plainValue(source, onError) {
		let badChar = "";
		switch (source[0]) {
			case "	":
				badChar = "a tab character";
				break;
			case ",":
				badChar = "flow indicator character ,";
				break;
			case "%":
				badChar = "directive indicator character %";
				break;
			case "|":
			case ">":
				badChar = `block scalar indicator ${source[0]}`;
				break;
			case "@":
			case "`":
				badChar = `reserved character ${source[0]}`;
				break;
		}
		if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
		return foldLines(source);
	}
	function singleQuotedValue(source, onError) {
		if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
		return foldLines(source.slice(1, -1)).replace(/''/g, "'");
	}
	function foldLines(source) {
		/**
		* The negative lookbehind here and in the `re` RegExp is to
		* prevent causing a polynomial search time in certain cases.
		*
		* The try-catch is for Safari, which doesn't support this yet:
		* https://caniuse.com/js-regexp-lookbehind
		*/
		let first, line;
		try {
			first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
			line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
		} catch {
			first = /(.*?)[ \t]*\r?\n/sy;
			line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
		}
		let match = first.exec(source);
		if (!match) return source;
		let res = match[1];
		let sep$1 = " ";
		let pos = first.lastIndex;
		line.lastIndex = pos;
		while (match = line.exec(source)) {
			if (match[1] === "") if (sep$1 === "\n") res += sep$1;
			else sep$1 = "\n";
			else {
				res += sep$1 + match[1];
				sep$1 = " ";
			}
			pos = line.lastIndex;
		}
		const last = /[ \t]*(.*)/sy;
		last.lastIndex = pos;
		match = last.exec(source);
		return res + sep$1 + (match?.[1] ?? "");
	}
	function doubleQuotedValue(source, onError) {
		let res = "";
		for (let i$1 = 1; i$1 < source.length - 1; ++i$1) {
			const ch = source[i$1];
			if (ch === "\r" && source[i$1 + 1] === "\n") continue;
			if (ch === "\n") {
				const { fold, offset } = foldNewline(source, i$1);
				res += fold;
				i$1 = offset;
			} else if (ch === "\\") {
				let next = source[++i$1];
				const cc = escapeCodes[next];
				if (cc) res += cc;
				else if (next === "\n") {
					next = source[i$1 + 1];
					while (next === " " || next === "	") next = source[++i$1 + 1];
				} else if (next === "\r" && source[i$1 + 1] === "\n") {
					next = source[++i$1 + 1];
					while (next === " " || next === "	") next = source[++i$1 + 1];
				} else if (next === "x" || next === "u" || next === "U") {
					const length = {
						x: 2,
						u: 4,
						U: 8
					}[next];
					res += parseCharCode(source, i$1 + 1, length, onError);
					i$1 += length;
				} else {
					const raw = source.substr(i$1 - 1, 2);
					onError(i$1 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
					res += raw;
				}
			} else if (ch === " " || ch === "	") {
				const wsStart = i$1;
				let next = source[i$1 + 1];
				while (next === " " || next === "	") next = source[++i$1 + 1];
				if (next !== "\n" && !(next === "\r" && source[i$1 + 2] === "\n")) res += i$1 > wsStart ? source.slice(wsStart, i$1 + 1) : ch;
			} else res += ch;
		}
		if (source[source.length - 1] !== "\"" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing \"quote");
		return res;
	}
	/**
	* Fold a single newline into a space, multiple newlines to N - 1 newlines.
	* Presumes `source[offset] === '\n'`
	*/
	function foldNewline(source, offset) {
		let fold = "";
		let ch = source[offset + 1];
		while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
			if (ch === "\r" && source[offset + 2] !== "\n") break;
			if (ch === "\n") fold += "\n";
			offset += 1;
			ch = source[offset + 1];
		}
		if (!fold) fold = " ";
		return {
			fold,
			offset
		};
	}
	const escapeCodes = {
		"0": "\0",
		a: "\x07",
		b: "\b",
		e: "\x1B",
		f: "\f",
		n: "\n",
		r: "\r",
		t: "	",
		v: "\v",
		N: "",
		_: "\xA0",
		L: "\u2028",
		P: "\u2029",
		" ": " ",
		"\"": "\"",
		"/": "/",
		"\\": "\\",
		"	": "	"
	};
	function parseCharCode(source, offset, length, onError) {
		const cc = source.substr(offset, length);
		const code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
		if (isNaN(code)) {
			const raw = source.substr(offset - 2, length + 2);
			onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
			return raw;
		}
		return String.fromCodePoint(code);
	}
	exports.resolveFlowScalar = resolveFlowScalar$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-scalar.js": ((exports) => {
	var identity$5 = require_identity();
	var Scalar$1 = require_Scalar();
	var resolveBlockScalar$1 = require_resolve_block_scalar();
	var resolveFlowScalar$1 = require_resolve_flow_scalar();
	function composeScalar$1(ctx, token, tagToken, onError) {
		const { value, type, comment: comment$1, range } = token.type === "block-scalar" ? resolveBlockScalar$1.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar$1.resolveFlowScalar(token, ctx.options.strict, onError);
		const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
		let tag;
		if (ctx.options.stringKeys && ctx.atKey) tag = ctx.schema[identity$5.SCALAR];
		else if (tagName) tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
		else if (token.type === "scalar") tag = findScalarTagByTest(ctx, value, token, onError);
		else tag = ctx.schema[identity$5.SCALAR];
		let scalar;
		try {
			const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
			scalar = identity$5.isScalar(res) ? res : new Scalar$1.Scalar(res);
		} catch (error) {
			const msg = error instanceof Error ? error.message : String(error);
			onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
			scalar = new Scalar$1.Scalar(value);
		}
		scalar.range = range;
		scalar.source = value;
		if (type) scalar.type = type;
		if (tagName) scalar.tag = tagName;
		if (tag.format) scalar.format = tag.format;
		if (comment$1) scalar.comment = comment$1;
		return scalar;
	}
	function findScalarTagByName(schema$6, value, tagName, tagToken, onError) {
		if (tagName === "!") return schema$6[identity$5.SCALAR];
		const matchWithTest = [];
		for (const tag of schema$6.tags) if (!tag.collection && tag.tag === tagName) if (tag.default && tag.test) matchWithTest.push(tag);
		else return tag;
		for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
		const kt$1 = schema$6.knownTags[tagName];
		if (kt$1 && !kt$1.collection) {
			schema$6.tags.push(Object.assign({}, kt$1, {
				default: false,
				test: void 0
			}));
			return kt$1;
		}
		onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
		return schema$6[identity$5.SCALAR];
	}
	function findScalarTagByTest({ atKey, directives: directives$2, schema: schema$6 }, value, token, onError) {
		const tag = schema$6.tags.find((tag$1) => (tag$1.default === true || atKey && tag$1.default === "key") && tag$1.test?.test(value)) || schema$6[identity$5.SCALAR];
		if (schema$6.compat) {
			const compat = schema$6.compat.find((tag$1) => tag$1.default && tag$1.test?.test(value)) ?? schema$6[identity$5.SCALAR];
			if (tag.tag !== compat.tag) {
				const ts = directives$2.tagString(tag.tag);
				const cs = directives$2.tagString(compat.tag);
				const msg = `Value may be parsed as either ${ts} or ${cs}`;
				onError(token, "TAG_RESOLVE_FAILED", msg, true);
			}
		}
		return tag;
	}
	exports.composeScalar = composeScalar$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js": ((exports) => {
	function emptyScalarPosition(offset, before, pos) {
		if (before) {
			pos ?? (pos = before.length);
			for (let i$1 = pos - 1; i$1 >= 0; --i$1) {
				let st = before[i$1];
				switch (st.type) {
					case "space":
					case "comment":
					case "newline":
						offset -= st.source.length;
						continue;
				}
				st = before[++i$1];
				while (st?.type === "space") {
					offset += st.source.length;
					st = before[++i$1];
				}
				break;
			}
		}
		return offset;
	}
	exports.emptyScalarPosition = emptyScalarPosition;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-node.js": ((exports) => {
	var Alias$1 = require_Alias();
	var identity$4 = require_identity();
	var composeCollection = require_compose_collection();
	var composeScalar = require_compose_scalar();
	var resolveEnd$2 = require_resolve_end();
	var utilEmptyScalarPosition = require_util_empty_scalar_position();
	const CN = {
		composeNode: composeNode$1,
		composeEmptyNode
	};
	function composeNode$1(ctx, token, props, onError) {
		const atKey = ctx.atKey;
		const { spaceBefore, comment: comment$1, anchor, tag } = props;
		let node;
		let isSrcToken = true;
		switch (token.type) {
			case "alias":
				node = composeAlias(ctx, token, onError);
				if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
				break;
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar":
			case "block-scalar":
				node = composeScalar.composeScalar(ctx, token, tag, onError);
				if (anchor) node.anchor = anchor.source.substring(1);
				break;
			case "block-map":
			case "block-seq":
			case "flow-collection":
				node = composeCollection.composeCollection(CN, ctx, token, props, onError);
				if (anchor) node.anchor = anchor.source.substring(1);
				break;
			default: {
				const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
				onError(token, "UNEXPECTED_TOKEN", message);
				node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
				isSrcToken = false;
			}
		}
		if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
		if (atKey && ctx.options.stringKeys && (!identity$4.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) onError(tag ?? token, "NON_STRING_KEY", "With stringKeys, all keys must be strings");
		if (spaceBefore) node.spaceBefore = true;
		if (comment$1) if (token.type === "scalar" && token.source === "") node.comment = comment$1;
		else node.commentBefore = comment$1;
		if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
		return node;
	}
	function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment$1, anchor, tag, end }, onError) {
		const token = {
			type: "scalar",
			offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
			indent: -1,
			source: ""
		};
		const node = composeScalar.composeScalar(ctx, token, tag, onError);
		if (anchor) {
			node.anchor = anchor.source.substring(1);
			if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
		}
		if (spaceBefore) node.spaceBefore = true;
		if (comment$1) {
			node.comment = comment$1;
			node.range[2] = end;
		}
		return node;
	}
	function composeAlias({ options }, { offset, source, end }, onError) {
		const alias = new Alias$1.Alias(source.substring(1));
		if (alias.source === "") onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
		if (alias.source.endsWith(":")) onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
		const valueEnd = offset + source.length;
		const re = resolveEnd$2.resolveEnd(end, valueEnd, options.strict, onError);
		alias.range = [
			offset,
			valueEnd,
			re.offset
		];
		if (re.comment) alias.comment = re.comment;
		return alias;
	}
	exports.composeEmptyNode = composeEmptyNode;
	exports.composeNode = composeNode$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-doc.js": ((exports) => {
	var Document$4 = require_Document();
	var composeNode = require_compose_node();
	var resolveEnd$1 = require_resolve_end();
	var resolveProps = require_resolve_props();
	function composeDoc$1(options, directives$2, { offset, start, value, end }, onError) {
		const opts = Object.assign({ _directives: directives$2 }, options);
		const doc = new Document$4.Document(void 0, opts);
		const ctx = {
			atKey: false,
			atRoot: true,
			directives: doc.directives,
			options: doc.options,
			schema: doc.schema
		};
		const props = resolveProps.resolveProps(start, {
			indicator: "doc-start",
			next: value ?? end?.[0],
			offset,
			onError,
			parentIndent: 0,
			startOnNewline: true
		});
		if (props.found) {
			doc.directives.docStart = true;
			if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
		}
		doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
		const contentEnd = doc.contents.range[2];
		const re = resolveEnd$1.resolveEnd(end, contentEnd, false, onError);
		if (re.comment) doc.comment = re.comment;
		doc.range = [
			offset,
			contentEnd,
			re.offset
		];
		return doc;
	}
	exports.composeDoc = composeDoc$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/composer.js
var require_composer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/composer.js": ((exports) => {
	var node_process$1 = __require("process");
	var directives = require_directives();
	var Document$3 = require_Document();
	var errors$3 = require_errors();
	var identity$3 = require_identity();
	var composeDoc = require_compose_doc();
	var resolveEnd = require_resolve_end();
	function getErrorPos(src) {
		if (typeof src === "number") return [src, src + 1];
		if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
		const { offset, source } = src;
		return [offset, offset + (typeof source === "string" ? source.length : 1)];
	}
	function parsePrelude(prelude) {
		let comment$1 = "";
		let atComment = false;
		let afterEmptyLine = false;
		for (let i$1 = 0; i$1 < prelude.length; ++i$1) {
			const source = prelude[i$1];
			switch (source[0]) {
				case "#":
					comment$1 += (comment$1 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
					atComment = true;
					afterEmptyLine = false;
					break;
				case "%":
					if (prelude[i$1 + 1]?.[0] !== "#") i$1 += 1;
					atComment = false;
					break;
				default:
					if (!atComment) afterEmptyLine = true;
					atComment = false;
			}
		}
		return {
			comment: comment$1,
			afterEmptyLine
		};
	}
	/**
	* Compose a stream of CST nodes into a stream of YAML Documents.
	*
	* ```ts
	* import { Composer, Parser } from 'yaml'
	*
	* const src: string = ...
	* const tokens = new Parser().parse(src)
	* const docs = new Composer().compose(tokens)
	* ```
	*/
	var Composer = class {
		constructor(options = {}) {
			this.doc = null;
			this.atDirectives = false;
			this.prelude = [];
			this.errors = [];
			this.warnings = [];
			this.onError = (source, code, message, warning) => {
				const pos = getErrorPos(source);
				if (warning) this.warnings.push(new errors$3.YAMLWarning(pos, code, message));
				else this.errors.push(new errors$3.YAMLParseError(pos, code, message));
			};
			this.directives = new directives.Directives({ version: options.version || "1.2" });
			this.options = options;
		}
		decorate(doc, afterDoc) {
			const { comment: comment$1, afterEmptyLine } = parsePrelude(this.prelude);
			if (comment$1) {
				const dc = doc.contents;
				if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment$1}` : comment$1;
				else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment$1;
				else if (identity$3.isCollection(dc) && !dc.flow && dc.items.length > 0) {
					let it = dc.items[0];
					if (identity$3.isPair(it)) it = it.key;
					const cb = it.commentBefore;
					it.commentBefore = cb ? `${comment$1}\n${cb}` : comment$1;
				} else {
					const cb = dc.commentBefore;
					dc.commentBefore = cb ? `${comment$1}\n${cb}` : comment$1;
				}
			}
			if (afterDoc) {
				Array.prototype.push.apply(doc.errors, this.errors);
				Array.prototype.push.apply(doc.warnings, this.warnings);
			} else {
				doc.errors = this.errors;
				doc.warnings = this.warnings;
			}
			this.prelude = [];
			this.errors = [];
			this.warnings = [];
		}
		/**
		* Current stream status information.
		*
		* Mostly useful at the end of input for an empty stream.
		*/
		streamInfo() {
			return {
				comment: parsePrelude(this.prelude).comment,
				directives: this.directives,
				errors: this.errors,
				warnings: this.warnings
			};
		}
		/**
		* Compose tokens into documents.
		*
		* @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
		* @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
		*/
		*compose(tokens, forceDoc = false, endOffset = -1) {
			for (const token of tokens) yield* this.next(token);
			yield* this.end(forceDoc, endOffset);
		}
		/** Advance the composer by one CST token. */
		*next(token) {
			if (node_process$1.env.LOG_STREAM) console.dir(token, { depth: null });
			switch (token.type) {
				case "directive":
					this.directives.add(token.source, (offset, message, warning) => {
						const pos = getErrorPos(token);
						pos[0] += offset;
						this.onError(pos, "BAD_DIRECTIVE", message, warning);
					});
					this.prelude.push(token.source);
					this.atDirectives = true;
					break;
				case "document": {
					const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
					if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
					this.decorate(doc, false);
					if (this.doc) yield this.doc;
					this.doc = doc;
					this.atDirectives = false;
					break;
				}
				case "byte-order-mark":
				case "space": break;
				case "comment":
				case "newline":
					this.prelude.push(token.source);
					break;
				case "error": {
					const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
					const error = new errors$3.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
					if (this.atDirectives || !this.doc) this.errors.push(error);
					else this.doc.errors.push(error);
					break;
				}
				case "doc-end": {
					if (!this.doc) {
						this.errors.push(new errors$3.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", "Unexpected doc-end without preceding document"));
						break;
					}
					this.doc.directives.docEnd = true;
					const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
					this.decorate(this.doc, true);
					if (end.comment) {
						const dc = this.doc.comment;
						this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
					}
					this.doc.range[2] = end.offset;
					break;
				}
				default: this.errors.push(new errors$3.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
			}
		}
		/**
		* Call at end of input to yield any remaining document.
		*
		* @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
		* @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
		*/
		*end(forceDoc = false, endOffset = -1) {
			if (this.doc) {
				this.decorate(this.doc, true);
				yield this.doc;
				this.doc = null;
			} else if (forceDoc) {
				const opts = Object.assign({ _directives: this.directives }, this.options);
				const doc = new Document$3.Document(void 0, opts);
				if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
				doc.range = [
					0,
					endOffset,
					endOffset
				];
				this.decorate(doc, false);
				yield doc;
			}
		}
	};
	exports.Composer = Composer;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-scalar.js": ((exports) => {
	var resolveBlockScalar = require_resolve_block_scalar();
	var resolveFlowScalar = require_resolve_flow_scalar();
	var errors$2 = require_errors();
	var stringifyString = require_stringifyString();
	function resolveAsScalar(token, strict = true, onError) {
		if (token) {
			const _onError = (pos, code, message) => {
				const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
				if (onError) onError(offset, code, message);
				else throw new errors$2.YAMLParseError([offset, offset + 1], code, message);
			};
			switch (token.type) {
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
				case "block-scalar": return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
			}
		}
		return null;
	}
	/**
	* Create a new scalar token with `value`
	*
	* Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
	* as this function does not support any schema operations and won't check for such conflicts.
	*
	* @param value The string representation of the value, which will have its content properly indented.
	* @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
	* @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
	* @param context.indent The indent level of the token.
	* @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
	* @param context.offset The offset position of the token.
	* @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
	*/
	function createScalarToken(value, context) {
		const { implicitKey = false, indent: indent$2, inFlow = false, offset = -1, type = "PLAIN" } = context;
		const source = stringifyString.stringifyString({
			type,
			value
		}, {
			implicitKey,
			indent: indent$2 > 0 ? " ".repeat(indent$2) : "",
			inFlow,
			options: {
				blockQuote: true,
				lineWidth: -1
			}
		});
		const end = context.end ?? [{
			type: "newline",
			offset: -1,
			indent: indent$2,
			source: "\n"
		}];
		switch (source[0]) {
			case "|":
			case ">": {
				const he$1 = source.indexOf("\n");
				const head = source.substring(0, he$1);
				const body = source.substring(he$1 + 1) + "\n";
				const props = [{
					type: "block-scalar-header",
					offset,
					indent: indent$2,
					source: head
				}];
				if (!addEndtoBlockProps(props, end)) props.push({
					type: "newline",
					offset: -1,
					indent: indent$2,
					source: "\n"
				});
				return {
					type: "block-scalar",
					offset,
					indent: indent$2,
					props,
					source: body
				};
			}
			case "\"": return {
				type: "double-quoted-scalar",
				offset,
				indent: indent$2,
				source,
				end
			};
			case "'": return {
				type: "single-quoted-scalar",
				offset,
				indent: indent$2,
				source,
				end
			};
			default: return {
				type: "scalar",
				offset,
				indent: indent$2,
				source,
				end
			};
		}
	}
	/**
	* Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
	*
	* Best efforts are made to retain any comments previously associated with the `token`,
	* though all contents within a collection's `items` will be overwritten.
	*
	* Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
	* as this function does not support any schema operations and won't check for such conflicts.
	*
	* @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
	* @param value The string representation of the value, which will have its content properly indented.
	* @param context.afterKey In most cases, values after a key should have an additional level of indentation.
	* @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
	* @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
	* @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
	*/
	function setScalarValue(token, value, context = {}) {
		let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
		let indent$2 = "indent" in token ? token.indent : null;
		if (afterKey && typeof indent$2 === "number") indent$2 += 2;
		if (!type) switch (token.type) {
			case "single-quoted-scalar":
				type = "QUOTE_SINGLE";
				break;
			case "double-quoted-scalar":
				type = "QUOTE_DOUBLE";
				break;
			case "block-scalar": {
				const header = token.props[0];
				if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
				type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
				break;
			}
			default: type = "PLAIN";
		}
		const source = stringifyString.stringifyString({
			type,
			value
		}, {
			implicitKey: implicitKey || indent$2 === null,
			indent: indent$2 !== null && indent$2 > 0 ? " ".repeat(indent$2) : "",
			inFlow,
			options: {
				blockQuote: true,
				lineWidth: -1
			}
		});
		switch (source[0]) {
			case "|":
			case ">":
				setBlockScalarValue(token, source);
				break;
			case "\"":
				setFlowScalarValue(token, source, "double-quoted-scalar");
				break;
			case "'":
				setFlowScalarValue(token, source, "single-quoted-scalar");
				break;
			default: setFlowScalarValue(token, source, "scalar");
		}
	}
	function setBlockScalarValue(token, source) {
		const he$1 = source.indexOf("\n");
		const head = source.substring(0, he$1);
		const body = source.substring(he$1 + 1) + "\n";
		if (token.type === "block-scalar") {
			const header = token.props[0];
			if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
			header.source = head;
			token.source = body;
		} else {
			const { offset } = token;
			const indent$2 = "indent" in token ? token.indent : -1;
			const props = [{
				type: "block-scalar-header",
				offset,
				indent: indent$2,
				source: head
			}];
			if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0)) props.push({
				type: "newline",
				offset: -1,
				indent: indent$2,
				source: "\n"
			});
			for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
			Object.assign(token, {
				type: "block-scalar",
				indent: indent$2,
				props,
				source: body
			});
		}
	}
	/** @returns `true` if last token is a newline */
	function addEndtoBlockProps(props, end) {
		if (end) for (const st of end) switch (st.type) {
			case "space":
			case "comment":
				props.push(st);
				break;
			case "newline":
				props.push(st);
				return true;
		}
		return false;
	}
	function setFlowScalarValue(token, source, type) {
		switch (token.type) {
			case "scalar":
			case "double-quoted-scalar":
			case "single-quoted-scalar":
				token.type = type;
				token.source = source;
				break;
			case "block-scalar": {
				const end = token.props.slice(1);
				let oa = source.length;
				if (token.props[0].type === "block-scalar-header") oa -= token.props[0].source.length;
				for (const tok of end) tok.offset += oa;
				delete token.props;
				Object.assign(token, {
					type,
					source,
					end
				});
				break;
			}
			case "block-map":
			case "block-seq": {
				const nl = {
					type: "newline",
					offset: token.offset + source.length,
					indent: token.indent,
					source: "\n"
				};
				delete token.items;
				Object.assign(token, {
					type,
					source,
					end: [nl]
				});
				break;
			}
			default: {
				const indent$2 = "indent" in token ? token.indent : -1;
				const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
				for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
				Object.assign(token, {
					type,
					indent: indent$2,
					source,
					end
				});
			}
		}
	}
	exports.createScalarToken = createScalarToken;
	exports.resolveAsScalar = resolveAsScalar;
	exports.setScalarValue = setScalarValue;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-stringify.js": ((exports) => {
	/**
	* Stringify a CST document, token, or collection item
	*
	* Fair warning: This applies no validation whatsoever, and
	* simply concatenates the sources in their logical order.
	*/
	const stringify$1 = (cst$3) => "type" in cst$3 ? stringifyToken(cst$3) : stringifyItem(cst$3);
	function stringifyToken(token) {
		switch (token.type) {
			case "block-scalar": {
				let res = "";
				for (const tok of token.props) res += stringifyToken(tok);
				return res + token.source;
			}
			case "block-map":
			case "block-seq": {
				let res = "";
				for (const item of token.items) res += stringifyItem(item);
				return res;
			}
			case "flow-collection": {
				let res = token.start.source;
				for (const item of token.items) res += stringifyItem(item);
				for (const st of token.end) res += st.source;
				return res;
			}
			case "document": {
				let res = stringifyItem(token);
				if (token.end) for (const st of token.end) res += st.source;
				return res;
			}
			default: {
				let res = token.source;
				if ("end" in token && token.end) for (const st of token.end) res += st.source;
				return res;
			}
		}
	}
	function stringifyItem({ start, key, sep: sep$1, value }) {
		let res = "";
		for (const st of start) res += st.source;
		if (key) res += stringifyToken(key);
		if (sep$1) for (const st of sep$1) res += st.source;
		if (value) res += stringifyToken(value);
		return res;
	}
	exports.stringify = stringify$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-visit.js": ((exports) => {
	const BREAK = Symbol("break visit");
	const SKIP = Symbol("skip children");
	const REMOVE = Symbol("remove item");
	/**
	* Apply a visitor to a CST document or item.
	*
	* Walks through the tree (depth-first) starting from the root, calling a
	* `visitor` function with two arguments when entering each item:
	*   - `item`: The current item, which included the following members:
	*     - `start: SourceToken[]`  Source tokens before the key or value,
	*       possibly including its anchor or tag.
	*     - `key?: Token | null`  Set for pair values. May then be `null`, if
	*       the key before the `:` separator is empty.
	*     - `sep?: SourceToken[]`  Source tokens between the key and the value,
	*       which should include the `:` map value indicator if `value` is set.
	*     - `value?: Token`  The value of a sequence item, or of a map pair.
	*   - `path`: The steps from the root to the current node, as an array of
	*     `['key' | 'value', number]` tuples.
	*
	* The return value of the visitor may be used to control the traversal:
	*   - `undefined` (default): Do nothing and continue
	*   - `visit.SKIP`: Do not visit the children of this token, continue with
	*      next sibling
	*   - `visit.BREAK`: Terminate traversal completely
	*   - `visit.REMOVE`: Remove the current item, then continue with the next one
	*   - `number`: Set the index of the next step. This is useful especially if
	*     the index of the current token has changed.
	*   - `function`: Define the next visitor for this item. After the original
	*     visitor is called on item entry, next visitors are called after handling
	*     a non-empty `key` and when exiting the item.
	*/
	function visit$1(cst$3, visitor) {
		if ("type" in cst$3 && cst$3.type === "document") cst$3 = {
			start: cst$3.start,
			value: cst$3.value
		};
		_visit(Object.freeze([]), cst$3, visitor);
	}
	/** Terminate visit traversal completely */
	visit$1.BREAK = BREAK;
	/** Do not visit the children of the current item */
	visit$1.SKIP = SKIP;
	/** Remove the current item */
	visit$1.REMOVE = REMOVE;
	/** Find the item at `path` from `cst` as the root */
	visit$1.itemAtPath = (cst$3, path$2) => {
		let item = cst$3;
		for (const [field, index] of path$2) {
			const tok = item?.[field];
			if (tok && "items" in tok) item = tok.items[index];
			else return void 0;
		}
		return item;
	};
	/**
	* Get the immediate parent collection of the item at `path` from `cst` as the root.
	*
	* Throws an error if the collection is not found, which should never happen if the item itself exists.
	*/
	visit$1.parentCollection = (cst$3, path$2) => {
		const parent = visit$1.itemAtPath(cst$3, path$2.slice(0, -1));
		const field = path$2[path$2.length - 1][0];
		const coll = parent?.[field];
		if (coll && "items" in coll) return coll;
		throw new Error("Parent collection not found");
	};
	function _visit(path$2, item, visitor) {
		let ctrl = visitor(item, path$2);
		if (typeof ctrl === "symbol") return ctrl;
		for (const field of ["key", "value"]) {
			const token = item[field];
			if (token && "items" in token) {
				for (let i$1 = 0; i$1 < token.items.length; ++i$1) {
					const ci = _visit(Object.freeze(path$2.concat([[field, i$1]])), token.items[i$1], visitor);
					if (typeof ci === "number") i$1 = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						token.items.splice(i$1, 1);
						i$1 -= 1;
					}
				}
				if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path$2);
			}
		}
		return typeof ctrl === "function" ? ctrl(item, path$2) : ctrl;
	}
	exports.visit = visit$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst.js
var require_cst = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst.js": ((exports) => {
	var cstScalar = require_cst_scalar();
	var cstStringify = require_cst_stringify();
	var cstVisit = require_cst_visit();
	/** The byte order mark */
	const BOM = "";
	/** Start of doc-mode */
	const DOCUMENT = "";
	/** Unexpected end of flow-mode */
	const FLOW_END = "";
	/** Next token is a scalar value */
	const SCALAR = "";
	/** @returns `true` if `token` is a flow or block collection */
	const isCollection = (token) => !!token && "items" in token;
	/** @returns `true` if `token` is a flow or block scalar; not an alias */
	const isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
	/* istanbul ignore next */
	/** Get a printable representation of a lexer token */
	function prettyToken(token) {
		switch (token) {
			case BOM: return "<BOM>";
			case DOCUMENT: return "<DOC>";
			case FLOW_END: return "<FLOW_END>";
			case SCALAR: return "<SCALAR>";
			default: return JSON.stringify(token);
		}
	}
	/** Identify the type of a lexer token. May return `null` for unknown tokens. */
	function tokenType(source) {
		switch (source) {
			case BOM: return "byte-order-mark";
			case DOCUMENT: return "doc-mode";
			case FLOW_END: return "flow-error-end";
			case SCALAR: return "scalar";
			case "---": return "doc-start";
			case "...": return "doc-end";
			case "":
			case "\n":
			case "\r\n": return "newline";
			case "-": return "seq-item-ind";
			case "?": return "explicit-key-ind";
			case ":": return "map-value-ind";
			case "{": return "flow-map-start";
			case "}": return "flow-map-end";
			case "[": return "flow-seq-start";
			case "]": return "flow-seq-end";
			case ",": return "comma";
		}
		switch (source[0]) {
			case " ":
			case "	": return "space";
			case "#": return "comment";
			case "%": return "directive-line";
			case "*": return "alias";
			case "&": return "anchor";
			case "!": return "tag";
			case "'": return "single-quoted-scalar";
			case "\"": return "double-quoted-scalar";
			case "|":
			case ">": return "block-scalar-header";
		}
		return null;
	}
	exports.createScalarToken = cstScalar.createScalarToken;
	exports.resolveAsScalar = cstScalar.resolveAsScalar;
	exports.setScalarValue = cstScalar.setScalarValue;
	exports.stringify = cstStringify.stringify;
	exports.visit = cstVisit.visit;
	exports.BOM = BOM;
	exports.DOCUMENT = DOCUMENT;
	exports.FLOW_END = FLOW_END;
	exports.SCALAR = SCALAR;
	exports.isCollection = isCollection;
	exports.isScalar = isScalar;
	exports.prettyToken = prettyToken;
	exports.tokenType = tokenType;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/lexer.js
var require_lexer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/lexer.js": ((exports) => {
	var cst$2 = require_cst();
	function isEmpty(ch) {
		switch (ch) {
			case void 0:
			case " ":
			case "\n":
			case "\r":
			case "	": return true;
			default: return false;
		}
	}
	const hexDigits = /* @__PURE__ */ new Set("0123456789ABCDEFabcdef");
	const tagChars = /* @__PURE__ */ new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
	const flowIndicatorChars = /* @__PURE__ */ new Set(",[]{}");
	const invalidAnchorChars = /* @__PURE__ */ new Set(" ,[]{}\n\r	");
	const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
	/**
	* Splits an input string into lexical tokens, i.e. smaller strings that are
	* easily identifiable by `tokens.tokenType()`.
	*
	* Lexing starts always in a "stream" context. Incomplete input may be buffered
	* until a complete token can be emitted.
	*
	* In addition to slices of the original input, the following control characters
	* may also be emitted:
	*
	* - `\x02` (Start of Text): A document starts with the next token
	* - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
	* - `\x1f` (Unit Separator): Next token is a scalar value
	* - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
	*/
	var Lexer = class {
		constructor() {
			/**
			* Flag indicating whether the end of the current buffer marks the end of
			* all input
			*/
			this.atEnd = false;
			/**
			* Explicit indent set in block scalar header, as an offset from the current
			* minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
			* explicitly set.
			*/
			this.blockScalarIndent = -1;
			/**
			* Block scalars that include a + (keep) chomping indicator in their header
			* include trailing empty lines, which are otherwise excluded from the
			* scalar's contents.
			*/
			this.blockScalarKeep = false;
			/** Current input */
			this.buffer = "";
			/**
			* Flag noting whether the map value indicator : can immediately follow this
			* node within a flow context.
			*/
			this.flowKey = false;
			/** Count of surrounding flow collection levels. */
			this.flowLevel = 0;
			/**
			* Minimum level of indentation required for next lines to be parsed as a
			* part of the current scalar value.
			*/
			this.indentNext = 0;
			/** Indentation level of the current line. */
			this.indentValue = 0;
			/** Position of the next \n character. */
			this.lineEndPos = null;
			/** Stores the state of the lexer if reaching the end of incpomplete input */
			this.next = null;
			/** A pointer to `buffer`; the current position of the lexer. */
			this.pos = 0;
		}
		/**
		* Generate YAML tokens from the `source` string. If `incomplete`,
		* a part of the last line may be left as a buffer for the next call.
		*
		* @returns A generator of lexical tokens
		*/
		*lex(source, incomplete = false) {
			if (source) {
				if (typeof source !== "string") throw TypeError("source is not a string");
				this.buffer = this.buffer ? this.buffer + source : source;
				this.lineEndPos = null;
			}
			this.atEnd = !incomplete;
			let next = this.next ?? "stream";
			while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
		}
		atLineEnd() {
			let i$1 = this.pos;
			let ch = this.buffer[i$1];
			while (ch === " " || ch === "	") ch = this.buffer[++i$1];
			if (!ch || ch === "#" || ch === "\n") return true;
			if (ch === "\r") return this.buffer[i$1 + 1] === "\n";
			return false;
		}
		charAt(n$1) {
			return this.buffer[this.pos + n$1];
		}
		continueScalar(offset) {
			let ch = this.buffer[offset];
			if (this.indentNext > 0) {
				let indent$2 = 0;
				while (ch === " ") ch = this.buffer[++indent$2 + offset];
				if (ch === "\r") {
					const next = this.buffer[indent$2 + offset + 1];
					if (next === "\n" || !next && !this.atEnd) return offset + indent$2 + 1;
				}
				return ch === "\n" || indent$2 >= this.indentNext || !ch && !this.atEnd ? offset + indent$2 : -1;
			}
			if (ch === "-" || ch === ".") {
				const dt$1 = this.buffer.substr(offset, 3);
				if ((dt$1 === "---" || dt$1 === "...") && isEmpty(this.buffer[offset + 3])) return -1;
			}
			return offset;
		}
		getLine() {
			let end = this.lineEndPos;
			if (typeof end !== "number" || end !== -1 && end < this.pos) {
				end = this.buffer.indexOf("\n", this.pos);
				this.lineEndPos = end;
			}
			if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
			if (this.buffer[end - 1] === "\r") end -= 1;
			return this.buffer.substring(this.pos, end);
		}
		hasChars(n$1) {
			return this.pos + n$1 <= this.buffer.length;
		}
		setNext(state) {
			this.buffer = this.buffer.substring(this.pos);
			this.pos = 0;
			this.lineEndPos = null;
			this.next = state;
			return null;
		}
		peek(n$1) {
			return this.buffer.substr(this.pos, n$1);
		}
		*parseNext(next) {
			switch (next) {
				case "stream": return yield* this.parseStream();
				case "line-start": return yield* this.parseLineStart();
				case "block-start": return yield* this.parseBlockStart();
				case "doc": return yield* this.parseDocument();
				case "flow": return yield* this.parseFlowCollection();
				case "quoted-scalar": return yield* this.parseQuotedScalar();
				case "block-scalar": return yield* this.parseBlockScalar();
				case "plain-scalar": return yield* this.parsePlainScalar();
			}
		}
		*parseStream() {
			let line = this.getLine();
			if (line === null) return this.setNext("stream");
			if (line[0] === cst$2.BOM) {
				yield* this.pushCount(1);
				line = line.substring(1);
			}
			if (line[0] === "%") {
				let dirEnd = line.length;
				let cs = line.indexOf("#");
				while (cs !== -1) {
					const ch = line[cs - 1];
					if (ch === " " || ch === "	") {
						dirEnd = cs - 1;
						break;
					} else cs = line.indexOf("#", cs + 1);
				}
				while (true) {
					const ch = line[dirEnd - 1];
					if (ch === " " || ch === "	") dirEnd -= 1;
					else break;
				}
				const n$1 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
				yield* this.pushCount(line.length - n$1);
				this.pushNewline();
				return "stream";
			}
			if (this.atLineEnd()) {
				const sp = yield* this.pushSpaces(true);
				yield* this.pushCount(line.length - sp);
				yield* this.pushNewline();
				return "stream";
			}
			yield cst$2.DOCUMENT;
			return yield* this.parseLineStart();
		}
		*parseLineStart() {
			const ch = this.charAt(0);
			if (!ch && !this.atEnd) return this.setNext("line-start");
			if (ch === "-" || ch === ".") {
				if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
				const s = this.peek(3);
				if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
					yield* this.pushCount(3);
					this.indentValue = 0;
					this.indentNext = 0;
					return s === "---" ? "doc" : "stream";
				}
			}
			this.indentValue = yield* this.pushSpaces(false);
			if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
			return yield* this.parseBlockStart();
		}
		*parseBlockStart() {
			const [ch0, ch1] = this.peek(2);
			if (!ch1 && !this.atEnd) return this.setNext("block-start");
			if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
				const n$1 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
				this.indentNext = this.indentValue + 1;
				this.indentValue += n$1;
				return yield* this.parseBlockStart();
			}
			return "doc";
		}
		*parseDocument() {
			yield* this.pushSpaces(true);
			const line = this.getLine();
			if (line === null) return this.setNext("doc");
			let n$1 = yield* this.pushIndicators();
			switch (line[n$1]) {
				case "#": yield* this.pushCount(line.length - n$1);
				case void 0:
					yield* this.pushNewline();
					return yield* this.parseLineStart();
				case "{":
				case "[":
					yield* this.pushCount(1);
					this.flowKey = false;
					this.flowLevel = 1;
					return "flow";
				case "}":
				case "]":
					yield* this.pushCount(1);
					return "doc";
				case "*":
					yield* this.pushUntil(isNotAnchorChar);
					return "doc";
				case "\"":
				case "'": return yield* this.parseQuotedScalar();
				case "|":
				case ">":
					n$1 += yield* this.parseBlockScalarHeader();
					n$1 += yield* this.pushSpaces(true);
					yield* this.pushCount(line.length - n$1);
					yield* this.pushNewline();
					return yield* this.parseBlockScalar();
				default: return yield* this.parsePlainScalar();
			}
		}
		*parseFlowCollection() {
			let nl, sp;
			let indent$2 = -1;
			do {
				nl = yield* this.pushNewline();
				if (nl > 0) {
					sp = yield* this.pushSpaces(false);
					this.indentValue = indent$2 = sp;
				} else sp = 0;
				sp += yield* this.pushSpaces(true);
			} while (nl + sp > 0);
			const line = this.getLine();
			if (line === null) return this.setNext("flow");
			if (indent$2 !== -1 && indent$2 < this.indentNext && line[0] !== "#" || indent$2 === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
				if (!(indent$2 === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}"))) {
					this.flowLevel = 0;
					yield cst$2.FLOW_END;
					return yield* this.parseLineStart();
				}
			}
			let n$1 = 0;
			while (line[n$1] === ",") {
				n$1 += yield* this.pushCount(1);
				n$1 += yield* this.pushSpaces(true);
				this.flowKey = false;
			}
			n$1 += yield* this.pushIndicators();
			switch (line[n$1]) {
				case void 0: return "flow";
				case "#":
					yield* this.pushCount(line.length - n$1);
					return "flow";
				case "{":
				case "[":
					yield* this.pushCount(1);
					this.flowKey = false;
					this.flowLevel += 1;
					return "flow";
				case "}":
				case "]":
					yield* this.pushCount(1);
					this.flowKey = true;
					this.flowLevel -= 1;
					return this.flowLevel ? "flow" : "doc";
				case "*":
					yield* this.pushUntil(isNotAnchorChar);
					return "flow";
				case "\"":
				case "'":
					this.flowKey = true;
					return yield* this.parseQuotedScalar();
				case ":": {
					const next = this.charAt(1);
					if (this.flowKey || isEmpty(next) || next === ",") {
						this.flowKey = false;
						yield* this.pushCount(1);
						yield* this.pushSpaces(true);
						return "flow";
					}
				}
				default:
					this.flowKey = false;
					return yield* this.parsePlainScalar();
			}
		}
		*parseQuotedScalar() {
			const quote$1 = this.charAt(0);
			let end = this.buffer.indexOf(quote$1, this.pos + 1);
			if (quote$1 === "'") while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
			else while (end !== -1) {
				let n$1 = 0;
				while (this.buffer[end - 1 - n$1] === "\\") n$1 += 1;
				if (n$1 % 2 === 0) break;
				end = this.buffer.indexOf("\"", end + 1);
			}
			const qb = this.buffer.substring(0, end);
			let nl = qb.indexOf("\n", this.pos);
			if (nl !== -1) {
				while (nl !== -1) {
					const cs = this.continueScalar(nl + 1);
					if (cs === -1) break;
					nl = qb.indexOf("\n", cs);
				}
				if (nl !== -1) end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
			}
			if (end === -1) {
				if (!this.atEnd) return this.setNext("quoted-scalar");
				end = this.buffer.length;
			}
			yield* this.pushToIndex(end + 1, false);
			return this.flowLevel ? "flow" : "doc";
		}
		*parseBlockScalarHeader() {
			this.blockScalarIndent = -1;
			this.blockScalarKeep = false;
			let i$1 = this.pos;
			while (true) {
				const ch = this.buffer[++i$1];
				if (ch === "+") this.blockScalarKeep = true;
				else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
				else if (ch !== "-") break;
			}
			return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
		}
		*parseBlockScalar() {
			let nl = this.pos - 1;
			let indent$2 = 0;
			let ch;
			loop: for (let i$2 = this.pos; ch = this.buffer[i$2]; ++i$2) switch (ch) {
				case " ":
					indent$2 += 1;
					break;
				case "\n":
					nl = i$2;
					indent$2 = 0;
					break;
				case "\r": {
					const next = this.buffer[i$2 + 1];
					if (!next && !this.atEnd) return this.setNext("block-scalar");
					if (next === "\n") break;
				}
				default: break loop;
			}
			if (!ch && !this.atEnd) return this.setNext("block-scalar");
			if (indent$2 >= this.indentNext) {
				if (this.blockScalarIndent === -1) this.indentNext = indent$2;
				else this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
				do {
					const cs = this.continueScalar(nl + 1);
					if (cs === -1) break;
					nl = this.buffer.indexOf("\n", cs);
				} while (nl !== -1);
				if (nl === -1) {
					if (!this.atEnd) return this.setNext("block-scalar");
					nl = this.buffer.length;
				}
			}
			let i$1 = nl + 1;
			ch = this.buffer[i$1];
			while (ch === " ") ch = this.buffer[++i$1];
			if (ch === "	") {
				while (ch === "	" || ch === " " || ch === "\r" || ch === "\n") ch = this.buffer[++i$1];
				nl = i$1 - 1;
			} else if (!this.blockScalarKeep) do {
				let i$2 = nl - 1;
				let ch$1 = this.buffer[i$2];
				if (ch$1 === "\r") ch$1 = this.buffer[--i$2];
				const lastChar = i$2;
				while (ch$1 === " ") ch$1 = this.buffer[--i$2];
				if (ch$1 === "\n" && i$2 >= this.pos && i$2 + 1 + indent$2 > lastChar) nl = i$2;
				else break;
			} while (true);
			yield cst$2.SCALAR;
			yield* this.pushToIndex(nl + 1, true);
			return yield* this.parseLineStart();
		}
		*parsePlainScalar() {
			const inFlow = this.flowLevel > 0;
			let end = this.pos - 1;
			let i$1 = this.pos - 1;
			let ch;
			while (ch = this.buffer[++i$1]) if (ch === ":") {
				const next = this.buffer[i$1 + 1];
				if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
				end = i$1;
			} else if (isEmpty(ch)) {
				let next = this.buffer[i$1 + 1];
				if (ch === "\r") if (next === "\n") {
					i$1 += 1;
					ch = "\n";
					next = this.buffer[i$1 + 1];
				} else end = i$1;
				if (next === "#" || inFlow && flowIndicatorChars.has(next)) break;
				if (ch === "\n") {
					const cs = this.continueScalar(i$1 + 1);
					if (cs === -1) break;
					i$1 = Math.max(i$1, cs - 2);
				}
			} else {
				if (inFlow && flowIndicatorChars.has(ch)) break;
				end = i$1;
			}
			if (!ch && !this.atEnd) return this.setNext("plain-scalar");
			yield cst$2.SCALAR;
			yield* this.pushToIndex(end + 1, true);
			return inFlow ? "flow" : "doc";
		}
		*pushCount(n$1) {
			if (n$1 > 0) {
				yield this.buffer.substr(this.pos, n$1);
				this.pos += n$1;
				return n$1;
			}
			return 0;
		}
		*pushToIndex(i$1, allowEmpty) {
			const s = this.buffer.slice(this.pos, i$1);
			if (s) {
				yield s;
				this.pos += s.length;
				return s.length;
			} else if (allowEmpty) yield "";
			return 0;
		}
		*pushIndicators() {
			switch (this.charAt(0)) {
				case "!": return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				case "&": return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				case "-":
				case "?":
				case ":": {
					const inFlow = this.flowLevel > 0;
					const ch1 = this.charAt(1);
					if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
						if (!inFlow) this.indentNext = this.indentValue + 1;
						else if (this.flowKey) this.flowKey = false;
						return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
					}
				}
			}
			return 0;
		}
		*pushTag() {
			if (this.charAt(1) === "<") {
				let i$1 = this.pos + 2;
				let ch = this.buffer[i$1];
				while (!isEmpty(ch) && ch !== ">") ch = this.buffer[++i$1];
				return yield* this.pushToIndex(ch === ">" ? i$1 + 1 : i$1, false);
			} else {
				let i$1 = this.pos + 1;
				let ch = this.buffer[i$1];
				while (ch) if (tagChars.has(ch)) ch = this.buffer[++i$1];
				else if (ch === "%" && hexDigits.has(this.buffer[i$1 + 1]) && hexDigits.has(this.buffer[i$1 + 2])) ch = this.buffer[i$1 += 3];
				else break;
				return yield* this.pushToIndex(i$1, false);
			}
		}
		*pushNewline() {
			const ch = this.buffer[this.pos];
			if (ch === "\n") return yield* this.pushCount(1);
			else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
			else return 0;
		}
		*pushSpaces(allowTabs) {
			let i$1 = this.pos - 1;
			let ch;
			do
				ch = this.buffer[++i$1];
			while (ch === " " || allowTabs && ch === "	");
			const n$1 = i$1 - this.pos;
			if (n$1 > 0) {
				yield this.buffer.substr(this.pos, n$1);
				this.pos = i$1;
			}
			return n$1;
		}
		*pushUntil(test) {
			let i$1 = this.pos;
			let ch = this.buffer[i$1];
			while (!test(ch)) ch = this.buffer[++i$1];
			return yield* this.pushToIndex(i$1, false);
		}
	};
	exports.Lexer = Lexer;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/line-counter.js": ((exports) => {
	/**
	* Tracks newlines during parsing in order to provide an efficient API for
	* determining the one-indexed `{ line, col }` position for any offset
	* within the input.
	*/
	var LineCounter = class {
		constructor() {
			this.lineStarts = [];
			/**
			* Should be called in ascending order. Otherwise, call
			* `lineCounter.lineStarts.sort()` before calling `linePos()`.
			*/
			this.addNewLine = (offset) => this.lineStarts.push(offset);
			/**
			* Performs a binary search and returns the 1-indexed { line, col }
			* position of `offset`. If `line === 0`, `addNewLine` has never been
			* called or `offset` is before the first known newline.
			*/
			this.linePos = (offset) => {
				let low = 0;
				let high = this.lineStarts.length;
				while (low < high) {
					const mid = low + high >> 1;
					if (this.lineStarts[mid] < offset) low = mid + 1;
					else high = mid;
				}
				if (this.lineStarts[low] === offset) return {
					line: low + 1,
					col: 1
				};
				if (low === 0) return {
					line: 0,
					col: offset
				};
				const start = this.lineStarts[low - 1];
				return {
					line: low,
					col: offset - start + 1
				};
			};
		}
	};
	exports.LineCounter = LineCounter;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/parser.js
var require_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/parser.js": ((exports) => {
	var node_process = __require("process");
	var cst$1 = require_cst();
	var lexer$1 = require_lexer();
	function includesToken(list$5, type) {
		for (let i$1 = 0; i$1 < list$5.length; ++i$1) if (list$5[i$1].type === type) return true;
		return false;
	}
	function findNonEmptyIndex(list$5) {
		for (let i$1 = 0; i$1 < list$5.length; ++i$1) switch (list$5[i$1].type) {
			case "space":
			case "comment":
			case "newline": break;
			default: return i$1;
		}
		return -1;
	}
	function isFlowToken(token) {
		switch (token?.type) {
			case "alias":
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar":
			case "flow-collection": return true;
			default: return false;
		}
	}
	function getPrevProps(parent) {
		switch (parent.type) {
			case "document": return parent.start;
			case "block-map": {
				const it = parent.items[parent.items.length - 1];
				return it.sep ?? it.start;
			}
			case "block-seq": return parent.items[parent.items.length - 1].start;
			default: return [];
		}
	}
	/** Note: May modify input array */
	function getFirstKeyStartProps(prev) {
		if (prev.length === 0) return [];
		let i$1 = prev.length;
		loop: while (--i$1 >= 0) switch (prev[i$1].type) {
			case "doc-start":
			case "explicit-key-ind":
			case "map-value-ind":
			case "seq-item-ind":
			case "newline": break loop;
		}
		while (prev[++i$1]?.type === "space");
		return prev.splice(i$1, prev.length);
	}
	function fixFlowSeqItems(fc) {
		if (fc.start.type === "flow-seq-start") {
			for (const it of fc.items) if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
				if (it.key) it.value = it.key;
				delete it.key;
				if (isFlowToken(it.value)) if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
				else it.value.end = it.sep;
				else Array.prototype.push.apply(it.start, it.sep);
				delete it.sep;
			}
		}
	}
	/**
	* A YAML concrete syntax tree (CST) parser
	*
	* ```ts
	* const src: string = ...
	* for (const token of new Parser().parse(src)) {
	*   // token: Token
	* }
	* ```
	*
	* To use the parser with a user-provided lexer:
	*
	* ```ts
	* function* parse(source: string, lexer: Lexer) {
	*   const parser = new Parser()
	*   for (const lexeme of lexer.lex(source))
	*     yield* parser.next(lexeme)
	*   yield* parser.end()
	* }
	*
	* const src: string = ...
	* const lexer = new Lexer()
	* for (const token of parse(src, lexer)) {
	*   // token: Token
	* }
	* ```
	*/
	var Parser = class {
		/**
		* @param onNewLine - If defined, called separately with the start position of
		*   each new line (in `parse()`, including the start of input).
		*/
		constructor(onNewLine) {
			/** If true, space and sequence indicators count as indentation */
			this.atNewLine = true;
			/** If true, next token is a scalar value */
			this.atScalar = false;
			/** Current indentation level */
			this.indent = 0;
			/** Current offset since the start of parsing */
			this.offset = 0;
			/** On the same line with a block map key */
			this.onKeyLine = false;
			/** Top indicates the node that's currently being built */
			this.stack = [];
			/** The source of the current token, set in parse() */
			this.source = "";
			/** The type of the current token, set in parse() */
			this.type = "";
			this.lexer = new lexer$1.Lexer();
			this.onNewLine = onNewLine;
		}
		/**
		* Parse `source` as a YAML stream.
		* If `incomplete`, a part of the last line may be left as a buffer for the next call.
		*
		* Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
		*
		* @returns A generator of tokens representing each directive, document, and other structure.
		*/
		*parse(source, incomplete = false) {
			if (this.onNewLine && this.offset === 0) this.onNewLine(0);
			for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
			if (!incomplete) yield* this.end();
		}
		/**
		* Advance the parser by the `source` of one lexical token.
		*/
		*next(source) {
			this.source = source;
			if (node_process.env.LOG_TOKENS) console.log("|", cst$1.prettyToken(source));
			if (this.atScalar) {
				this.atScalar = false;
				yield* this.step();
				this.offset += source.length;
				return;
			}
			const type = cst$1.tokenType(source);
			if (!type) {
				const message = `Not a YAML token: ${source}`;
				yield* this.pop({
					type: "error",
					offset: this.offset,
					message,
					source
				});
				this.offset += source.length;
			} else if (type === "scalar") {
				this.atNewLine = false;
				this.atScalar = true;
				this.type = "scalar";
			} else {
				this.type = type;
				yield* this.step();
				switch (type) {
					case "newline":
						this.atNewLine = true;
						this.indent = 0;
						if (this.onNewLine) this.onNewLine(this.offset + source.length);
						break;
					case "space":
						if (this.atNewLine && source[0] === " ") this.indent += source.length;
						break;
					case "explicit-key-ind":
					case "map-value-ind":
					case "seq-item-ind":
						if (this.atNewLine) this.indent += source.length;
						break;
					case "doc-mode":
					case "flow-error-end": return;
					default: this.atNewLine = false;
				}
				this.offset += source.length;
			}
		}
		/** Call at end of input to push out any remaining constructions */
		*end() {
			while (this.stack.length > 0) yield* this.pop();
		}
		get sourceToken() {
			return {
				type: this.type,
				offset: this.offset,
				indent: this.indent,
				source: this.source
			};
		}
		*step() {
			const top = this.peek(1);
			if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
				while (this.stack.length > 0) yield* this.pop();
				this.stack.push({
					type: "doc-end",
					offset: this.offset,
					source: this.source
				});
				return;
			}
			if (!top) return yield* this.stream();
			switch (top.type) {
				case "document": return yield* this.document(top);
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return yield* this.scalar(top);
				case "block-scalar": return yield* this.blockScalar(top);
				case "block-map": return yield* this.blockMap(top);
				case "block-seq": return yield* this.blockSequence(top);
				case "flow-collection": return yield* this.flowCollection(top);
				case "doc-end": return yield* this.documentEnd(top);
			}
			/* istanbul ignore next should not happen */
			yield* this.pop();
		}
		peek(n$1) {
			return this.stack[this.stack.length - n$1];
		}
		*pop(error) {
			const token = error ?? this.stack.pop();
			/* istanbul ignore if should not happen */
			if (!token) yield {
				type: "error",
				offset: this.offset,
				source: "",
				message: "Tried to pop an empty stack"
			};
			else if (this.stack.length === 0) yield token;
			else {
				const top = this.peek(1);
				if (token.type === "block-scalar") token.indent = "indent" in top ? top.indent : 0;
				else if (token.type === "flow-collection" && top.type === "document") token.indent = 0;
				if (token.type === "flow-collection") fixFlowSeqItems(token);
				switch (top.type) {
					case "document":
						top.value = token;
						break;
					case "block-scalar":
						top.props.push(token);
						break;
					case "block-map": {
						const it = top.items[top.items.length - 1];
						if (it.value) {
							top.items.push({
								start: [],
								key: token,
								sep: []
							});
							this.onKeyLine = true;
							return;
						} else if (it.sep) it.value = token;
						else {
							Object.assign(it, {
								key: token,
								sep: []
							});
							this.onKeyLine = !it.explicitKey;
							return;
						}
						break;
					}
					case "block-seq": {
						const it = top.items[top.items.length - 1];
						if (it.value) top.items.push({
							start: [],
							value: token
						});
						else it.value = token;
						break;
					}
					case "flow-collection": {
						const it = top.items[top.items.length - 1];
						if (!it || it.value) top.items.push({
							start: [],
							key: token,
							sep: []
						});
						else if (it.sep) it.value = token;
						else Object.assign(it, {
							key: token,
							sep: []
						});
						return;
					}
					default:
						yield* this.pop();
						yield* this.pop(token);
				}
				if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
					const last = token.items[token.items.length - 1];
					if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
						if (top.type === "document") top.end = last.start;
						else top.items.push({ start: last.start });
						token.items.splice(-1, 1);
					}
				}
			}
		}
		*stream() {
			switch (this.type) {
				case "directive-line":
					yield {
						type: "directive",
						offset: this.offset,
						source: this.source
					};
					return;
				case "byte-order-mark":
				case "space":
				case "comment":
				case "newline":
					yield this.sourceToken;
					return;
				case "doc-mode":
				case "doc-start": {
					const doc = {
						type: "document",
						offset: this.offset,
						start: []
					};
					if (this.type === "doc-start") doc.start.push(this.sourceToken);
					this.stack.push(doc);
					return;
				}
			}
			yield {
				type: "error",
				offset: this.offset,
				message: `Unexpected ${this.type} token in YAML stream`,
				source: this.source
			};
		}
		*document(doc) {
			if (doc.value) return yield* this.lineEnd(doc);
			switch (this.type) {
				case "doc-start":
					if (findNonEmptyIndex(doc.start) !== -1) {
						yield* this.pop();
						yield* this.step();
					} else doc.start.push(this.sourceToken);
					return;
				case "anchor":
				case "tag":
				case "space":
				case "comment":
				case "newline":
					doc.start.push(this.sourceToken);
					return;
			}
			const bv = this.startBlockValue(doc);
			if (bv) this.stack.push(bv);
			else yield {
				type: "error",
				offset: this.offset,
				message: `Unexpected ${this.type} token in YAML document`,
				source: this.source
			};
		}
		*scalar(scalar) {
			if (this.type === "map-value-ind") {
				const prev = getPrevProps(this.peek(2));
				const start = getFirstKeyStartProps(prev);
				let sep$1;
				if (scalar.end) {
					sep$1 = scalar.end;
					sep$1.push(this.sourceToken);
					delete scalar.end;
				} else sep$1 = [this.sourceToken];
				const map$6 = {
					type: "block-map",
					offset: scalar.offset,
					indent: scalar.indent,
					items: [{
						start,
						key: scalar,
						sep: sep$1
					}]
				};
				this.onKeyLine = true;
				this.stack[this.stack.length - 1] = map$6;
			} else yield* this.lineEnd(scalar);
		}
		*blockScalar(scalar) {
			switch (this.type) {
				case "space":
				case "comment":
				case "newline":
					scalar.props.push(this.sourceToken);
					return;
				case "scalar":
					scalar.source = this.source;
					this.atNewLine = true;
					this.indent = 0;
					if (this.onNewLine) {
						let nl = this.source.indexOf("\n") + 1;
						while (nl !== 0) {
							this.onNewLine(this.offset + nl);
							nl = this.source.indexOf("\n", nl) + 1;
						}
					}
					yield* this.pop();
					break;
				default:
					yield* this.pop();
					yield* this.step();
			}
		}
		*blockMap(map$6) {
			const it = map$6.items[map$6.items.length - 1];
			switch (this.type) {
				case "newline":
					this.onKeyLine = false;
					if (it.value) {
						const end = "end" in it.value ? it.value.end : void 0;
						if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
						else map$6.items.push({ start: [this.sourceToken] });
					} else if (it.sep) it.sep.push(this.sourceToken);
					else it.start.push(this.sourceToken);
					return;
				case "space":
				case "comment":
					if (it.value) map$6.items.push({ start: [this.sourceToken] });
					else if (it.sep) it.sep.push(this.sourceToken);
					else {
						if (this.atIndentedComment(it.start, map$6.indent)) {
							const end = map$6.items[map$6.items.length - 2]?.value?.end;
							if (Array.isArray(end)) {
								Array.prototype.push.apply(end, it.start);
								end.push(this.sourceToken);
								map$6.items.pop();
								return;
							}
						}
						it.start.push(this.sourceToken);
					}
					return;
			}
			if (this.indent >= map$6.indent) {
				const atMapIndent = !this.onKeyLine && this.indent === map$6.indent;
				const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
				let start = [];
				if (atNextItem && it.sep && !it.value) {
					const nl = [];
					for (let i$1 = 0; i$1 < it.sep.length; ++i$1) {
						const st = it.sep[i$1];
						switch (st.type) {
							case "newline":
								nl.push(i$1);
								break;
							case "space": break;
							case "comment":
								if (st.indent > map$6.indent) nl.length = 0;
								break;
							default: nl.length = 0;
						}
					}
					if (nl.length >= 2) start = it.sep.splice(nl[1]);
				}
				switch (this.type) {
					case "anchor":
					case "tag":
						if (atNextItem || it.value) {
							start.push(this.sourceToken);
							map$6.items.push({ start });
							this.onKeyLine = true;
						} else if (it.sep) it.sep.push(this.sourceToken);
						else it.start.push(this.sourceToken);
						return;
					case "explicit-key-ind":
						if (!it.sep && !it.explicitKey) {
							it.start.push(this.sourceToken);
							it.explicitKey = true;
						} else if (atNextItem || it.value) {
							start.push(this.sourceToken);
							map$6.items.push({
								start,
								explicitKey: true
							});
						} else this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: [this.sourceToken],
								explicitKey: true
							}]
						});
						this.onKeyLine = true;
						return;
					case "map-value-ind":
						if (it.explicitKey) if (!it.sep) if (includesToken(it.start, "newline")) Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						else {
							const start$1 = getFirstKeyStartProps(it.start);
							this.stack.push({
								type: "block-map",
								offset: this.offset,
								indent: this.indent,
								items: [{
									start: start$1,
									key: null,
									sep: [this.sourceToken]
								}]
							});
						}
						else if (it.value) map$6.items.push({
							start: [],
							key: null,
							sep: [this.sourceToken]
						});
						else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start,
								key: null,
								sep: [this.sourceToken]
							}]
						});
						else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
							const start$1 = getFirstKeyStartProps(it.start);
							const key = it.key;
							const sep$1 = it.sep;
							sep$1.push(this.sourceToken);
							delete it.key;
							delete it.sep;
							this.stack.push({
								type: "block-map",
								offset: this.offset,
								indent: this.indent,
								items: [{
									start: start$1,
									key,
									sep: sep$1
								}]
							});
						} else if (start.length > 0) it.sep = it.sep.concat(start, this.sourceToken);
						else it.sep.push(this.sourceToken);
						else if (!it.sep) Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						else if (it.value || atNextItem) map$6.items.push({
							start,
							key: null,
							sep: [this.sourceToken]
						});
						else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: [],
								key: null,
								sep: [this.sourceToken]
							}]
						});
						else it.sep.push(this.sourceToken);
						this.onKeyLine = true;
						return;
					case "alias":
					case "scalar":
					case "single-quoted-scalar":
					case "double-quoted-scalar": {
						const fs$2 = this.flowScalar(this.type);
						if (atNextItem || it.value) {
							map$6.items.push({
								start,
								key: fs$2,
								sep: []
							});
							this.onKeyLine = true;
						} else if (it.sep) this.stack.push(fs$2);
						else {
							Object.assign(it, {
								key: fs$2,
								sep: []
							});
							this.onKeyLine = true;
						}
						return;
					}
					default: {
						const bv = this.startBlockValue(map$6);
						if (bv) {
							if (bv.type === "block-seq") {
								if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
									yield* this.pop({
										type: "error",
										offset: this.offset,
										message: "Unexpected block-seq-ind on same line with key",
										source: this.source
									});
									return;
								}
							} else if (atMapIndent) map$6.items.push({ start });
							this.stack.push(bv);
							return;
						}
					}
				}
			}
			yield* this.pop();
			yield* this.step();
		}
		*blockSequence(seq$6) {
			const it = seq$6.items[seq$6.items.length - 1];
			switch (this.type) {
				case "newline":
					if (it.value) {
						const end = "end" in it.value ? it.value.end : void 0;
						if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
						else seq$6.items.push({ start: [this.sourceToken] });
					} else it.start.push(this.sourceToken);
					return;
				case "space":
				case "comment":
					if (it.value) seq$6.items.push({ start: [this.sourceToken] });
					else {
						if (this.atIndentedComment(it.start, seq$6.indent)) {
							const end = seq$6.items[seq$6.items.length - 2]?.value?.end;
							if (Array.isArray(end)) {
								Array.prototype.push.apply(end, it.start);
								end.push(this.sourceToken);
								seq$6.items.pop();
								return;
							}
						}
						it.start.push(this.sourceToken);
					}
					return;
				case "anchor":
				case "tag":
					if (it.value || this.indent <= seq$6.indent) break;
					it.start.push(this.sourceToken);
					return;
				case "seq-item-ind":
					if (this.indent !== seq$6.indent) break;
					if (it.value || includesToken(it.start, "seq-item-ind")) seq$6.items.push({ start: [this.sourceToken] });
					else it.start.push(this.sourceToken);
					return;
			}
			if (this.indent > seq$6.indent) {
				const bv = this.startBlockValue(seq$6);
				if (bv) {
					this.stack.push(bv);
					return;
				}
			}
			yield* this.pop();
			yield* this.step();
		}
		*flowCollection(fc) {
			const it = fc.items[fc.items.length - 1];
			if (this.type === "flow-error-end") {
				let top;
				do {
					yield* this.pop();
					top = this.peek(1);
				} while (top && top.type === "flow-collection");
			} else if (fc.end.length === 0) {
				switch (this.type) {
					case "comma":
					case "explicit-key-ind":
						if (!it || it.sep) fc.items.push({ start: [this.sourceToken] });
						else it.start.push(this.sourceToken);
						return;
					case "map-value-ind":
						if (!it || it.value) fc.items.push({
							start: [],
							key: null,
							sep: [this.sourceToken]
						});
						else if (it.sep) it.sep.push(this.sourceToken);
						else Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						return;
					case "space":
					case "comment":
					case "newline":
					case "anchor":
					case "tag":
						if (!it || it.value) fc.items.push({ start: [this.sourceToken] });
						else if (it.sep) it.sep.push(this.sourceToken);
						else it.start.push(this.sourceToken);
						return;
					case "alias":
					case "scalar":
					case "single-quoted-scalar":
					case "double-quoted-scalar": {
						const fs$2 = this.flowScalar(this.type);
						if (!it || it.value) fc.items.push({
							start: [],
							key: fs$2,
							sep: []
						});
						else if (it.sep) this.stack.push(fs$2);
						else Object.assign(it, {
							key: fs$2,
							sep: []
						});
						return;
					}
					case "flow-map-end":
					case "flow-seq-end":
						fc.end.push(this.sourceToken);
						return;
				}
				const bv = this.startBlockValue(fc);
				/* istanbul ignore else should not happen */
				if (bv) this.stack.push(bv);
				else {
					yield* this.pop();
					yield* this.step();
				}
			} else {
				const parent = this.peek(2);
				if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
					yield* this.pop();
					yield* this.step();
				} else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
					const prev = getPrevProps(parent);
					const start = getFirstKeyStartProps(prev);
					fixFlowSeqItems(fc);
					const sep$1 = fc.end.splice(1, fc.end.length);
					sep$1.push(this.sourceToken);
					const map$6 = {
						type: "block-map",
						offset: fc.offset,
						indent: fc.indent,
						items: [{
							start,
							key: fc,
							sep: sep$1
						}]
					};
					this.onKeyLine = true;
					this.stack[this.stack.length - 1] = map$6;
				} else yield* this.lineEnd(fc);
			}
		}
		flowScalar(type) {
			if (this.onNewLine) {
				let nl = this.source.indexOf("\n") + 1;
				while (nl !== 0) {
					this.onNewLine(this.offset + nl);
					nl = this.source.indexOf("\n", nl) + 1;
				}
			}
			return {
				type,
				offset: this.offset,
				indent: this.indent,
				source: this.source
			};
		}
		startBlockValue(parent) {
			switch (this.type) {
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return this.flowScalar(this.type);
				case "block-scalar-header": return {
					type: "block-scalar",
					offset: this.offset,
					indent: this.indent,
					props: [this.sourceToken],
					source: ""
				};
				case "flow-map-start":
				case "flow-seq-start": return {
					type: "flow-collection",
					offset: this.offset,
					indent: this.indent,
					start: this.sourceToken,
					items: [],
					end: []
				};
				case "seq-item-ind": return {
					type: "block-seq",
					offset: this.offset,
					indent: this.indent,
					items: [{ start: [this.sourceToken] }]
				};
				case "explicit-key-ind": {
					this.onKeyLine = true;
					const prev = getPrevProps(parent);
					const start = getFirstKeyStartProps(prev);
					start.push(this.sourceToken);
					return {
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							explicitKey: true
						}]
					};
				}
				case "map-value-ind": {
					this.onKeyLine = true;
					const prev = getPrevProps(parent);
					const start = getFirstKeyStartProps(prev);
					return {
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							key: null,
							sep: [this.sourceToken]
						}]
					};
				}
			}
			return null;
		}
		atIndentedComment(start, indent$2) {
			if (this.type !== "comment") return false;
			if (this.indent <= indent$2) return false;
			return start.every((st) => st.type === "newline" || st.type === "space");
		}
		*documentEnd(docEnd) {
			if (this.type !== "doc-mode") {
				if (docEnd.end) docEnd.end.push(this.sourceToken);
				else docEnd.end = [this.sourceToken];
				if (this.type === "newline") yield* this.pop();
			}
		}
		*lineEnd(token) {
			switch (this.type) {
				case "comma":
				case "doc-start":
				case "doc-end":
				case "flow-seq-end":
				case "flow-map-end":
				case "map-value-ind":
					yield* this.pop();
					yield* this.step();
					break;
				case "newline": this.onKeyLine = false;
				case "space":
				case "comment":
				default:
					if (token.end) token.end.push(this.sourceToken);
					else token.end = [this.sourceToken];
					if (this.type === "newline") yield* this.pop();
			}
		}
	};
	exports.Parser = Parser;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/public-api.js
var require_public_api = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/public-api.js": ((exports) => {
	var composer$1 = require_composer();
	var Document$2 = require_Document();
	var errors$1 = require_errors();
	var log = require_log();
	var identity$2 = require_identity();
	var lineCounter$1 = require_line_counter();
	var parser$1 = require_parser();
	function parseOptions(options) {
		const prettyErrors = options.prettyErrors !== false;
		return {
			lineCounter: options.lineCounter || prettyErrors && new lineCounter$1.LineCounter() || null,
			prettyErrors
		};
	}
	/**
	* Parse the input as a stream of YAML documents.
	*
	* Documents should be separated from each other by `...` or `---` marker lines.
	*
	* @returns If an empty `docs` array is returned, it will be of type
	*   EmptyStream and contain additional stream information. In
	*   TypeScript, you should use `'empty' in docs` as a type guard for it.
	*/
	function parseAllDocuments(source, options = {}) {
		const { lineCounter: lineCounter$2, prettyErrors } = parseOptions(options);
		const parser$1$1 = new parser$1.Parser(lineCounter$2?.addNewLine);
		const composer$1$1 = new composer$1.Composer(options);
		const docs = Array.from(composer$1$1.compose(parser$1$1.parse(source)));
		if (prettyErrors && lineCounter$2) for (const doc of docs) {
			doc.errors.forEach(errors$1.prettifyError(source, lineCounter$2));
			doc.warnings.forEach(errors$1.prettifyError(source, lineCounter$2));
		}
		if (docs.length > 0) return docs;
		return Object.assign([], { empty: true }, composer$1$1.streamInfo());
	}
	/** Parse an input string into a single YAML.Document */
	function parseDocument$1(source, options = {}) {
		const { lineCounter: lineCounter$2, prettyErrors } = parseOptions(options);
		const parser$1$1 = new parser$1.Parser(lineCounter$2?.addNewLine);
		const composer$1$1 = new composer$1.Composer(options);
		let doc = null;
		for (const _doc of composer$1$1.compose(parser$1$1.parse(source), true, source.length)) if (!doc) doc = _doc;
		else if (doc.options.logLevel !== "silent") {
			doc.errors.push(new errors$1.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
			break;
		}
		if (prettyErrors && lineCounter$2) {
			doc.errors.forEach(errors$1.prettifyError(source, lineCounter$2));
			doc.warnings.forEach(errors$1.prettifyError(source, lineCounter$2));
		}
		return doc;
	}
	function parse$1(src, reviver, options) {
		let _reviver = void 0;
		if (typeof reviver === "function") _reviver = reviver;
		else if (options === void 0 && reviver && typeof reviver === "object") options = reviver;
		const doc = parseDocument$1(src, options);
		if (!doc) return null;
		doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
		if (doc.errors.length > 0) if (doc.options.logLevel !== "silent") throw doc.errors[0];
		else doc.errors = [];
		return doc.toJS(Object.assign({ reviver: _reviver }, options));
	}
	function stringify(value, replacer, options) {
		let _replacer = null;
		if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
		else if (options === void 0 && replacer) options = replacer;
		if (typeof options === "string") options = options.length;
		if (typeof options === "number") {
			const indent$2 = Math.round(options);
			options = indent$2 < 1 ? void 0 : indent$2 > 8 ? { indent: 8 } : { indent: indent$2 };
		}
		if (value === void 0) {
			const { keepUndefined } = options ?? replacer ?? {};
			if (!keepUndefined) return void 0;
		}
		if (identity$2.isDocument(value) && !_replacer) return value.toString(options);
		return new Document$2.Document(value, _replacer, options).toString(options);
	}
	exports.parse = parse$1;
	exports.parseAllDocuments = parseAllDocuments;
	exports.parseDocument = parseDocument$1;
	exports.stringify = stringify;
}) });

//#endregion
//#region ../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/index.js
var require_dist = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/index.js": ((exports) => {
	var composer = require_composer();
	var Document$1 = require_Document();
	var Schema = require_Schema();
	var errors = require_errors();
	var Alias = require_Alias();
	var identity$1 = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var cst = require_cst();
	var lexer = require_lexer();
	var lineCounter = require_line_counter();
	var parser = require_parser();
	var publicApi = require_public_api();
	var visit = require_visit();
	exports.Composer = composer.Composer;
	exports.Document = Document$1.Document;
	exports.Schema = Schema.Schema;
	exports.YAMLError = errors.YAMLError;
	exports.YAMLParseError = errors.YAMLParseError;
	exports.YAMLWarning = errors.YAMLWarning;
	exports.Alias = Alias.Alias;
	exports.isAlias = identity$1.isAlias;
	exports.isCollection = identity$1.isCollection;
	exports.isDocument = identity$1.isDocument;
	exports.isMap = identity$1.isMap;
	exports.isNode = identity$1.isNode;
	exports.isPair = identity$1.isPair;
	exports.isScalar = identity$1.isScalar;
	exports.isSeq = identity$1.isSeq;
	exports.Pair = Pair.Pair;
	exports.Scalar = Scalar.Scalar;
	exports.YAMLMap = YAMLMap.YAMLMap;
	exports.YAMLSeq = YAMLSeq.YAMLSeq;
	exports.Lexer = lexer.Lexer;
	exports.LineCounter = lineCounter.LineCounter;
	exports.Parser = parser.Parser;
	exports.parse = publicApi.parse;
	exports.parseAllDocuments = publicApi.parseAllDocuments;
	exports.parseDocument = publicApi.parseDocument;
	exports.stringify = publicApi.stringify;
	exports.visit = visit.visit;
	exports.visitAsync = visit.visitAsync;
}) });

//#endregion
//#region ../core/tooling/index.ts
var import_silver_fleece_umd = /* @__PURE__ */ __toESM(require_silver_fleece_umd(), 1);
var import_dist = /* @__PURE__ */ __toESM(require_dist(), 1);
/**
* Parses as string to an AST. Code below is taken from `esrap` to ensure compatibilty.
* https://github.com/sveltejs/esrap/blob/9daf5dd43b31f17f596aa7da91678f2650666dd0/test/common.js#L12
*/
function parseScript$1(content) {
	const comments = [];
	const ast = Parser$1.extend(tsPlugin()).parse(content, {
		ecmaVersion: "latest",
		sourceType: "module",
		locations: true,
		onComment: (block, value, start, end) => {
			if (block && /\n/.test(value)) {
				let a = start;
				while (a > 0 && content[a - 1] !== "\n") a -= 1;
				let b$1 = a;
				while (/[ \t]/.test(content[b$1])) b$1 += 1;
				const indentation = content.slice(a, b$1);
				value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
			}
			comments.push({
				type: block ? "Block" : "Line",
				value,
				start,
				end
			});
		}
	});
	walk(ast, null, { _(commentNode, { next }) {
		let comment$1;
		while (comments[0] && commentNode.start && comments[0].start < commentNode.start) {
			comment$1 = comments.shift();
			(commentNode.leadingComments ??= []).push(comment$1);
		}
		next();
		if (comments[0]) {
			const slice = content.slice(commentNode.end, comments[0].start);
			if (/^[,) \t]*$/.test(slice)) commentNode.trailingComments = [comments.shift()];
		}
	} });
	return ast;
}
function serializeScript(ast, previousContent) {
	const { code } = print(ast, {
		indent: guessIndentString(previousContent),
		quotes: guessQuoteStyle(ast)
	});
	return code;
}
function parseCss$1(content) {
	return parse(content);
}
function parseHtml$1(content) {
	return parseDocument(content, {
		recognizeSelfClosing: true,
		lowerCaseTags: false
	});
}
function serializeHtml(ast) {
	return esm_default(ast, {
		encodeEntities: "utf8",
		selfClosingTags: true
	});
}
function stripAst(node, propsToRemove) {
	if (typeof node !== "object" || node === null) return node;
	for (const key in node) {
		if (propsToRemove.includes(key)) {
			delete node[key];
			continue;
		}
		const child = node[key];
		if (child && typeof child === "object") if (Array.isArray(child)) child.forEach((element) => stripAst(element, propsToRemove));
		else stripAst(child, propsToRemove);
	}
	return node;
}
function parseJson$1(content) {
	return import_silver_fleece_umd.evaluate(content);
}
function serializeJson(originalInput, data$1) {
	const indentString = guessIndentString(originalInput);
	let spaces;
	if (indentString && indentString.includes(" ")) spaces = (indentString.match(/ /g) || []).length;
	return import_silver_fleece_umd.stringify(data$1, { spaces });
}
function guessIndentString(str) {
	if (!str) return "	";
	const lines = str.split("\n");
	let tabs = 0;
	let spaces = 0;
	let minSpaces = 8;
	lines.forEach((line) => {
		const match = /^(?: +|\t+)/.exec(line);
		if (!match) return;
		const whitespace = match[0];
		if (whitespace.length === line.length) return;
		if (whitespace[0] === "	") tabs += 1;
		else {
			spaces += 1;
			if (whitespace.length > 1 && whitespace.length < minSpaces) minSpaces = whitespace.length;
		}
	});
	if (spaces > tabs) {
		let result = "";
		while (minSpaces--) result += " ";
		return result;
	} else return "	";
}
function guessQuoteStyle(ast) {
	let singleCount = 0;
	let doubleCount = 0;
	walk(ast, null, { Literal(node) {
		if (node.raw && node.raw.length >= 2) {
			const quotes = [node.raw[0], node.raw[node.raw.length - 1]];
			for (const quote$1 of quotes) switch (quote$1) {
				case "'":
					singleCount++;
					break;
				case "\"":
					doubleCount++;
					break;
				default: break;
			}
		}
	} });
	if (singleCount === 0 && doubleCount === 0) return;
	return singleCount > doubleCount ? "single" : "double";
}
function parseYaml$1(content) {
	return import_dist.parseDocument(content);
}
function serializeYaml(data$1) {
	return import_dist.stringify(data$1, { singleQuote: true });
}

//#endregion
//#region ../core/index.ts
var import_picocolors = /* @__PURE__ */ __toESM(require_picocolors(), 1);

//#endregion
//#region ../../node_modules/.pnpm/magic-string@0.30.19/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}
	add(n$1) {
		this.bits[n$1 >> 5] |= 1 << (n$1 & 31);
	}
	has(n$1) {
		return !!(this.bits[n$1 >> 5] & 1 << (n$1 & 31));
	}
};
var Chunk = class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		this.previous = null;
		this.next = null;
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", void 0, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", void 0, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
	else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa$1 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min + 1).join(" ");
}
function getRelativePath(from$1, to) {
	const fromParts = from$1.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i$1 = fromParts.length;
		while (i$1--) fromParts[i$1] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString = Object.prototype.toString;
function isObject(thing) {
	return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i$1 = 0, pos = 0; i$1 < originalLines.length; i$1++) {
		lineOffsets.push(pos);
		pos += originalLines[i$1].length + 1;
	}
	return function locate(index) {
		let i$1 = 0;
		let j$2 = lineOffsets.length;
		while (i$1 < j$2) {
			const m$1 = i$1 + j$2 >> 1;
			if (index < lineOffsets[m$1]) j$2 = m$1;
			else i$1 = m$1 + 1;
		}
		const line = i$1 - 1;
		const column = index - lineOffsets[line];
		return {
			line,
			column
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
					else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i$1 = 0; i$1 < lines.length - 1; i$1++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString {
	constructor(string$5, options = {}) {
		const chunk = new Chunk(0, string$5.length, string$5);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string$5
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: void 0
			},
			ignoreList: {
				writable: true,
				value: options.ignoreList
			},
			offset: {
				writable: true,
				value: options.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string$5.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
		else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
		else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options) {
		options = options || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
			else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		if (this.outro) mappings.advance(this.outro);
		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
			sources: [options.source ? getRelativePath(options.file || "", options.source) : options.file || ""],
			sourcesContent: options.includeContent ? [this.original] : void 0,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
		};
	}
	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}
	_ensureindentStr() {
		if (this.indentStr === void 0) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;
		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = void 0;
		}
		if (indentStr === void 0) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options = options || {};
		const isExcluded = {};
		if (options.exclude) (typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude).forEach((exclusion) => {
			for (let i$1 = exclusion[0]; i$1 < exclusion[1]; i$1 += 1) isExcluded[i$1] = true;
		});
		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
						else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
							else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;
		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}
		first.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, {
			...options,
			overwrite: !options.contentOnly
		});
	}
	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range  use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options = { storeName: true };
		}
		const storeName = options !== void 0 ? options.storeName : false;
		const overwrite = options !== void 0 ? options.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first = this.byStart[start];
		const last = this.byEnd[end];
		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
		else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
		else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);
		return clone;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		let previousChunk = chunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
			if (chunk === previousChunk) return;
			previousChunk = chunk;
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column}  "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_$1, i$1) => {
				if (i$1 === "$") return "$";
				if (i$1 === "&") return match[0];
				if (+i$1 < match.length) return match[+i$1];
				return `$${i$1}`;
			});
			else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while (match = re.exec(str)) matches.push(match);
			return matches;
		}
		if (searchValue.global) matchAll(searchValue, this.original).forEach((match) => {
			if (match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		});
		else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		}
		return this;
	}
	_replaceString(string$5, replacement) {
		const { original } = this;
		const index = original.indexOf(string$5);
		if (index !== -1) {
			if (typeof replacement === "function") replacement = replacement(string$5, index, original);
			if (string$5 !== replacement) this.overwrite(index, index + string$5.length, replacement);
		}
		return this;
	}
	replace(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
		return this._replaceRegexp(searchValue, replacement);
	}
	_replaceAllString(string$5, replacement) {
		const { original } = this;
		const stringLength = string$5.length;
		for (let index = original.indexOf(string$5); index !== -1; index = original.indexOf(string$5, index + stringLength)) {
			const previous = original.slice(index, index + stringLength);
			let _replacement = replacement;
			if (typeof replacement === "function") _replacement = replacement(previous, index, original);
			if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
		}
		return this;
	}
	replaceAll(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
		if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
		return this._replaceRegexp(searchValue, replacement);
	}
};

//#endregion
//#region ../core/tooling/parsers.ts
function parseScript(source) {
	const ast = parseScript$1(source);
	const generateCode = () => serializeScript(ast, source);
	return {
		ast,
		source,
		generateCode
	};
}
function parseCss(source) {
	const ast = parseCss$1(source);
	const generateCode = () => ast.toString();
	return {
		ast,
		source,
		generateCode
	};
}
function parseHtml(source) {
	const ast = parseHtml$1(source);
	const generateCode = () => serializeHtml(ast);
	return {
		ast,
		source,
		generateCode
	};
}
function parseJson(source) {
	if (!source) source = "{}";
	const data$1 = parseJson$1(source);
	const generateCode = () => serializeJson(source, data$1);
	return {
		data: data$1,
		source,
		generateCode
	};
}
function parseYaml(source) {
	if (!source) source = "";
	const data$1 = parseYaml$1(source);
	const generateCode = () => serializeYaml(data$1);
	return {
		data: data$1,
		source,
		generateCode
	};
}
function parseSvelte(source, options) {
	const scripts = extractScripts(source);
	const { tag: scriptTag = "", src: scriptSource = "" } = scripts.find(({ attrs }) => !attrs.includes("module")) ?? {};
	const { tag: moduleScriptTag = "", src: moduleSource = "" } = scripts.find(({ attrs }) => attrs.includes("module")) ?? {};
	const { styleTag, cssSource } = extractStyle(source);
	const templateSource = source.replace(moduleScriptTag, "").replace(scriptTag, "").replace(styleTag, "").trim();
	const script = parseScript(scriptSource);
	const module$1 = parseScript(moduleSource);
	const css = parseCss(cssSource);
	const template = parseHtml(templateSource);
	const generateCode = (code) => {
		const ms = new MagicString(source);
		if (code.script !== void 0) if (scriptSource.length === 0) {
			const ts = options?.typescript ? " lang=\"ts\"" : "";
			const indented = code.script.split("\n").join("\n	");
			const script$1 = `<script${ts}>\n\t${indented}\n<\/script>\n\n`;
			ms.prepend(script$1);
		} else {
			const { start, end } = locations(source, scriptSource);
			const formatted = indent(code.script, ms.getIndentString());
			ms.update(start, end, formatted);
		}
		if (code.module !== void 0) if (moduleSource.length === 0) {
			const ts = options?.typescript ? " lang=\"ts\"" : "";
			const indented = code.module.split("\n").join("\n	");
			const module$2 = `<script${ts} context="module">\n\t${indented}\n<\/script>\n\n`;
			ms.prepend(module$2);
		} else {
			const { start, end } = locations(source, moduleSource);
			const formatted = indent(code.module, ms.getIndentString());
			ms.update(start, end, formatted);
		}
		if (code.css !== void 0) if (cssSource.length === 0) {
			const style = `\n<style>\n\t${code.css.split("\n").join("\n	")}\n</style>\n`;
			ms.append(style);
		} else {
			const { start, end } = locations(source, cssSource);
			const formatted = indent(code.css, ms.getIndentString());
			ms.update(start, end, formatted);
		}
		if (code.template !== void 0) if (templateSource.length === 0) ms.appendLeft(0, code.template);
		else {
			const { start, end } = locations(source, templateSource);
			ms.update(start, end, code.template);
		}
		return ms.toString();
	};
	return {
		script: {
			...script,
			source: scriptSource
		},
		module: {
			...module$1,
			source: moduleSource
		},
		css: {
			...css,
			source: cssSource
		},
		template: {
			...template,
			source: templateSource
		},
		generateCode
	};
}
function locations(source, search) {
	const start = source.indexOf(search);
	const end = start + search.length;
	return {
		start,
		end
	};
}
function indent(content, indent$2) {
	return `\n${indent$2 + content.split("\n").join(`\n${indent$2}`)}\n`;
}
const regexScriptTags = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/;
const regexStyleTags = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/;
function extractScripts(source) {
	const scripts = [];
	const [tag = "", attrs = "", src = ""] = regexScriptTags.exec(source) ?? [];
	if (tag) {
		const stripped = source.replace(tag, "");
		scripts.push({
			tag,
			attrs,
			src
		}, ...extractScripts(stripped));
		return scripts;
	}
	return [];
}
function extractStyle(source) {
	const [styleTag = "", attributes = "", cssSource = ""] = regexStyleTags.exec(source) ?? [];
	return {
		styleTag,
		attributes,
		cssSource
	};
}

//#endregion
//#region ../../node_modules/.pnpm/package-manager-detector@0.2.11/node_modules/package-manager-detector/dist/commands.mjs
function npmRun(agent) {
	return (args) => {
		if (args.length > 1) return [
			agent,
			"run",
			args[0],
			"--",
			...args.slice(1)
		];
		else return [
			agent,
			"run",
			args[0]
		];
	};
}
function denoExecute() {
	return (args) => {
		return [
			"deno",
			"run",
			`npm:${args[0]}`,
			...args.slice(1)
		];
	};
}
const npm = {
	"agent": ["npm", 0],
	"run": npmRun("npm"),
	"install": [
		"npm",
		"i",
		0
	],
	"frozen": [
		"npm",
		"ci",
		0
	],
	"global": [
		"npm",
		"i",
		"-g",
		0
	],
	"add": [
		"npm",
		"i",
		0
	],
	"upgrade": [
		"npm",
		"update",
		0
	],
	"upgrade-interactive": null,
	"execute": ["npx", 0],
	"execute-local": ["npx", 0],
	"uninstall": [
		"npm",
		"uninstall",
		0
	],
	"global_uninstall": [
		"npm",
		"uninstall",
		"-g",
		0
	]
};
const yarn = {
	"agent": ["yarn", 0],
	"run": [
		"yarn",
		"run",
		0
	],
	"install": [
		"yarn",
		"install",
		0
	],
	"frozen": [
		"yarn",
		"install",
		"--frozen-lockfile",
		0
	],
	"global": [
		"yarn",
		"global",
		"add",
		0
	],
	"add": [
		"yarn",
		"add",
		0
	],
	"upgrade": [
		"yarn",
		"upgrade",
		0
	],
	"upgrade-interactive": [
		"yarn",
		"upgrade-interactive",
		0
	],
	"execute": ["npx", 0],
	"execute-local": [
		"yarn",
		"exec",
		0
	],
	"uninstall": [
		"yarn",
		"remove",
		0
	],
	"global_uninstall": [
		"yarn",
		"global",
		"remove",
		0
	]
};
const yarnBerry = {
	...yarn,
	"frozen": [
		"yarn",
		"install",
		"--immutable",
		0
	],
	"upgrade": [
		"yarn",
		"up",
		0
	],
	"upgrade-interactive": [
		"yarn",
		"up",
		"-i",
		0
	],
	"execute": [
		"yarn",
		"dlx",
		0
	],
	"execute-local": [
		"yarn",
		"exec",
		0
	],
	"global": [
		"npm",
		"i",
		"-g",
		0
	],
	"global_uninstall": [
		"npm",
		"uninstall",
		"-g",
		0
	]
};
const pnpm = {
	"agent": ["pnpm", 0],
	"run": [
		"pnpm",
		"run",
		0
	],
	"install": [
		"pnpm",
		"i",
		0
	],
	"frozen": [
		"pnpm",
		"i",
		"--frozen-lockfile",
		0
	],
	"global": [
		"pnpm",
		"add",
		"-g",
		0
	],
	"add": [
		"pnpm",
		"add",
		0
	],
	"upgrade": [
		"pnpm",
		"update",
		0
	],
	"upgrade-interactive": [
		"pnpm",
		"update",
		"-i",
		0
	],
	"execute": [
		"pnpm",
		"dlx",
		0
	],
	"execute-local": [
		"pnpm",
		"exec",
		0
	],
	"uninstall": [
		"pnpm",
		"remove",
		0
	],
	"global_uninstall": [
		"pnpm",
		"remove",
		"--global",
		0
	]
};
const bun = {
	"agent": ["bun", 0],
	"run": [
		"bun",
		"run",
		0
	],
	"install": [
		"bun",
		"install",
		0
	],
	"frozen": [
		"bun",
		"install",
		"--frozen-lockfile",
		0
	],
	"global": [
		"bun",
		"add",
		"-g",
		0
	],
	"add": [
		"bun",
		"add",
		0
	],
	"upgrade": [
		"bun",
		"update",
		0
	],
	"upgrade-interactive": [
		"bun",
		"update",
		0
	],
	"execute": [
		"bun",
		"x",
		0
	],
	"execute-local": [
		"bun",
		"x",
		0
	],
	"uninstall": [
		"bun",
		"remove",
		0
	],
	"global_uninstall": [
		"bun",
		"remove",
		"-g",
		0
	]
};
const deno = {
	"agent": ["deno", 0],
	"run": [
		"deno",
		"task",
		0
	],
	"install": [
		"deno",
		"install",
		0
	],
	"frozen": [
		"deno",
		"install",
		"--frozen",
		0
	],
	"global": [
		"deno",
		"install",
		"-g",
		0
	],
	"add": [
		"deno",
		"add",
		0
	],
	"upgrade": [
		"deno",
		"outdated",
		"--update",
		0
	],
	"upgrade-interactive": [
		"deno",
		"outdated",
		"--update",
		0
	],
	"execute": denoExecute(),
	"execute-local": [
		"deno",
		"task",
		"--eval",
		0
	],
	"uninstall": [
		"deno",
		"remove",
		0
	],
	"global_uninstall": [
		"deno",
		"uninstall",
		"-g",
		0
	]
};
const COMMANDS = {
	"npm": npm,
	"yarn": yarn,
	"yarn@berry": yarnBerry,
	"pnpm": pnpm,
	"pnpm@6": {
		...pnpm,
		run: npmRun("pnpm")
	},
	"bun": bun,
	"deno": deno
};
function resolveCommand(agent, command, args) {
	const value = COMMANDS[agent][command];
	return constructCommand(value, args);
}
function constructCommand(value, args) {
	if (value == null) return null;
	const list$5 = typeof value === "function" ? value(args) : value.flatMap((v$2) => {
		if (typeof v$2 === "number") return args;
		return [v$2];
	});
	return {
		command: list$5[0],
		args: list$5.slice(1)
	};
}

//#endregion
//#region ../../node_modules/.pnpm/package-manager-detector@0.2.11/node_modules/package-manager-detector/dist/constants.mjs
const AGENTS = [
	"npm",
	"yarn",
	"yarn@berry",
	"pnpm",
	"pnpm@6",
	"bun",
	"deno"
];
const LOCKS = {
	"bun.lock": "bun",
	"bun.lockb": "bun",
	"deno.lock": "deno",
	"pnpm-lock.yaml": "pnpm",
	"yarn.lock": "yarn",
	"package-lock.json": "npm",
	"npm-shrinkwrap.json": "npm"
};

//#endregion
//#region ../../node_modules/.pnpm/quansync@0.2.11/node_modules/quansync/dist/index.mjs
const GET_IS_ASYNC = Symbol.for("quansync.getIsAsync");
var QuansyncError = class extends Error {
	constructor(message = "Unexpected promise in sync context") {
		super(message);
		this.name = "QuansyncError";
	}
};
function isThenable(value) {
	return value && typeof value === "object" && typeof value.then === "function";
}
function isQuansyncGenerator(value) {
	return value && typeof value === "object" && typeof value[Symbol.iterator] === "function" && "__quansync" in value;
}
function fromObject(options) {
	const generator = function* (...args) {
		if (yield GET_IS_ASYNC) return yield options.async.apply(this, args);
		return options.sync.apply(this, args);
	};
	function fn(...args) {
		const iter = generator.apply(this, args);
		iter.then = (...thenArgs) => options.async.apply(this, args).then(...thenArgs);
		iter.__quansync = true;
		return iter;
	}
	fn.sync = options.sync;
	fn.async = options.async;
	return fn;
}
function fromPromise(promise) {
	return fromObject({
		async: () => Promise.resolve(promise),
		sync: () => {
			if (isThenable(promise)) throw new QuansyncError();
			return promise;
		}
	});
}
function unwrapYield(value, isAsync) {
	if (value === GET_IS_ASYNC) return isAsync;
	if (isQuansyncGenerator(value)) return isAsync ? iterateAsync(value) : iterateSync(value);
	if (!isAsync && isThenable(value)) throw new QuansyncError();
	return value;
}
const DEFAULT_ON_YIELD = (value) => value;
function iterateSync(generator, onYield = DEFAULT_ON_YIELD) {
	let current = generator.next();
	while (!current.done) try {
		current = generator.next(unwrapYield(onYield(current.value, false)));
	} catch (err) {
		current = generator.throw(err);
	}
	return unwrapYield(current.value);
}
async function iterateAsync(generator, onYield = DEFAULT_ON_YIELD) {
	let current = generator.next();
	while (!current.done) try {
		current = generator.next(await unwrapYield(onYield(current.value, true), true));
	} catch (err) {
		current = generator.throw(err);
	}
	return current.value;
}
function fromGeneratorFn(generatorFn, options) {
	return fromObject({
		name: generatorFn.name,
		async(...args) {
			return iterateAsync(generatorFn.apply(this, args), options?.onYield);
		},
		sync(...args) {
			return iterateSync(generatorFn.apply(this, args), options?.onYield);
		}
	});
}
function quansync$1(input, options) {
	if (isThenable(input)) return fromPromise(input);
	if (typeof input === "function") return fromGeneratorFn(input, options);
	else return fromObject(input);
}
const getIsAsync = quansync$1({
	async: () => Promise.resolve(true),
	sync: () => false
});

//#endregion
//#region ../../node_modules/.pnpm/quansync@0.2.11/node_modules/quansync/dist/macro.mjs
const quansync = quansync$1;

//#endregion
//#region ../../node_modules/.pnpm/package-manager-detector@0.2.11/node_modules/package-manager-detector/dist/detect.mjs
const isFile = quansync({
	sync: (path2) => {
		try {
			return fs.statSync(path2).isFile();
		} catch {
			return false;
		}
	},
	async: async (path2) => {
		try {
			return (await fs.promises.stat(path2)).isFile();
		} catch {
			return false;
		}
	}
});
function* lookup(cwd$1 = process$1.cwd()) {
	let directory = path.resolve(cwd$1);
	const { root: root$1 } = path.parse(directory);
	while (directory && directory !== root$1) {
		yield directory;
		directory = path.dirname(directory);
	}
}
const parsePackageJson = quansync(function* (filepath, onUnknown) {
	return !filepath || !(yield isFile(filepath)) ? null : handlePackageManager(filepath, onUnknown);
});
const detect = quansync(function* (options = {}) {
	const { cwd: cwd$1, onUnknown } = options;
	for (const directory of lookup(cwd$1)) {
		for (const lock of Object.keys(LOCKS)) if (yield isFile(path.join(directory, lock))) {
			const name = LOCKS[lock];
			const result2 = yield parsePackageJson(path.join(directory, "package.json"), onUnknown);
			if (result2) return result2;
			else return {
				name,
				agent: name
			};
		}
		const result = yield parsePackageJson(path.join(directory, "package.json"), onUnknown);
		if (result) return result;
	}
	return null;
});
const detectSync = detect.sync;
function handlePackageManager(filepath, onUnknown) {
	try {
		const pkg = JSON.parse(fs.readFileSync(filepath, "utf8"));
		let agent;
		if (typeof pkg.packageManager === "string") {
			const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
			let version$1 = ver;
			if (name === "yarn" && Number.parseInt(ver) > 1) {
				agent = "yarn@berry";
				version$1 = "berry";
				return {
					name,
					agent,
					version: version$1
				};
			} else if (name === "pnpm" && Number.parseInt(ver) < 7) {
				agent = "pnpm@6";
				return {
					name,
					agent,
					version: version$1
				};
			} else if (AGENTS.includes(name)) {
				agent = name;
				return {
					name,
					agent,
					version: version$1
				};
			} else return onUnknown?.(pkg.packageManager) ?? null;
		}
	} catch {}
	return null;
}

//#endregion
//#region ../../node_modules/.pnpm/tinyexec@0.3.2/node_modules/tinyexec/dist/main.js
const require$1 = createRequire(import.meta.url);
var St = Object.create;
var $ = Object.defineProperty;
var kt = Object.getOwnPropertyDescriptor;
var Tt = Object.getOwnPropertyNames;
var At = Object.getPrototypeOf, Rt = Object.prototype.hasOwnProperty;
var h = /* @__PURE__ */ ((t) => typeof require$1 < "u" ? require$1 : typeof Proxy < "u" ? new Proxy(t, { get: (e$1, n$1) => (typeof require$1 < "u" ? require$1 : e$1)[n$1] }) : t)(function(t) {
	if (typeof require$1 < "u") return require$1.apply(this, arguments);
	throw Error("Dynamic require of \"" + t + "\" is not supported");
});
var l = (t, e$1) => () => (e$1 || t((e$1 = { exports: {} }).exports, e$1), e$1.exports);
var $t = (t, e$1, n$1, r) => {
	if (e$1 && typeof e$1 == "object" || typeof e$1 == "function") for (let s of Tt(e$1)) !Rt.call(t, s) && s !== n$1 && $(t, s, {
		get: () => e$1[s],
		enumerable: !(r = kt(e$1, s)) || r.enumerable
	});
	return t;
};
var Nt = (t, e$1, n$1) => (n$1 = t != null ? St(At(t)) : {}, $t(e$1 || !t || !t.__esModule ? $(n$1, "default", {
	value: t,
	enumerable: !0
}) : n$1, t));
var W = l((Se, H$2) => {
	H$2.exports = z;
	z.sync = Wt;
	var j$2 = h("fs");
	function Ht(t, e$1) {
		var n$1 = e$1.pathExt !== void 0 ? e$1.pathExt : process.env.PATHEXT;
		if (!n$1 || (n$1 = n$1.split(";"), n$1.indexOf("") !== -1)) return !0;
		for (var r = 0; r < n$1.length; r++) {
			var s = n$1[r].toLowerCase();
			if (s && t.substr(-s.length).toLowerCase() === s) return !0;
		}
		return !1;
	}
	function F$1(t, e$1, n$1) {
		return !t.isSymbolicLink() && !t.isFile() ? !1 : Ht(e$1, n$1);
	}
	function z(t, e$1, n$1) {
		j$2.stat(t, function(r, s) {
			n$1(r, r ? !1 : F$1(s, t, e$1));
		});
	}
	function Wt(t, e$1) {
		return F$1(j$2.statSync(t), t, e$1);
	}
});
var X = l((ke$1, B$2) => {
	B$2.exports = K$2;
	K$2.sync = Dt;
	var D$1 = h("fs");
	function K$2(t, e$1, n$1) {
		D$1.stat(t, function(r, s) {
			n$1(r, r ? !1 : M$1(s, e$1));
		});
	}
	function Dt(t, e$1) {
		return M$1(D$1.statSync(t), e$1);
	}
	function M$1(t, e$1) {
		return t.isFile() && Kt(t, e$1);
	}
	function Kt(t, e$1) {
		var n$1 = t.mode, r = t.uid, s = t.gid, o$1 = e$1.uid !== void 0 ? e$1.uid : process.getuid && process.getuid(), i$1 = e$1.gid !== void 0 ? e$1.gid : process.getgid && process.getgid(), a = parseInt("100", 8), c$2 = parseInt("010", 8), u = parseInt("001", 8), f$2 = a | c$2;
		return n$1 & u || n$1 & c$2 && s === i$1 || n$1 & a && r === o$1 || n$1 & f$2 && o$1 === 0;
	}
});
var U = l((Ae, G$1) => {
	h("fs");
	var v$2;
	process.platform === "win32" || global.TESTING_WINDOWS ? v$2 = W() : v$2 = X();
	G$1.exports = y;
	y.sync = Mt;
	function y(t, e$1, n$1) {
		if (typeof e$1 == "function" && (n$1 = e$1, e$1 = {}), !n$1) {
			if (typeof Promise != "function") throw new TypeError("callback not provided");
			return new Promise(function(r, s) {
				y(t, e$1 || {}, function(o$1, i$1) {
					o$1 ? s(o$1) : r(i$1);
				});
			});
		}
		v$2(t, e$1 || {}, function(r, s) {
			r && (r.code === "EACCES" || e$1 && e$1.ignoreErrors) && (r = null, s = !1), n$1(r, s);
		});
	}
	function Mt(t, e$1) {
		try {
			return v$2.sync(t, e$1 || {});
		} catch (n$1) {
			if (e$1 && e$1.ignoreErrors || n$1.code === "EACCES") return !1;
			throw n$1;
		}
	}
});
var et = l((Re, tt) => {
	var g$1 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Y$1 = h("path"), Bt = g$1 ? ";" : ":", V$1 = U(), J$2 = (t) => Object.assign(/* @__PURE__ */ new Error(`not found: ${t}`), { code: "ENOENT" }), Q$1 = (t, e$1) => {
		let n$1 = e$1.colon || Bt, r = t.match(/\//) || g$1 && t.match(/\\/) ? [""] : [...g$1 ? [process.cwd()] : [], ...(e$1.path || process.env.PATH || "").split(n$1)], s = g$1 ? e$1.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o$1 = g$1 ? s.split(n$1) : [""];
		return g$1 && t.indexOf(".") !== -1 && o$1[0] !== "" && o$1.unshift(""), {
			pathEnv: r,
			pathExt: o$1,
			pathExtExe: s
		};
	}, Z$1 = (t, e$1, n$1) => {
		typeof e$1 == "function" && (n$1 = e$1, e$1 = {}), e$1 || (e$1 = {});
		let { pathEnv: r, pathExt: s, pathExtExe: o$1 } = Q$1(t, e$1), i$1 = [], a = (u) => new Promise((f$2, p$2) => {
			if (u === r.length) return e$1.all && i$1.length ? f$2(i$1) : p$2(J$2(t));
			let d$1 = r[u], w$1 = /^".*"$/.test(d$1) ? d$1.slice(1, -1) : d$1, m$1 = Y$1.join(w$1, t), b$1 = !w$1 && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + m$1 : m$1;
			f$2(c$2(b$1, u, 0));
		}), c$2 = (u, f$2, p$2) => new Promise((d$1, w$1) => {
			if (p$2 === s.length) return d$1(a(f$2 + 1));
			let m$1 = s[p$2];
			V$1(u + m$1, { pathExt: o$1 }, (b$1, Ot) => {
				if (!b$1 && Ot) if (e$1.all) i$1.push(u + m$1);
				else return d$1(u + m$1);
				return d$1(c$2(u, f$2, p$2 + 1));
			});
		});
		return n$1 ? a(0).then((u) => n$1(null, u), n$1) : a(0);
	}, Xt = (t, e$1) => {
		e$1 = e$1 || {};
		let { pathEnv: n$1, pathExt: r, pathExtExe: s } = Q$1(t, e$1), o$1 = [];
		for (let i$1 = 0; i$1 < n$1.length; i$1++) {
			let a = n$1[i$1], c$2 = /^".*"$/.test(a) ? a.slice(1, -1) : a, u = Y$1.join(c$2, t), f$2 = !c$2 && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + u : u;
			for (let p$2 = 0; p$2 < r.length; p$2++) {
				let d$1 = f$2 + r[p$2];
				try {
					if (V$1.sync(d$1, { pathExt: s })) if (e$1.all) o$1.push(d$1);
					else return d$1;
				} catch {}
			}
		}
		if (e$1.all && o$1.length) return o$1;
		if (e$1.nothrow) return null;
		throw J$2(t);
	};
	tt.exports = Z$1;
	Z$1.sync = Xt;
});
var rt = l(($e$1, _$1) => {
	var nt = (t = {}) => {
		let e$1 = t.env || process.env;
		return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e$1).reverse().find((r) => r.toUpperCase() === "PATH") || "Path";
	};
	_$1.exports = nt;
	_$1.exports.default = nt;
});
var ct = l((Ne$1, it) => {
	var st = h("path"), Gt = et(), Ut = rt();
	function ot(t, e$1) {
		let n$1 = t.options.env || process.env, r = process.cwd(), s = t.options.cwd != null, o$1 = s && process.chdir !== void 0 && !process.chdir.disabled;
		if (o$1) try {
			process.chdir(t.options.cwd);
		} catch {}
		let i$1;
		try {
			i$1 = Gt.sync(t.command, {
				path: n$1[Ut({ env: n$1 })],
				pathExt: e$1 ? st.delimiter : void 0
			});
		} catch {} finally {
			o$1 && process.chdir(r);
		}
		return i$1 && (i$1 = st.resolve(s ? t.options.cwd : "", i$1)), i$1;
	}
	function Yt(t) {
		return ot(t) || ot(t, !0);
	}
	it.exports = Yt;
});
var ut = l((qe$1, P$2) => {
	var C$1 = /([()\][%!^"`<>&|;, *?])/g;
	function Vt(t) {
		return t = t.replace(C$1, "^$1"), t;
	}
	function Jt(t, e$1) {
		return t = `${t}`, t = t.replace(/(\\*)"/g, "$1$1\\\""), t = t.replace(/(\\*)$/, "$1$1"), t = `"${t}"`, t = t.replace(C$1, "^$1"), e$1 && (t = t.replace(C$1, "^$1")), t;
	}
	P$2.exports.command = Vt;
	P$2.exports.argument = Jt;
});
var lt = l((Ie, at) => {
	at.exports = /^#!(.*)/;
});
var dt = l((Le$1, pt) => {
	var Qt = lt();
	pt.exports = (t = "") => {
		let e$1 = t.match(Qt);
		if (!e$1) return null;
		let [n$1, r] = e$1[0].replace(/#! ?/, "").split(" "), s = n$1.split("/").pop();
		return s === "env" ? r : r ? `${s} ${r}` : s;
	};
});
var ht = l((je$1, ft) => {
	var O$2 = h("fs"), Zt = dt();
	function te(t) {
		let n$1 = Buffer.alloc(150), r;
		try {
			r = O$2.openSync(t, "r"), O$2.readSync(r, n$1, 0, 150, 0), O$2.closeSync(r);
		} catch {}
		return Zt(n$1.toString());
	}
	ft.exports = te;
});
var wt = l((Fe$1, Et) => {
	var ee = h("path"), mt = ct(), gt = ut(), ne$1 = ht(), re = process.platform === "win32", se = /\.(?:com|exe)$/i, oe$1 = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
	function ie$1(t) {
		t.file = mt(t);
		let e$1 = t.file && ne$1(t.file);
		return e$1 ? (t.args.unshift(t.file), t.command = e$1, mt(t)) : t.file;
	}
	function ce$1(t) {
		if (!re) return t;
		let e$1 = ie$1(t), n$1 = !se.test(e$1);
		if (t.options.forceShell || n$1) {
			let r = oe$1.test(e$1);
			t.command = ee.normalize(t.command), t.command = gt.command(t.command), t.args = t.args.map((o$1) => gt.argument(o$1, r));
			t.args = [
				"/d",
				"/s",
				"/c",
				`"${[t.command].concat(t.args).join(" ")}"`
			], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = !0;
		}
		return t;
	}
	function ue$1(t, e$1, n$1) {
		e$1 && !Array.isArray(e$1) && (n$1 = e$1, e$1 = null), e$1 = e$1 ? e$1.slice(0) : [], n$1 = Object.assign({}, n$1);
		let r = {
			command: t,
			args: e$1,
			options: n$1,
			file: void 0,
			original: {
				command: t,
				args: e$1
			}
		};
		return n$1.shell ? r : ce$1(r);
	}
	Et.exports = ue$1;
});
var bt = l((ze$1, vt) => {
	var S$1 = process.platform === "win32";
	function k$2(t, e$1) {
		return Object.assign(/* @__PURE__ */ new Error(`${e$1} ${t.command} ENOENT`), {
			code: "ENOENT",
			errno: "ENOENT",
			syscall: `${e$1} ${t.command}`,
			path: t.command,
			spawnargs: t.args
		});
	}
	function ae$1(t, e$1) {
		if (!S$1) return;
		let n$1 = t.emit;
		t.emit = function(r, s) {
			if (r === "exit") {
				let o$1 = xt(s, e$1, "spawn");
				if (o$1) return n$1.call(t, "error", o$1);
			}
			return n$1.apply(t, arguments);
		};
	}
	function xt(t, e$1) {
		return S$1 && t === 1 && !e$1.file ? k$2(e$1.original, "spawn") : null;
	}
	function le$1(t, e$1) {
		return S$1 && t === 1 && !e$1.file ? k$2(e$1.original, "spawnSync") : null;
	}
	vt.exports = {
		hookChildProcess: ae$1,
		verifyENOENT: xt,
		verifyENOENTSync: le$1,
		notFoundError: k$2
	};
});
var Ct = l((He$1, E$2) => {
	var yt = h("child_process"), T$2 = wt(), A = bt();
	function _t(t, e$1, n$1) {
		let r = T$2(t, e$1, n$1), s = yt.spawn(r.command, r.args, r.options);
		return A.hookChildProcess(s, r), s;
	}
	function pe$1(t, e$1, n$1) {
		let r = T$2(t, e$1, n$1), s = yt.spawnSync(r.command, r.args, r.options);
		return s.error = s.error || A.verifyENOENTSync(s.status, r), s;
	}
	E$2.exports = _t;
	E$2.exports.spawn = _t;
	E$2.exports.sync = pe$1;
	E$2.exports._parse = T$2;
	E$2.exports._enoent = A;
});
var Lt = /^path$/i, q = {
	key: "PATH",
	value: ""
};
function jt(t) {
	for (let e$1 in t) {
		if (!Object.prototype.hasOwnProperty.call(t, e$1) || !Lt.test(e$1)) continue;
		let n$1 = t[e$1];
		return n$1 ? {
			key: e$1,
			value: n$1
		} : q;
	}
	return q;
}
function Ft(t, e$1) {
	let n$1 = e$1.value.split(delimiter), r = t, s;
	do
		n$1.push(resolve$1(r, "node_modules", ".bin")), s = r, r = dirname$1(r);
	while (r !== s);
	return {
		key: e$1.key,
		value: n$1.join(delimiter)
	};
}
function I(t, e$1) {
	let n$1 = {
		...process.env,
		...e$1
	}, r = Ft(t, jt(n$1));
	return n$1[r.key] = r.value, n$1;
}
var L = (t) => {
	let e$1 = t.length, n$1 = new PassThrough(), r = () => {
		--e$1 === 0 && n$1.emit("end");
	};
	for (let s of t) s.pipe(n$1, { end: !1 }), s.on("end", r);
	return n$1;
};
var Pt = Nt(Ct(), 1);
var x = class extends Error {
	result;
	output;
	get exitCode() {
		if (this.result.exitCode !== null) return this.result.exitCode;
	}
	constructor(e$1, n$1) {
		super(`Process exited with non-zero status (${e$1.exitCode})`), this.result = e$1, this.output = n$1;
	}
};
var ge = {
	timeout: void 0,
	persist: !1
}, Ee = { windowsHide: !0 };
function we(t, e$1) {
	return {
		command: normalize(t),
		args: e$1 ?? []
	};
}
function xe(t) {
	let e$1 = new AbortController();
	for (let n$1 of t) {
		if (n$1.aborted) return e$1.abort(), n$1;
		let r = () => {
			e$1.abort(n$1.reason);
		};
		n$1.addEventListener("abort", r, { signal: e$1.signal });
	}
	return e$1.signal;
}
var R = class {
	_process;
	_aborted = !1;
	_options;
	_command;
	_args;
	_resolveClose;
	_processClosed;
	_thrownError;
	get process() {
		return this._process;
	}
	get pid() {
		return this._process?.pid;
	}
	get exitCode() {
		if (this._process && this._process.exitCode !== null) return this._process.exitCode;
	}
	constructor(e$1, n$1, r) {
		this._options = {
			...ge,
			...r
		}, this._command = e$1, this._args = n$1 ?? [], this._processClosed = new Promise((s) => {
			this._resolveClose = s;
		});
	}
	kill(e$1) {
		return this._process?.kill(e$1) === !0;
	}
	get aborted() {
		return this._aborted;
	}
	get killed() {
		return this._process?.killed === !0;
	}
	pipe(e$1, n$1, r) {
		return be(e$1, n$1, {
			...r,
			stdin: this
		});
	}
	async *[Symbol.asyncIterator]() {
		let e$1 = this._process;
		if (!e$1) return;
		let n$1 = [];
		this._streamErr && n$1.push(this._streamErr), this._streamOut && n$1.push(this._streamOut);
		let r = L(n$1), s = me.createInterface({ input: r });
		for await (let o$1 of s) yield o$1.toString();
		if (await this._processClosed, e$1.removeAllListeners(), this._thrownError) throw this._thrownError;
		if (this._options?.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0) throw new x(this);
	}
	async _waitForOutput() {
		let e$1 = this._process;
		if (!e$1) throw new Error("No process was started");
		let n$1 = "", r = "";
		if (this._streamOut) for await (let o$1 of this._streamOut) r += o$1.toString();
		if (this._streamErr) for await (let o$1 of this._streamErr) n$1 += o$1.toString();
		if (await this._processClosed, this._options?.stdin && await this._options.stdin, e$1.removeAllListeners(), this._thrownError) throw this._thrownError;
		let s = {
			stderr: n$1,
			stdout: r,
			exitCode: this.exitCode
		};
		if (this._options.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0) throw new x(this, s);
		return s;
	}
	then(e$1, n$1) {
		return this._waitForOutput().then(e$1, n$1);
	}
	_streamOut;
	_streamErr;
	spawn() {
		let e$1 = cwd(), n$1 = this._options, r = {
			...Ee,
			...n$1.nodeOptions
		}, s = [];
		this._resetState(), n$1.timeout !== void 0 && s.push(AbortSignal.timeout(n$1.timeout)), n$1.signal !== void 0 && s.push(n$1.signal), n$1.persist === !0 && (r.detached = !0), s.length > 0 && (r.signal = xe(s)), r.env = I(e$1, r.env);
		let { command: o$1, args: i$1 } = we(this._command, this._args), a = (0, Pt._parse)(o$1, i$1, r), c$2 = spawn(a.command, a.args, a.options);
		if (c$2.stderr && (this._streamErr = c$2.stderr), c$2.stdout && (this._streamOut = c$2.stdout), this._process = c$2, c$2.once("error", this._onError), c$2.once("close", this._onClose), n$1.stdin !== void 0 && c$2.stdin && n$1.stdin.process) {
			let { stdout: u } = n$1.stdin.process;
			u && u.pipe(c$2.stdin);
		}
	}
	_resetState() {
		this._aborted = !1, this._processClosed = new Promise((e$1) => {
			this._resolveClose = e$1;
		}), this._thrownError = void 0;
	}
	_onError = (e$1) => {
		if (e$1.name === "AbortError" && (!(e$1.cause instanceof Error) || e$1.cause.name !== "TimeoutError")) {
			this._aborted = !0;
			return;
		}
		this._thrownError = e$1;
	};
	_onClose = () => {
		this._resolveClose && this._resolveClose();
	};
}, ve = (t, e$1, n$1) => {
	let r = new R(t, e$1, n$1);
	return r.spawn(), r;
}, be = ve;

//#endregion
//#region utils/package-manager.ts
const AGENT_NAMES = AGENTS.filter((agent) => !agent.includes("@"));
const agentOptions = AGENT_NAMES.map((pm) => ({
	value: pm,
	label: pm
}));
agentOptions.unshift({
	label: "None",
	value: void 0
});
const installOption = new Option("--install <package-manager>", "installs dependencies with a specified package manager").choices(AGENT_NAMES);
async function packageManagerPrompt(cwd$1) {
	const agent = (await detect({ cwd: cwd$1 }))?.name ?? getUserAgent();
	if (!process$1.stdout.isTTY) return agent;
	const pm = await ze({
		message: "Which package manager do you want to install dependencies with?",
		options: agentOptions,
		initialValue: agent
	});
	if (Vu(pm)) {
		De("Operation cancelled.");
		process$1.exit(1);
	}
	return pm;
}
async function installDependencies(agent, cwd$1) {
	const task = Ze({
		title: `Installing dependencies with ${agent}...`,
		limit: Math.ceil(process$1.stdout.rows / 2),
		spacing: 0,
		retainLog: true
	});
	try {
		const { command, args } = constructCommand(COMMANDS[agent].install, []);
		const proc = be(command, args, {
			nodeOptions: {
				cwd: cwd$1,
				stdio: "pipe"
			},
			throwOnError: true
		});
		for await (const line of proc) task.message(line, { raw: true });
		task.success("Successfully installed dependencies");
	} catch {
		task.error("Failed to install dependencies");
		De("Operation failed.");
		process$1.exit(2);
	}
}
function getUserAgent() {
	const userAgent = process$1.env.npm_config_user_agent;
	if (!userAgent) return void 0;
	const pmSpec = userAgent.split(" ")[0];
	const separatorPos = pmSpec.lastIndexOf("/");
	const name = pmSpec.substring(0, separatorPos);
	return AGENTS.includes(name) ? name : void 0;
}
async function addPnpmBuildDependencies(cwd$1, packageManager, allowedPackages) {
	if (!packageManager || packageManager !== "pnpm" || allowedPackages.length === 0) return;
	let confIn = "package.json";
	const pnpmVersion = await getPnpmVersion();
	if (pnpmVersion) confIn = isVersionUnsupportedBelow(pnpmVersion, "10.5") ? "package.json" : "pnpm-workspace.yaml";
	const found = up("pnpm-workspace.yaml", { cwd: cwd$1 });
	if (confIn === "pnpm-workspace.yaml") {
		const content = found ? fs.readFileSync(found, "utf-8") : "";
		const { data: data$1, generateCode } = parseYaml(content);
		const items = data$1.get("onlyBuiltDependencies")?.items ?? [];
		for (const item of allowedPackages) {
			if (items.includes(item)) continue;
			if (items.some((y) => typeof y === "object" && y.value === item)) continue;
			items.push(item);
		}
		data$1.set("onlyBuiltDependencies", items);
		const newContent = generateCode();
		const pnpmWorkspacePath = found ?? path.join(cwd$1, "pnpm-workspace.yaml");
		if (newContent !== content) fs.writeFileSync(pnpmWorkspacePath, newContent, "utf-8");
	} else {
		const rootDir = found ? path.dirname(found) : cwd$1;
		const pkgPath = path.join(rootDir, "package.json");
		const content = fs.readFileSync(pkgPath, "utf-8");
		const { data: data$1, generateCode } = parseJson(content);
		data$1.pnpm ??= {};
		data$1.pnpm.onlyBuiltDependencies ??= [];
		for (const allowedPackage of allowedPackages) {
			if (data$1.pnpm.onlyBuiltDependencies.includes(allowedPackage)) continue;
			data$1.pnpm.onlyBuiltDependencies.push(allowedPackage);
		}
		const newContent = generateCode();
		if (newContent !== content) fs.writeFileSync(pkgPath, newContent, "utf-8");
	}
}
async function getPnpmVersion() {
	let v$2 = void 0;
	try {
		v$2 = (await be("pnpm", ["--version"], { throwOnError: true })).stdout.trim();
	} catch {}
	return v$2;
}

//#endregion
//#region ../create/utils.ts
function mkdirp(dir) {
	try {
		fs.mkdirSync(dir, { recursive: true });
	} catch (err) {
		const e$1 = err;
		if (e$1.code === "EEXIST") return;
		throw e$1;
	}
}
function identity(x$3) {
	return x$3;
}
function copy(from$1, to, rename = identity) {
	if (!fs.existsSync(from$1)) return;
	if (fs.statSync(from$1).isDirectory()) fs.readdirSync(from$1).forEach((file) => {
		copy(path.join(from$1, file), path.join(to, rename(file)));
	});
	else {
		mkdirp(path.dirname(to));
		fs.copyFileSync(from$1, to);
	}
}
function dist(path$2) {
	const insideDistFolder = import.meta.url.includes("dist");
	return fileURLToPath(new URL(`./${!insideDistFolder ? "dist/" : ""}${path$2}`, import.meta.url).href);
}

//#endregion
//#region ../create/index.ts
const templateTypes = [
	"minimal",
	"demo",
	"library"
];
const languageTypes = [
	"typescript",
	"checkjs",
	"none"
];
function create(cwd$1, options) {
	mkdirp(cwd$1);
	write_template_files(options.template, options.types, options.name, cwd$1);
	write_common_files(cwd$1, options, options.name);
}
const templates = templateTypes.map((dir) => {
	const meta_file = dist(`templates/${dir}/meta.json`);
	const { title, description } = JSON.parse(fs.readFileSync(meta_file, "utf8"));
	return {
		name: dir,
		title,
		description
	};
});
function write_template_files(template, types$2, name, cwd$1) {
	const dir = dist(`templates/${template}`);
	copy(`${dir}/assets`, cwd$1, (name$1) => name$1.replace("DOT-", "."));
	copy(`${dir}/package.json`, `${cwd$1}/package.json`);
	const manifest = `${dir}/files.types=${types$2}.json`;
	JSON.parse(fs.readFileSync(manifest, "utf-8")).forEach((file) => {
		const dest = path.join(cwd$1, file.name);
		mkdirp(path.dirname(dest));
		fs.writeFileSync(dest, file.contents.replace(/~TODO~/g, name));
	});
}
function write_common_files(cwd$1, options, name) {
	const shared$1 = dist("shared.json");
	const { files } = JSON.parse(fs.readFileSync(shared$1, "utf-8"));
	const pkg_file = path.join(cwd$1, "package.json");
	const pkg = JSON.parse(fs.readFileSync(pkg_file, "utf-8"));
	sort_files(files).forEach((file) => {
		const include = file.include.every((condition) => matches_condition(condition, options));
		if (file.exclude.some((condition) => matches_condition(condition, options)) || !include) return;
		if (file.name === "package.json") {
			const new_pkg = JSON.parse(file.contents);
			merge(pkg, new_pkg);
		} else {
			const dest = path.join(cwd$1, file.name);
			mkdirp(path.dirname(dest));
			fs.writeFileSync(dest, file.contents);
		}
	});
	pkg.dependencies = sort_keys(pkg.dependencies);
	pkg.devDependencies = sort_keys(pkg.devDependencies);
	pkg.name = to_valid_package_name(name);
	fs.writeFileSync(pkg_file, JSON.stringify(pkg, null, "	") + "\n");
}
function matches_condition(condition, options) {
	if (templateTypes.includes(condition)) return options.template === condition;
	if (languageTypes.includes(condition)) return options.types === condition;
	return Boolean(options[condition]);
}
function merge(target, source) {
	for (const key in source) if (key in target) {
		const target_value = target[key];
		const source_value = source[key];
		if (typeof source_value !== typeof target_value || Array.isArray(source_value) !== Array.isArray(target_value)) throw new Error("Mismatched values");
		if (typeof source_value === "object") merge(target_value, source_value);
		else target[key] = source_value;
	} else target[key] = source[key];
}
function sort_keys(obj) {
	if (!obj) return;
	const sorted = {};
	Object.keys(obj).sort().forEach((key) => {
		sorted[key] = obj[key];
	});
	return sorted;
}
/**
* Sort files so that those which apply more generically come first so they
* can be overwritten by files for more precise cases later.
*/
function sort_files(files) {
	return files.sort((f1, f2) => {
		const f1_more_generic = f1.include.every((include) => f2.include.includes(include)) && f1.exclude.every((exclude) => f2.exclude.includes(exclude));
		const f2_more_generic = f2.include.every((include) => f1.include.includes(include)) && f2.exclude.every((exclude) => f1.exclude.includes(exclude));
		return f1_more_generic && f2_more_generic || !f1_more_generic && !f2_more_generic ? 0 : f1_more_generic ? -1 : 1;
	});
}
function to_valid_package_name(name) {
	return name.trim().toLowerCase().replace(/\s+/g, "-").replace(/^[._]/, "").replace(/[^a-z0-9~.-]+/g, "-");
}

//#endregion
export { AGENT_NAMES, Command, De, Element, Fe, Ge, J, Ke, MagicString, Option, T, Tag, Ue, Vu, We, __commonJS, __require, __toESM, addPnpmBuildDependencies, any, be, create, createPrinter, dedent_default, defineAddon, defineAddonOptions, detect, et$1 as et, from, getUserAgent, import_picocolors, installDependencies, installOption, isVersionUnsupportedBelow, ke, packageManagerPrompt, parseCss, parseHtml, parseHtml$1, parseJson, parseScript, parseScript$1, parseSvelte, program, require_picocolors, resolveCommand, serializeScript, stripAst, templates, up, ve, walk, ze };