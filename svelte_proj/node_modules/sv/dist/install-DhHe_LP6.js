import { Element, MagicString, T, Tag, __toESM, any, be, createPrinter, dedent_default, defineAddon, defineAddonOptions, detect, getUserAgent, import_picocolors as import_picocolors$2, parseCss, parseHtml, parseHtml$1, parseJson, parseScript, parseScript$1, parseSvelte, require_picocolors, resolveCommand, serializeScript, stripAst, walk } from "./create-G_G45yBx.js";
import path from "node:path";
import fs from "node:fs";
import process from "node:process";

//#region ../../node_modules/.pnpm/decircular@1.0.0/node_modules/decircular/index.js
function decircular(object) {
	const seenObjects = /* @__PURE__ */ new WeakMap();
	function internalDecircular(value, path$1 = []) {
		if (!(value !== null && typeof value === "object")) return value;
		const existingPath = seenObjects.get(value);
		if (existingPath) return `[Circular *${existingPath.join(".")}]`;
		seenObjects.set(value, path$1);
		const newValue = Array.isArray(value) ? [] : {};
		for (const [key2, value2] of Object.entries(value)) newValue[key2] = internalDecircular(value2, [...path$1, key2]);
		seenObjects.delete(value);
		return newValue;
	}
	return internalDecircular(object);
}

//#endregion
//#region ../core/tooling/js/common.ts
function addJsDocTypeComment(node, options$6) {
	const comment = {
		type: "Block",
		value: `* @type {${options$6.type}} `
	};
	addComment(node, comment);
}
function addComment(node, comment) {
	node.leadingComments ??= [];
	if (!node.leadingComments.find((item) => item.type === "Block" && item.value === comment.value)) node.leadingComments.push(comment);
}
function createSpread(argument) {
	return {
		type: "SpreadElement",
		argument
	};
}
function createLiteral(value) {
	return {
		type: "Literal",
		value: value ?? null
	};
}
function areNodesEqual(node, otherNode) {
	const nodeClone = stripAst(decircular(node), ["loc", "raw"]);
	const otherNodeClone = stripAst(decircular(otherNode), ["loc", "raw"]);
	return serializeScript(nodeClone) === serializeScript(otherNodeClone);
}
function appendFromString(node, options$6) {
	const program = parseScript$1(dedent_default(options$6.code));
	for (const childNode of program.body) node.body.push(childNode);
}
function parseExpression(code) {
	const program = parseScript$1(dedent_default(code));
	stripAst(program, ["raw"]);
	const statement = program.body[0];
	if (statement.type !== "ExpressionStatement") throw new Error("Code provided was not an expression");
	return statement.expression;
}
function parseStatement(code) {
	return parseFromString(code);
}
function parseFromString(code) {
	return parseScript$1(dedent_default(code)).body[0];
}
/** Appends the statement to body of the block if it doesn't already exist */
function appendStatement(node, options$6) {
	if (!contains(node, options$6.statement)) node.body.push(options$6.statement);
}
/** Returns `true` if the provided node exists in the AST */
function contains(node, targetNode) {
	let found = false;
	walk(node, null, { _(currentNode, { next, stop }) {
		if (currentNode.type === targetNode.type) {
			found = areNodesEqual(currentNode, targetNode);
			if (found) stop();
		}
		next();
	} });
	return found;
}
function hasTypeProperty(node, options$6) {
	return node.type === "TSPropertySignature" && node.key.type === "Identifier" && node.key.name === options$6.name;
}

//#endregion
//#region ../core/tooling/js/array.ts
function create$1() {
	return {
		type: "ArrayExpression",
		elements: []
	};
}
function append(node, element) {
	insertElement(node, element, { insertEnd: true });
}
function prepend(node, element) {
	insertElement(node, element, { insertEnd: false });
}
function insertElement(node, element, options$6) {
	if (typeof element === "string") {
		let literal = node.elements.filter((item) => item !== null && item.type === "Literal").find((item) => item.value === element);
		if (!literal) {
			literal = {
				type: "Literal",
				value: element
			};
			if (options$6.insertEnd) node.elements.push(literal);
			else node.elements.unshift(literal);
		}
	} else if (!node.elements.some((item) => item && areNodesEqual(element, item))) if (options$6.insertEnd) node.elements.push(element);
	else node.elements.unshift(element);
}

//#endregion
//#region ../core/tooling/js/object.ts
function property(node, options$6) {
	return propertyNode(node, options$6).value;
}
function propertyNode(node, options$6) {
	let prop = node.properties.filter((x$1) => x$1.type === "Property").find((x$1) => x$1.key.name === options$6.name);
	if (!prop) {
		let isShorthand = false;
		if (options$6.fallback.type === "Identifier") isShorthand = options$6.fallback.name === options$6.name;
		prop = {
			type: "Property",
			shorthand: isShorthand,
			key: {
				type: "Identifier",
				name: options$6.name
			},
			value: options$6.fallback,
			kind: "init",
			computed: false,
			method: false
		};
		node.properties.push(prop);
	}
	return prop;
}
function create(properties) {
	return populateObjectExpression({
		objectExpression: {
			type: "ObjectExpression",
			properties: []
		},
		properties,
		override: false
	});
}
function overrideProperties(objectExpression, properties) {
	populateObjectExpression({
		objectExpression,
		properties,
		override: true
	});
}
function overrideProperty(node, options$6) {
	const prop = node.properties.filter((x$1) => x$1.type === "Property").find((x$1) => x$1.key.name === options$6.name);
	if (!prop) return property(node, {
		name: options$6.name,
		fallback: options$6.value
	});
	prop.value = options$6.value;
	return options$6.value;
}
function populateObjectExpression(options$6) {
	const getExpression = (value, existingExpression) => {
		let expression;
		if (Array.isArray(value)) {
			expression = create$1();
			for (const v of value) append(expression, getExpression(v));
		} else if (typeof value === "object" && value !== null) if (value.type !== void 0) expression = value;
		else if (options$6.override && existingExpression && existingExpression.type === "ObjectExpression") expression = populateObjectExpression({
			objectExpression: existingExpression,
			properties: value,
			override: options$6.override
		});
		else expression = populateObjectExpression({
			objectExpression: create({}),
			properties: value,
			override: options$6.override
		});
		else expression = createLiteral(value);
		return expression;
	};
	for (const [prop, value] of Object.entries(options$6.properties)) {
		if (value === void 0) continue;
		if (options$6.override) {
			const existingProperty = options$6.objectExpression.properties.filter((x$1) => x$1.type === "Property").find((x$1) => x$1.key.name === prop);
			const existingExpression = existingProperty?.value.type === "ObjectExpression" ? existingProperty.value : void 0;
			overrideProperty(options$6.objectExpression, {
				name: prop,
				value: getExpression(value, existingExpression)
			});
		} else property(options$6.objectExpression, {
			name: prop,
			fallback: getExpression(value)
		});
	}
	return options$6.objectExpression;
}

//#endregion
//#region ../core/tooling/js/function.ts
function createCall(options$6) {
	const callExpression = {
		type: "CallExpression",
		callee: {
			type: "Identifier",
			name: options$6.name
		},
		arguments: [],
		optional: false
	};
	for (const arg of options$6.args) {
		let argNode;
		if (options$6.useIdentifiers) argNode = {
			type: "Identifier",
			name: arg
		};
		else argNode = {
			type: "Literal",
			value: arg
		};
		callExpression.arguments.push(argNode);
	}
	return callExpression;
}
function getArgument(node, options$6) {
	if (options$6.index < node.arguments.length) return node.arguments[options$6.index];
	node.arguments.push(options$6.fallback);
	return options$6.fallback;
}

//#endregion
//#region ../core/tooling/js/imports.ts
function addEmpty(node, options$6) {
	const expectedImportDeclaration = {
		type: "ImportDeclaration",
		source: {
			type: "Literal",
			value: options$6.from
		},
		specifiers: [],
		attributes: [],
		importKind: "value"
	};
	addImportIfNecessary(node, expectedImportDeclaration);
}
function addNamespace(node, options$6) {
	const expectedImportDeclaration = {
		type: "ImportDeclaration",
		importKind: "value",
		source: {
			type: "Literal",
			value: options$6.from
		},
		specifiers: [{
			type: "ImportNamespaceSpecifier",
			local: {
				type: "Identifier",
				name: options$6.as
			}
		}],
		attributes: []
	};
	addImportIfNecessary(node, expectedImportDeclaration);
}
function addDefault(node, options$6) {
	const expectedImportDeclaration = {
		type: "ImportDeclaration",
		source: {
			type: "Literal",
			value: options$6.from
		},
		specifiers: [{
			type: "ImportDefaultSpecifier",
			local: {
				type: "Identifier",
				name: options$6.as
			}
		}],
		attributes: [],
		importKind: "value"
	};
	addImportIfNecessary(node, expectedImportDeclaration);
}
function addNamed(node, options$6) {
	const o_imports = Array.isArray(options$6.imports) ? Object.fromEntries(options$6.imports.map((n) => [n, n])) : options$6.imports;
	const specifiers = Object.entries(o_imports).map(([key, value]) => {
		return {
			type: "ImportSpecifier",
			imported: {
				type: "Identifier",
				name: key
			},
			local: {
				type: "Identifier",
				name: value
			}
		};
	});
	let importDecl;
	walk(node, null, { ImportDeclaration(declaration$1) {
		if (declaration$1.source.value === options$6.from && declaration$1.specifiers) importDecl = declaration$1;
	} });
	if (importDecl) {
		specifiers.forEach((specifierToAdd) => {
			if (importDecl?.specifiers?.every((existingSpecifier) => existingSpecifier.type === "ImportSpecifier" && existingSpecifier.local?.name !== specifierToAdd.local?.name && existingSpecifier.imported.type === "Identifier" && specifierToAdd.imported.type === "Identifier" && existingSpecifier.imported.name !== specifierToAdd.imported.name)) importDecl?.specifiers?.push(specifierToAdd);
		});
		return;
	}
	const expectedImportDeclaration = {
		type: "ImportDeclaration",
		source: {
			type: "Literal",
			value: options$6.from
		},
		specifiers,
		attributes: [],
		importKind: options$6.isType ? "type" : "value"
	};
	node.body.unshift(expectedImportDeclaration);
}
function addImportIfNecessary(node, expectedImportDeclaration) {
	if (!node.body.filter((item) => item.type === "ImportDeclaration").find((item) => areNodesEqual(item, expectedImportDeclaration))) node.body.unshift(expectedImportDeclaration);
}
function find(ast, options$6) {
	let alias = options$6.name;
	let statement;
	walk(ast, null, { ImportDeclaration(node) {
		if (node.specifiers && node.source.value === options$6.from) {
			const specifier = node.specifiers.find((sp) => sp.type === "ImportSpecifier" && sp.imported.type === "Identifier" && sp.imported.name === options$6.name);
			if (specifier) {
				statement = node;
				alias = specifier.local?.name ?? alias;
				return;
			}
		}
	} });
	if (statement) return {
		statement,
		alias
	};
	return {
		statement: void 0,
		alias: void 0
	};
}
function remove(ast, options$6) {
	const statement = options$6.statement ?? find(ast, {
		name: options$6.name,
		from: options$6.from
	}).statement;
	if (!statement) return;
	if (statement.specifiers?.length === 1) {
		const idxToRemove = ast.body.indexOf(statement);
		ast.body.splice(idxToRemove, 1);
	} else {
		const idxToRemove = statement.specifiers?.findIndex((s) => s.type === "ImportSpecifier" && s.imported.type === "Identifier" && s.imported.name === options$6.name);
		if (idxToRemove !== void 0 && idxToRemove !== -1) statement.specifiers?.splice(idxToRemove, 1);
	}
}

//#endregion
//#region ../core/tooling/js/variables.ts
function declaration(node, options$6) {
	let declaration$1 = (node.type === "Program" ? node.body.filter((x$1) => x$1.type === "VariableDeclaration") : [node]).find((x$1) => {
		return x$1.declarations[0].id.name === options$6.name;
	});
	if (declaration$1) return declaration$1;
	declaration$1 = {
		type: "VariableDeclaration",
		kind: options$6.kind,
		declarations: [{
			type: "VariableDeclarator",
			id: {
				type: "Identifier",
				name: options$6.name
			},
			init: options$6.value
		}]
	};
	return declaration$1;
}
function createIdentifier(name) {
	return {
		type: "Identifier",
		name
	};
}
function typeAnnotateDeclarator(node, options$6) {
	if (node.id.type === "Identifier") node.id.typeAnnotation = {
		type: "TSTypeAnnotation",
		typeAnnotation: {
			type: "TSTypeReference",
			typeName: {
				type: "Identifier",
				name: options$6.typeName
			}
		}
	};
	return node;
}

//#endregion
//#region ../core/tooling/js/exports.ts
function createDefault(node, options$6) {
	const existingNode = node.body.find((item) => item.type === "ExportDefaultDeclaration");
	if (!existingNode) {
		const exportNode = {
			type: "ExportDefaultDeclaration",
			declaration: options$6.fallback
		};
		node.body.push(exportNode);
		return {
			astNode: exportNode,
			value: options$6.fallback,
			isFallback: true
		};
	}
	const exportDefaultDeclaration = existingNode;
	if (exportDefaultDeclaration.declaration.type === "Identifier") {
		const identifier = exportDefaultDeclaration.declaration;
		let variableDeclaration;
		let variableDeclarator;
		for (const declaration$2 of node.body) {
			if (declaration$2.type !== "VariableDeclaration") continue;
			variableDeclarator = declaration$2.declarations.find((declarator) => declarator.type === "VariableDeclarator" && declarator.id.type === "Identifier" && declarator.id.name === identifier.name);
			variableDeclaration = declaration$2;
		}
		if (!variableDeclaration || !variableDeclarator) throw new Error(`Unable to find exported variable '${identifier.name}'`);
		const value = variableDeclarator.init;
		return {
			astNode: exportDefaultDeclaration,
			value,
			isFallback: false
		};
	}
	const declaration$1 = exportDefaultDeclaration.declaration;
	return {
		astNode: exportDefaultDeclaration,
		value: declaration$1,
		isFallback: false
	};
}
function createNamed(node, options$6) {
	let namedExport = node.body.filter((item) => item.type === "ExportNamedDeclaration").find((exportNode) => {
		return exportNode.declaration.declarations[0].id.name === options$6.name;
	});
	if (namedExport) return namedExport;
	namedExport = {
		type: "ExportNamedDeclaration",
		declaration: options$6.fallback,
		specifiers: [],
		attributes: []
	};
	node.body.push(namedExport);
	return namedExport;
}

//#endregion
//#region ../core/tooling/js/kit.ts
function addGlobalAppInterface(node, options$6) {
	let globalDecl = node.body.filter((n) => n.type === "TSModuleDeclaration").find((m) => m.global && m.declare);
	if (!globalDecl) {
		globalDecl = parseFromString("declare global {}");
		node.body.push(globalDecl);
	}
	if (globalDecl.body?.type !== "TSModuleBlock") throw new Error("Unexpected body type of `declare global` in `src/app.d.ts`");
	let app;
	let interfaceNode;
	walk(globalDecl, null, {
		TSModuleDeclaration(node$1, { next }) {
			if (node$1.id.type === "Identifier" && node$1.id.name === "App") app = node$1;
			next();
		},
		TSInterfaceDeclaration(node$1) {
			if (node$1.id.type === "Identifier" && node$1.id.name === options$6.name) interfaceNode = node$1;
		}
	});
	if (!app) {
		app = parseFromString("namespace App {}");
		globalDecl.body.body.push(app);
	}
	if (app.body?.type !== "TSModuleBlock") throw new Error("Unexpected body type of `namespace App` in `src/app.d.ts`");
	if (!interfaceNode) {
		interfaceNode = parseFromString(`interface ${options$6.name} {}`);
		app.body.body.push(interfaceNode);
	}
	return interfaceNode;
}
function addHooksHandle(node, options$6) {
	if (options$6.typescript) addNamed(node, {
		from: "@sveltejs/kit",
		imports: { Handle: "Handle" },
		isType: true
	});
	let isSpecifier = false;
	let handleName = "handle";
	let exportDecl;
	let originalHandleDecl;
	walk(node, null, { ExportNamedDeclaration(declaration$1) {
		let maybeHandleDecl;
		const handleSpecifier = declaration$1.specifiers?.find((specifier) => specifier.exported.type === "Identifier" && specifier.exported.name === "handle");
		if (handleSpecifier && handleSpecifier.local.type === "Identifier" && handleSpecifier.exported.type === "Identifier") {
			isSpecifier = true;
			handleName = handleSpecifier.local?.name ?? handleSpecifier.exported.name;
			const handleFunc = node.body.find((item) => isFunctionDeclaration(item, handleName));
			const handleVar = node.body.find((item) => isVariableDeclaration(item, handleName));
			maybeHandleDecl = handleFunc ?? handleVar;
		}
		maybeHandleDecl ??= declaration$1.declaration ?? void 0;
		if (maybeHandleDecl && isVariableDeclaration(maybeHandleDecl, handleName)) {
			exportDecl = declaration$1;
			originalHandleDecl = maybeHandleDecl;
		}
		if (maybeHandleDecl && isFunctionDeclaration(maybeHandleDecl, handleName)) {
			exportDecl = declaration$1;
			originalHandleDecl = maybeHandleDecl;
		}
	} });
	const newHandle = parseExpression(options$6.handleContent);
	if (contains(node, newHandle)) return;
	if (!originalHandleDecl || !exportDecl) {
		const newHandleDecl$1 = declaration(node, {
			kind: "const",
			name: options$6.newHandleName,
			value: newHandle
		});
		if (options$6.typescript) {
			const declarator = newHandleDecl$1.declarations[0];
			typeAnnotateDeclarator(declarator, { typeName: "Handle" });
		}
		node.body.push(newHandleDecl$1);
		const handleDecl = declaration(node, {
			kind: "const",
			name: handleName,
			value: createIdentifier(options$6.newHandleName)
		});
		if (options$6.typescript) {
			const declarator = handleDecl.declarations[0];
			typeAnnotateDeclarator(declarator, { typeName: "Handle" });
		}
		createNamed(node, {
			name: handleName,
			fallback: handleDecl
		});
		return;
	}
	const newHandleDecl = declaration(node, {
		kind: "const",
		name: options$6.newHandleName,
		value: newHandle
	});
	if (options$6.typescript) {
		const declarator = newHandleDecl.declarations[0];
		typeAnnotateDeclarator(declarator, { typeName: "Handle" });
	}
	let sequence;
	if (originalHandleDecl.type === "VariableDeclaration") sequence = originalHandleDecl.declarations.find((declarator) => declarator.type === "VariableDeclarator" && usingSequence(declarator, handleName))?.init;
	if (sequence) {
		if (!sequence.arguments.some((arg) => arg.type === "Identifier" && arg.name === options$6.newHandleName)) sequence.arguments.push(createIdentifier(options$6.newHandleName));
		node.body = node.body.filter((item) => item !== originalHandleDecl && item !== exportDecl && item !== newHandleDecl);
		if (isSpecifier) node.body.push(newHandleDecl, originalHandleDecl, exportDecl);
		else node.body.push(newHandleDecl, exportDecl);
	}
	const NEW_HANDLE_NAME = "originalHandle";
	const sequenceCall = createCall({
		name: "sequence",
		args: [NEW_HANDLE_NAME, options$6.newHandleName],
		useIdentifiers: true
	});
	const finalHandleDecl = declaration(node, {
		kind: "const",
		name: handleName,
		value: sequenceCall
	});
	addNamed(node, {
		from: "@sveltejs/kit/hooks",
		imports: { sequence: "sequence" }
	});
	let renameRequired = false;
	if (originalHandleDecl && isVariableDeclaration(originalHandleDecl, handleName)) {
		const handle = getVariableDeclarator(originalHandleDecl, handleName);
		if (handle && handle.id.type === "Identifier" && handle.init?.type !== "Identifier") {
			renameRequired = true;
			handle.id.name = NEW_HANDLE_NAME;
		}
	}
	if (originalHandleDecl && isFunctionDeclaration(originalHandleDecl, handleName)) {
		renameRequired = true;
		originalHandleDecl.id.name = NEW_HANDLE_NAME;
	}
	node.body = node.body.filter((item) => item !== originalHandleDecl && item !== exportDecl && item !== newHandleDecl);
	if (isSpecifier) node.body.push(originalHandleDecl, newHandleDecl, finalHandleDecl, exportDecl);
	if (exportDecl.declaration && renameRequired) {
		node.body.push(exportDecl.declaration, newHandleDecl);
		createNamed(node, {
			name: handleName,
			fallback: finalHandleDecl
		});
	} else if (exportDecl.declaration && isVariableDeclaration(originalHandleDecl, handleName)) {
		const variableDeclarator = getVariableDeclarator(originalHandleDecl, handleName);
		const sequenceCall$1 = createCall({
			name: "sequence",
			args: [(variableDeclarator?.init).name, options$6.newHandleName],
			useIdentifiers: true
		});
		const finalHandleDecl$1 = declaration(node, {
			kind: "const",
			name: handleName,
			value: sequenceCall$1
		});
		if (options$6.typescript) {
			const declarator = finalHandleDecl$1.declarations[0];
			typeAnnotateDeclarator(declarator, { typeName: "Handle" });
		}
		node.body.push(newHandleDecl);
		createNamed(node, {
			name: handleName,
			fallback: finalHandleDecl$1
		});
	}
}
function usingSequence(node, handleName) {
	return node.id.type === "Identifier" && node.id.name === handleName && node.init?.type === "CallExpression" && node.init.callee.type === "Identifier" && node.init.callee.name === "sequence";
}
function isVariableDeclaration(node, variableName) {
	return node.type === "VariableDeclaration" && getVariableDeclarator(node, variableName) !== void 0;
}
function getVariableDeclarator(node, variableName) {
	return node.declarations.find((d) => d.type === "VariableDeclarator" && d.id.type === "Identifier" && d.id.name === variableName);
}
function isFunctionDeclaration(node, funcName) {
	return node.type === "FunctionDeclaration" && node.id?.name === funcName;
}

//#endregion
//#region ../core/tooling/js/vite.ts
function isConfigWrapper(callExpression, knownWrappers) {
	if (callExpression.callee.type !== "Identifier") return false;
	const calleeName = callExpression.callee.name;
	if (knownWrappers.includes(calleeName)) return true;
	const isObjectCall = callExpression.arguments.length === 1 && callExpression.arguments[0]?.type === "ObjectExpression";
	return knownWrappers.includes(calleeName) || isObjectCall;
}
function exportDefaultConfig(ast, options$6) {
	const { fallback, ignoreWrapper } = options$6;
	let fallbackExpression;
	if (fallback) fallbackExpression = typeof fallback.code === "string" ? parseExpression(fallback.code) : fallback.code;
	else fallbackExpression = create({});
	const { value, isFallback } = createDefault(ast, { fallback: fallbackExpression });
	if (isFallback) options$6.fallback?.additional?.(ast);
	const rootObject = value.type === "TSSatisfiesExpression" ? value.expression : value;
	let configObject;
	if (!("arguments" in rootObject) || !Array.isArray(rootObject.arguments)) {
		configObject = rootObject;
		return configObject;
	}
	if (rootObject.type !== "CallExpression" || rootObject.callee.type !== "Identifier") {
		configObject = rootObject;
		return configObject;
	}
	if (!isConfigWrapper(rootObject, ignoreWrapper)) {
		configObject = rootObject;
		return configObject;
	}
	const firstArg = getArgument(rootObject, {
		index: 0,
		fallback: create({})
	});
	if (firstArg.type === "ArrowFunctionExpression") {
		const arrowFunction = firstArg;
		if (arrowFunction.body.type === "BlockStatement") {
			const returnStatement = arrowFunction.body.body.find((stmt) => stmt.type === "ReturnStatement");
			if (returnStatement && returnStatement.argument?.type === "ObjectExpression") configObject = returnStatement.argument;
			else {
				configObject = create({});
				const newReturnStatement = {
					type: "ReturnStatement",
					argument: configObject
				};
				arrowFunction.body.body.push(newReturnStatement);
			}
		} else if (arrowFunction.body.type === "ObjectExpression") configObject = arrowFunction.body;
		else {
			configObject = create({});
			arrowFunction.body = configObject;
			arrowFunction.expression = true;
		}
	} else if (firstArg.type === "ObjectExpression") configObject = firstArg;
	else configObject = create({});
	return configObject;
}
function addInArrayOfObject(ast, options$6) {
	const { code, arrayProperty, mode = "append" } = options$6;
	const targetArray = property(ast, {
		name: arrayProperty,
		fallback: create$1()
	});
	const expression = parseExpression(code);
	if (mode === "prepend") prepend(targetArray, expression);
	else append(targetArray, expression);
}
const addPlugin = (ast, options$6) => {
	const configObject = getConfig(ast);
	addInArrayOfObject(configObject, {
		arrayProperty: "plugins",
		...options$6
	});
};
const getConfig = (ast) => {
	return exportDefaultConfig(ast, {
		fallback: {
			code: "defineConfig()",
			additional: (ast$1) => addNamed(ast$1, {
				imports: ["defineConfig"],
				from: "vite"
			})
		},
		ignoreWrapper: ["defineConfig"]
	});
};

//#endregion
//#region ../addons/devtools-json/index.ts
var devtools_json_default = defineAddon({
	id: "devtools-json",
	shortDescription: "devtools json",
	homepage: "https://github.com/ChromeDevTools/vite-plugin-devtools-json",
	options: {},
	run: ({ sv, viteConfigFile }) => {
		sv.devDependency("vite-plugin-devtools-json", "^1.0.0");
		sv.file(viteConfigFile, (content) => {
			const { ast, generateCode } = parseScript(content);
			const vitePluginName = "devtoolsJson";
			addDefault(ast, {
				as: vitePluginName,
				from: "vite-plugin-devtools-json"
			});
			addPlugin(ast, { code: `${vitePluginName}()` });
			return generateCode();
		});
	}
});

//#endregion
//#region ../addons/common.ts
function addEslintConfigPrettier(content) {
	const { ast, generateCode } = parseScript(content);
	const sveltePluginImport = ast.body.filter((n) => n.type === "ImportDeclaration").find((n) => n.type === "ImportDeclaration" && n.source.value === "eslint-plugin-svelte" && n.specifiers?.some((n$1) => n$1.type === "ImportDefaultSpecifier"));
	let svelteImportName;
	for (const specifier of sveltePluginImport?.specifiers ?? []) if (specifier.type === "ImportDefaultSpecifier" && specifier.local?.name) svelteImportName = specifier.local.name;
	svelteImportName ??= "svelte";
	addDefault(ast, {
		from: "eslint-plugin-svelte",
		as: svelteImportName
	});
	addDefault(ast, {
		from: "eslint-config-prettier",
		as: "prettier"
	});
	const fallbackConfig = parseExpression("[]");
	const eslintConfig = createDefault(ast, { fallback: fallbackConfig }).value;
	if (eslintConfig.type !== "ArrayExpression" && eslintConfig.type !== "CallExpression") return content;
	const prettier = parseExpression("prettier");
	const sveltePrettierConfig = parseExpression(`${svelteImportName}.configs.prettier`);
	const configSpread = createSpread(sveltePrettierConfig);
	const nodesToInsert = [];
	if (!contains(eslintConfig, prettier)) nodesToInsert.push(prettier);
	if (!contains(eslintConfig, configSpread)) nodesToInsert.push(configSpread);
	const elements = eslintConfig.type === "ArrayExpression" ? eslintConfig.elements : eslintConfig.arguments;
	const idx = elements.findIndex((el) => el?.type === "SpreadElement" && el.argument.type === "MemberExpression" && el.argument.object.type === "MemberExpression" && el.argument.object.property.type === "Identifier" && el.argument.object.property.name === "configs" && el.argument.object.object.type === "Identifier" && el.argument.object.object.name === svelteImportName);
	if (idx !== -1) elements.splice(idx + 1, 0, ...nodesToInsert);
	else elements.push(...nodesToInsert);
	return generateCode();
}
function addToDemoPage(content, path$1) {
	const { template, generateCode } = parseSvelte(content);
	for (const node of template.ast.childNodes) if (node.type === "tag" && node.attribs["href"] === `/demo/${path$1}`) return content;
	const newLine = template.source ? "\n" : "";
	const src = template.source + `${newLine}<a href="/demo/${path$1}">${path$1}</a>`;
	return generateCode({ template: src });
}
/**
* Returns the corresponding `@types/node` version for the version of Node.js running in the current process.
*
* If the installed version of Node.js is from a `Current` release, then the major is decremented to
* the nearest `LTS` release version.
*/
function getNodeTypesVersion() {
	const nodeVersion = process.versions.node;
	const isDenoOrBun = Boolean(process.versions.deno ?? process.versions.bun);
	const [major] = nodeVersion.split(".");
	const majorNum = Number(major);
	const isEvenMajor = majorNum % 2 === 0;
	if (!!process.release.lts || isDenoOrBun && isEvenMajor) return `^${major}`;
	return `^${isEvenMajor ? majorNum - 2 : majorNum - 1}`;
}

//#endregion
//#region ../addons/drizzle/index.ts
const PORTS = {
	mysql: "3306",
	postgresql: "5432",
	sqlite: ""
};
const options$5 = defineAddonOptions().add("database", {
	question: "Which database would you like to use?",
	type: "select",
	default: "sqlite",
	options: [
		{
			value: "postgresql",
			label: "PostgreSQL"
		},
		{
			value: "mysql",
			label: "MySQL"
		},
		{
			value: "sqlite",
			label: "SQLite"
		}
	]
}).add("postgresql", {
	question: "Which PostgreSQL client would you like to use?",
	type: "select",
	group: "client",
	default: "postgres.js",
	options: [{
		value: "postgres.js",
		label: "Postgres.JS",
		hint: "recommended for most users"
	}, {
		value: "neon",
		label: "Neon",
		hint: "popular hosted platform"
	}],
	condition: ({ database }) => database === "postgresql"
}).add("mysql", {
	question: "Which MySQL client would you like to use?",
	type: "select",
	group: "client",
	default: "mysql2",
	options: [{
		value: "mysql2",
		hint: "recommended for most users"
	}, {
		value: "planetscale",
		label: "PlanetScale",
		hint: "popular hosted platform"
	}],
	condition: ({ database }) => database === "mysql"
}).add("sqlite", {
	question: "Which SQLite client would you like to use?",
	type: "select",
	group: "client",
	default: "libsql",
	options: [
		{
			value: "better-sqlite3",
			hint: "for traditional Node environments"
		},
		{
			value: "libsql",
			label: "libSQL",
			hint: "for serverless environments"
		},
		{
			value: "turso",
			label: "Turso",
			hint: "popular hosted platform"
		}
	],
	condition: ({ database }) => database === "sqlite"
}).add("docker", {
	question: "Do you want to run the database locally with docker-compose?",
	default: false,
	type: "boolean",
	condition: ({ database, mysql, postgresql }) => database === "mysql" && mysql === "mysql2" || database === "postgresql" && postgresql === "postgres.js"
}).build();
var drizzle_default = defineAddon({
	id: "drizzle",
	shortDescription: "database orm",
	homepage: "https://orm.drizzle.team",
	options: options$5,
	setup: ({ kit, unsupported, runsAfter, cwd, typescript }) => {
		runsAfter("prettier");
		const ext = typescript ? "ts" : "js";
		if (!kit) return unsupported("Requires SvelteKit");
		const baseDBPath = path.resolve(kit.libDirectory, "server", "db");
		const paths = {
			"drizzle config": path.relative(cwd, path.resolve(cwd, `drizzle.config.${ext}`)),
			"database schema": path.relative(cwd, path.resolve(baseDBPath, `schema.${ext}`)),
			database: path.relative(cwd, path.resolve(baseDBPath, `index.${ext}`))
		};
		for (const [fileType, filePath] of Object.entries(paths)) if (fs.existsSync(filePath)) unsupported(`Preexisting ${fileType} file at '${filePath}'`);
	},
	run: ({ sv, typescript, options: options$6, kit, dependencyVersion }) => {
		const ext = typescript ? "ts" : "js";
		sv.devDependency("drizzle-orm", "^0.44.5");
		sv.devDependency("drizzle-kit", "^0.31.4");
		sv.devDependency("@types/node", getNodeTypesVersion());
		if (options$6.mysql === "mysql2") sv.dependency("mysql2", "^3.15.0");
		if (options$6.mysql === "planetscale") sv.dependency("@planetscale/database", "^1.19.0");
		if (options$6.postgresql === "neon") sv.dependency("@neondatabase/serverless", "^1.0.1");
		if (options$6.postgresql === "postgres.js") sv.dependency("postgres", "^3.4.7");
		if (options$6.sqlite === "better-sqlite3") {
			sv.dependency("better-sqlite3", "^12.4.1");
			sv.devDependency("@types/better-sqlite3", "^7.6.13");
			sv.pnpmBuildDependency("better-sqlite3");
		}
		if (options$6.sqlite === "libsql" || options$6.sqlite === "turso") sv.devDependency("@libsql/client", "^0.15.15");
		sv.file(".env", (content) => generateEnvFileContent(content, options$6));
		sv.file(".env.example", (content) => generateEnvFileContent(content, options$6));
		if (options$6.docker && (options$6.mysql === "mysql2" || options$6.postgresql === "postgres.js")) sv.file("docker-compose.yml", (content) => {
			if (content.length > 0) return content;
			const imageName = options$6.database === "mysql" ? "mysql" : "postgres";
			const port = PORTS[options$6.database];
			const USER = "root";
			const PASSWORD = "mysecretpassword";
			const DB_NAME = "local";
			let dbSpecificContent = "";
			if (options$6.mysql === "mysql2") dbSpecificContent = `
                      MYSQL_ROOT_PASSWORD: ${PASSWORD}
                      MYSQL_DATABASE: ${DB_NAME}
                    volumes:
                      - mysqldata:/var/lib/mysql
                volumes:
                  mysqldata:
                `;
			if (options$6.postgresql === "postgres.js") dbSpecificContent = `
                      POSTGRES_USER: ${USER}
                      POSTGRES_PASSWORD: ${PASSWORD}
                      POSTGRES_DB: ${DB_NAME}
                    volumes:
                      - pgdata:/var/lib/postgresql/data
                volumes:
                  pgdata:
                `;
			content = dedent_default`
                services:
                  db:
                    image: ${imageName}
                    restart: always
                    ports:
                      - ${port}:${port}
                    environment: ${dbSpecificContent}
                `;
			return content;
		});
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson(content);
			data.scripts ??= {};
			const scripts = data.scripts;
			if (options$6.docker) scripts["db:start"] ??= "docker compose up";
			scripts["db:push"] ??= "drizzle-kit push";
			scripts["db:generate"] ??= "drizzle-kit generate";
			scripts["db:migrate"] ??= "drizzle-kit migrate";
			scripts["db:studio"] ??= "drizzle-kit studio";
			return generateCode();
		});
		if (Boolean(dependencyVersion("prettier"))) sv.file(".prettierignore", (content) => {
			if (!content.includes(`/drizzle/`)) return content.trimEnd() + "\n/drizzle/";
			return content;
		});
		if (options$6.database === "sqlite") sv.file(".gitignore", (content) => {
			if (content.length === 0) return content;
			if (!content.includes("\n*.db")) content = content.trimEnd() + "\n\n# SQLite\n*.db";
			return content;
		});
		sv.file(`drizzle.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamed(ast, {
				from: "drizzle-kit",
				imports: { defineConfig: "defineConfig" }
			});
			ast.body.push(parseStatement("if (!process.env.DATABASE_URL) throw new Error('DATABASE_URL is not set');"));
			createDefault(ast, { fallback: parseExpression(`
					defineConfig({
						schema: "./src/lib/server/db/schema.${typescript ? "ts" : "js"}",
						dialect: "${options$6.sqlite === "turso" ? "turso" : options$6.database}",
						dbCredentials: {
							${options$6.sqlite === "turso" ? "authToken: process.env.DATABASE_AUTH_TOKEN," : ""}
							url: process.env.DATABASE_URL
						},
						verbose: true,
						strict: true
					})`) });
			return generateCode();
		});
		sv.file(`${kit?.libDirectory}/server/db/schema.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			let userSchemaExpression;
			if (options$6.database === "sqlite") {
				addNamed(ast, {
					from: "drizzle-orm/sqlite-core",
					imports: [
						"integer",
						"sqliteTable",
						"text"
					]
				});
				userSchemaExpression = parseExpression(`sqliteTable('user', {
					id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),
					age: integer('age')
				})`);
			}
			if (options$6.database === "mysql") {
				addNamed(ast, {
					from: "drizzle-orm/mysql-core",
					imports: [
						"mysqlTable",
						"serial",
						"int"
					]
				});
				userSchemaExpression = parseExpression(`mysqlTable('user', {
					id: serial('id').primaryKey(),
					age: int('age'),
				})`);
			}
			if (options$6.database === "postgresql") {
				addNamed(ast, {
					from: "drizzle-orm/pg-core",
					imports: [
						"pgTable",
						"serial",
						"integer"
					]
				});
				userSchemaExpression = parseExpression(`pgTable('user', {
					id: serial('id').primaryKey(),
					age: integer('age'),
				})`);
			}
			if (!userSchemaExpression) throw new Error("unreachable state...");
			const userIdentifier = declaration(ast, {
				kind: "const",
				name: "user",
				value: userSchemaExpression
			});
			createNamed(ast, {
				name: "user",
				fallback: userIdentifier
			});
			return generateCode();
		});
		sv.file(`${kit?.libDirectory}/server/db/index.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamed(ast, {
				from: "$env/dynamic/private",
				imports: ["env"]
			});
			addNamespace(ast, {
				from: "./schema",
				as: "schema"
			});
			const dbURLCheck = parseStatement("if (!env.DATABASE_URL) throw new Error('DATABASE_URL is not set');");
			ast.body.push(dbURLCheck);
			let clientExpression;
			if (options$6.sqlite === "better-sqlite3") {
				addDefault(ast, {
					from: "better-sqlite3",
					as: "Database"
				});
				addNamed(ast, {
					from: "drizzle-orm/better-sqlite3",
					imports: ["drizzle"]
				});
				clientExpression = parseExpression("new Database(env.DATABASE_URL)");
			}
			if (options$6.sqlite === "libsql" || options$6.sqlite === "turso") {
				addNamed(ast, {
					from: "@libsql/client",
					imports: ["createClient"]
				});
				addNamed(ast, {
					from: "drizzle-orm/libsql",
					imports: ["drizzle"]
				});
				if (options$6.sqlite === "turso") {
					addNamed(ast, {
						from: "$app/environment",
						imports: ["dev"]
					});
					const authTokenCheck = parseStatement("if (!dev && !env.DATABASE_AUTH_TOKEN) throw new Error('DATABASE_AUTH_TOKEN is not set');");
					ast.body.push(authTokenCheck);
					clientExpression = parseExpression("createClient({ url: env.DATABASE_URL, authToken: env.DATABASE_AUTH_TOKEN })");
				} else clientExpression = parseExpression("createClient({ url: env.DATABASE_URL })");
			}
			if (options$6.mysql === "mysql2" || options$6.mysql === "planetscale") {
				addDefault(ast, {
					from: "mysql2/promise",
					as: "mysql"
				});
				addNamed(ast, {
					from: "drizzle-orm/mysql2",
					imports: ["drizzle"]
				});
				clientExpression = parseExpression("mysql.createPool(env.DATABASE_URL)");
			}
			if (options$6.postgresql === "neon") {
				addNamed(ast, {
					from: "@neondatabase/serverless",
					imports: ["neon"]
				});
				addNamed(ast, {
					from: "drizzle-orm/neon-http",
					imports: ["drizzle"]
				});
				clientExpression = parseExpression("neon(env.DATABASE_URL)");
			}
			if (options$6.postgresql === "postgres.js") {
				addDefault(ast, {
					from: "postgres",
					as: "postgres"
				});
				addNamed(ast, {
					from: "drizzle-orm/postgres-js",
					imports: ["drizzle"]
				});
				clientExpression = parseExpression("postgres(env.DATABASE_URL)");
			}
			if (!clientExpression) throw new Error("unreachable state...");
			ast.body.push(declaration(ast, {
				kind: "const",
				name: "client",
				value: clientExpression
			}));
			const drizzleCall = createCall({
				name: "drizzle",
				args: ["client"],
				useIdentifiers: true
			});
			const paramObject = create({ schema: createIdentifier("schema") });
			if (options$6.database === "mysql") {
				const mode = options$6.mysql === "planetscale" ? "planetscale" : "default";
				property(paramObject, {
					name: "mode",
					fallback: createLiteral(mode)
				});
			}
			drizzleCall.arguments.push(paramObject);
			const db = declaration(ast, {
				kind: "const",
				name: "db",
				value: drizzleCall
			});
			createNamed(ast, {
				name: "db",
				fallback: db
			});
			return generateCode();
		});
	},
	nextSteps: ({ options: options$6, highlighter, packageManager }) => {
		const steps = [`You will need to set ${highlighter.env("DATABASE_URL")} in your production environment`];
		if (options$6.docker) {
			const { command: command$1, args: args$1 } = resolveCommand(packageManager, "run", ["db:start"]);
			steps.push(`Run ${highlighter.command(`${command$1} ${args$1.join(" ")}`)} to start the docker container`);
		} else steps.push(`Check ${highlighter.env("DATABASE_URL")} in ${highlighter.path(".env")} and adjust it to your needs`);
		const { command, args } = resolveCommand(packageManager, "run", ["db:push"]);
		steps.push(`Run ${highlighter.command(`${command} ${args.join(" ")}`)} to update your database schema`);
		return steps;
	}
});
function generateEnvFileContent(content, opts) {
	const DB_URL_KEY = "DATABASE_URL";
	if (opts.docker) {
		const protocol = opts.database === "mysql" ? "mysql" : "postgres";
		const port = PORTS[opts.database];
		content = addEnvVar(content, DB_URL_KEY, `"${protocol}://root:mysecretpassword@localhost:${port}/local"`);
		return content;
	}
	if (opts.sqlite === "better-sqlite3" || opts.sqlite === "libsql") {
		const dbFile = opts.sqlite === "libsql" ? "file:local.db" : "local.db";
		content = addEnvVar(content, DB_URL_KEY, dbFile);
		return content;
	}
	content = addEnvComment(content, "Replace with your DB credentials!");
	if (opts.sqlite === "turso") {
		content = addEnvVar(content, DB_URL_KEY, "\"libsql://db-name-user.turso.io\"");
		content = addEnvVar(content, "DATABASE_AUTH_TOKEN", "\"\"");
		content = addEnvComment(content, "A local DB can also be used in dev as well");
		content = addEnvComment(content, `${DB_URL_KEY}="file:local.db"`);
	}
	if (opts.database === "mysql") content = addEnvVar(content, DB_URL_KEY, "\"mysql://user:password@host:port/db-name\"");
	if (opts.database === "postgresql") content = addEnvVar(content, DB_URL_KEY, "\"postgres://user:password@host:port/db-name\"");
	return content;
}
function addEnvVar(content, key, value) {
	if (!content.includes(key + "=")) content = appendEnvContent(content, `${key}=${value}`);
	return content;
}
function addEnvComment(content, comment) {
	const commented = `# ${comment}`;
	if (!content.includes(commented)) content = appendEnvContent(content, commented);
	return content;
}
function appendEnvContent(existing, content) {
	return (!existing.length || existing.endsWith("\n") ? existing : existing + "\n") + content + "\n";
}

//#endregion
//#region ../addons/eslint/index.ts
var eslint_default = defineAddon({
	id: "eslint",
	shortDescription: "linter",
	homepage: "https://eslint.org",
	options: {},
	run: ({ sv, typescript, dependencyVersion }) => {
		const prettierInstalled = Boolean(dependencyVersion("prettier"));
		sv.devDependency("eslint", "^9.36.0");
		sv.devDependency("@eslint/compat", "^1.4.0");
		sv.devDependency("eslint-plugin-svelte", "^3.12.4");
		sv.devDependency("globals", "^16.4.0");
		sv.devDependency("@eslint/js", "^9.36.0");
		sv.devDependency("@types/node", getNodeTypesVersion());
		if (typescript) sv.devDependency("typescript-eslint", "^8.44.1");
		if (prettierInstalled) sv.devDependency("eslint-config-prettier", "^10.1.8");
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson(content);
			data.scripts ??= {};
			const scripts = data.scripts;
			const LINT_CMD = "eslint .";
			scripts["lint"] ??= LINT_CMD;
			if (!scripts["lint"].includes(LINT_CMD)) scripts["lint"] += ` && ${LINT_CMD}`;
			return generateCode();
		});
		sv.file(".vscode/settings.json", (content) => {
			if (!content) return content;
			const { data, generateCode } = parseJson(content);
			const validate = data["eslint.validate"];
			if (validate && !validate.includes("svelte")) validate.push("svelte");
			return generateCode();
		});
		sv.file("eslint.config.js", (content) => {
			const { ast, generateCode } = parseScript(content);
			const eslintConfigs = [];
			addDefault(ast, {
				from: "./svelte.config.js",
				as: "svelteConfig"
			});
			const gitIgnorePathStatement = parseStatement("\nconst gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url));");
			appendStatement(ast, { statement: gitIgnorePathStatement });
			const ignoresConfig = parseExpression("includeIgnoreFile(gitignorePath)");
			eslintConfigs.push(ignoresConfig);
			const jsConfig = parseExpression("js.configs.recommended");
			eslintConfigs.push(jsConfig);
			if (typescript) {
				const tsConfig = parseExpression("ts.configs.recommended");
				eslintConfigs.push(createSpread(tsConfig));
			}
			const svelteConfig = parseExpression("svelte.configs.recommended");
			eslintConfigs.push(createSpread(svelteConfig));
			const globalsBrowser = createSpread(parseExpression("globals.browser"));
			const globalsNode = createSpread(parseExpression("globals.node"));
			const globalsObjLiteral = create({});
			globalsObjLiteral.properties = [globalsBrowser, globalsNode];
			const rules = create({ "\"no-undef\"": "off" });
			if (rules.properties[0].type !== "Property") throw new Error("rules.properties[0].type !== \"Property\"");
			rules.properties[0].key.leadingComments = [{
				type: "Line",
				value: " typescript-eslint strongly recommend that you do not use the no-undef lint rule on TypeScript projects."
			}, {
				type: "Line",
				value: " see: https://typescript-eslint.io/troubleshooting/faqs/eslint/#i-get-errors-from-the-no-undef-rule-about-global-variables-not-being-defined-even-though-there-are-no-typescript-errors"
			}];
			const globalsConfig = create({
				languageOptions: { globals: globalsObjLiteral },
				rules: typescript ? rules : void 0
			});
			eslintConfigs.push(globalsConfig);
			if (typescript) {
				const svelteTSParserConfig = create({
					files: [
						"**/*.svelte",
						"**/*.svelte.ts",
						"**/*.svelte.js"
					],
					languageOptions: { parserOptions: {
						projectService: true,
						extraFileExtensions: [".svelte"],
						parser: createIdentifier("ts.parser"),
						svelteConfig: createIdentifier("svelteConfig")
					} }
				});
				eslintConfigs.push(svelteTSParserConfig);
			} else {
				const svelteTSParserConfig = create({
					files: ["**/*.svelte", "**/*.svelte.js"],
					languageOptions: { parserOptions: { svelteConfig: createIdentifier("svelteConfig") } }
				});
				eslintConfigs.push(svelteTSParserConfig);
			}
			let exportExpression;
			if (typescript) {
				const tsConfigCall = createCall({
					name: "defineConfig",
					args: []
				});
				tsConfigCall.arguments.push(...eslintConfigs);
				exportExpression = tsConfigCall;
			} else {
				const eslintArray = create$1();
				eslintConfigs.map((x$1) => append(eslintArray, x$1));
				exportExpression = eslintArray;
			}
			const { value: defaultExport, astNode } = createDefault(ast, { fallback: exportExpression });
			if (defaultExport !== exportExpression) {
				T.warn("An eslint config is already defined. Skipping initialization.");
				return content;
			}
			if (!typescript) addJsDocTypeComment(astNode, { type: "import('eslint').Linter.Config[]" });
			if (typescript) addDefault(ast, {
				from: "typescript-eslint",
				as: "ts"
			});
			addDefault(ast, {
				from: "globals",
				as: "globals"
			});
			if (typescript) addNamed(ast, {
				from: "eslint/config",
				imports: ["defineConfig"]
			});
			addDefault(ast, {
				from: "eslint-plugin-svelte",
				as: "svelte"
			});
			addDefault(ast, {
				from: "@eslint/js",
				as: "js"
			});
			addNamed(ast, {
				from: "@eslint/compat",
				imports: ["includeIgnoreFile"]
			});
			addNamed(ast, {
				from: "node:url",
				imports: ["fileURLToPath"]
			});
			return generateCode();
		});
		if (prettierInstalled) sv.file("eslint.config.js", addEslintConfigPrettier);
	}
});

//#endregion
//#region ../addons/lucia/index.ts
const TABLE_TYPE = {
	mysql: "mysqlTable",
	postgresql: "pgTable",
	sqlite: "sqliteTable",
	turso: "sqliteTable"
};
let drizzleDialect;
let schemaPath;
const options$4 = defineAddonOptions().add("demo", {
	type: "boolean",
	default: true,
	question: `Do you want to include a demo? ${import_picocolors$2.default.dim("(includes a login/register page)")}`
}).build();
var lucia_default = defineAddon({
	id: "lucia",
	shortDescription: "auth guide",
	homepage: "https://lucia-auth.com",
	options: options$4,
	setup: ({ kit, dependencyVersion, unsupported, dependsOn, runsAfter }) => {
		if (!kit) unsupported("Requires SvelteKit");
		if (!dependencyVersion("drizzle-orm")) dependsOn("drizzle");
		runsAfter("tailwindcss");
	},
	run: ({ sv, typescript, options: options$6, kit, dependencyVersion }) => {
		const ext = typescript ? "ts" : "js";
		sv.devDependency("@oslojs/crypto", "^1.0.1");
		sv.devDependency("@oslojs/encoding", "^1.1.0");
		if (options$6.demo) sv.dependency("@node-rs/argon2", "^2.0.2");
		sv.file(`drizzle.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			const isProp = (name, node) => node.key.type === "Identifier" && node.key.name === name;
			walk(ast, null, { Property(node) {
				if (isProp("dialect", node) && node.value.type === "Literal" && typeof node.value.value === "string") drizzleDialect = node.value.value;
				if (isProp("schema", node) && node.value.type === "Literal" && typeof node.value.value === "string") schemaPath = node.value.value;
			} });
			if (!drizzleDialect) throw new Error("Failed to detect DB dialect in your `drizzle.config.[js|ts]` file");
			if (!schemaPath) throw new Error("Failed to find schema path in your `drizzle.config.[js|ts]` file");
			return generateCode();
		});
		sv.file(schemaPath, (content) => {
			const { ast, generateCode } = parseScript(content);
			const createTable = (name) => createCall({
				name: TABLE_TYPE[drizzleDialect],
				args: [name]
			});
			const userDecl = declaration(ast, {
				kind: "const",
				name: "user",
				value: createTable("user")
			});
			const sessionDecl = declaration(ast, {
				kind: "const",
				name: "session",
				value: createTable("session")
			});
			const user = createNamed(ast, {
				name: "user",
				fallback: userDecl
			});
			const session = createNamed(ast, {
				name: "session",
				fallback: sessionDecl
			});
			const userTable = getCallExpression(user);
			const sessionTable = getCallExpression(session);
			if (!userTable || !sessionTable) throw new Error("failed to find call expression of `user` or `session`");
			if (userTable.arguments.length === 1) userTable.arguments.push(create({}));
			if (sessionTable.arguments.length === 1) sessionTable.arguments.push(create({}));
			const userAttributes = userTable.arguments[1];
			const sessionAttributes = sessionTable.arguments[1];
			if (userAttributes?.type !== "ObjectExpression" || sessionAttributes?.type !== "ObjectExpression") throw new Error("unexpected shape of `user` or `session` table definition");
			if (drizzleDialect === "sqlite" || drizzleDialect === "turso") {
				addNamed(ast, {
					from: "drizzle-orm/sqlite-core",
					imports: [
						"sqliteTable",
						"text",
						"integer"
					]
				});
				overrideProperties(userAttributes, { id: parseExpression("text('id').primaryKey()") });
				if (options$6.demo) overrideProperties(userAttributes, {
					username: parseExpression("text('username').notNull().unique()"),
					passwordHash: parseExpression("text('password_hash').notNull()")
				});
				overrideProperties(sessionAttributes, {
					id: parseExpression("text('id').primaryKey()"),
					userId: parseExpression("text('user_id').notNull().references(() => user.id)"),
					expiresAt: parseExpression("integer('expires_at', { mode: 'timestamp' }).notNull()")
				});
			}
			if (drizzleDialect === "mysql") {
				addNamed(ast, {
					from: "drizzle-orm/mysql-core",
					imports: [
						"mysqlTable",
						"varchar",
						"datetime"
					]
				});
				overrideProperties(userAttributes, { id: parseExpression("varchar('id', { length: 255 }).primaryKey()") });
				if (options$6.demo) overrideProperties(userAttributes, {
					username: parseExpression("varchar('username', { length: 32 }).notNull().unique()"),
					passwordHash: parseExpression("varchar('password_hash', { length: 255 }).notNull()")
				});
				overrideProperties(sessionAttributes, {
					id: parseExpression("varchar('id', { length: 255 }).primaryKey()"),
					userId: parseExpression("varchar('user_id', { length: 255 }).notNull().references(() => user.id)"),
					expiresAt: parseExpression("datetime('expires_at').notNull()")
				});
			}
			if (drizzleDialect === "postgresql") {
				addNamed(ast, {
					from: "drizzle-orm/pg-core",
					imports: [
						"pgTable",
						"text",
						"timestamp"
					]
				});
				overrideProperties(userAttributes, { id: parseExpression("text('id').primaryKey()") });
				if (options$6.demo) overrideProperties(userAttributes, {
					username: parseExpression("text('username').notNull().unique()"),
					passwordHash: parseExpression("text('password_hash').notNull()")
				});
				overrideProperties(sessionAttributes, {
					id: parseExpression("text('id').primaryKey()"),
					userId: parseExpression("text('user_id').notNull().references(() => user.id)"),
					expiresAt: parseExpression("timestamp('expires_at', { withTimezone: true, mode: 'date' }).notNull()")
				});
			}
			let code = generateCode();
			if (typescript) {
				if (!code.includes("export type Session =")) code += "\n\nexport type Session = typeof session.$inferSelect;";
				if (!code.includes("export type User =")) code += "\n\nexport type User = typeof user.$inferSelect;";
			}
			return code;
		});
		sv.file(`${kit?.libDirectory}/server/auth.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamespace(ast, {
				from: "$lib/server/db/schema",
				as: "table"
			});
			addNamed(ast, {
				from: "$lib/server/db",
				imports: ["db"]
			});
			addNamed(ast, {
				from: "@oslojs/encoding",
				imports: ["encodeBase64url", "encodeHexLowerCase"]
			});
			addNamed(ast, {
				from: "@oslojs/crypto/sha2",
				imports: ["sha256"]
			});
			addNamed(ast, {
				from: "drizzle-orm",
				imports: ["eq"]
			});
			if (typescript) addNamed(ast, {
				from: "@sveltejs/kit",
				imports: ["RequestEvent"],
				isType: true
			});
			const ms = new MagicString(generateCode().trim());
			const [ts] = createPrinter(typescript);
			if (!ms.original.includes("const DAY_IN_MS")) ms.append("\n\nconst DAY_IN_MS = 1000 * 60 * 60 * 24;");
			if (!ms.original.includes("export const sessionCookieName")) ms.append("\n\nexport const sessionCookieName = 'auth-session';");
			if (!ms.original.includes("export function generateSessionToken")) {
				const generateSessionToken = dedent_default`					
					export function generateSessionToken() {
						const bytes = crypto.getRandomValues(new Uint8Array(18));
						const token = encodeBase64url(bytes);
						return token;
					}`;
				ms.append(`\n\n${generateSessionToken}`);
			}
			if (!ms.original.includes("async function createSession")) {
				const createSession = dedent_default`
					${ts("", "/**")}
					${ts("", " * @param {string} token")}
					${ts("", " * @param {string} userId")}
					${ts("", " */")}
					export async function createSession(token${ts(": string")}, userId${ts(": string")}) {
						const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
						const session${ts(": table.Session")} = {
							id: sessionId,
							userId,
							expiresAt: new Date(Date.now() + DAY_IN_MS * 30)
						};
						await db.insert(table.session).values(session);
						return session;
					}`;
				ms.append(`\n\n${createSession}`);
			}
			if (!ms.original.includes("async function validateSessionToken")) {
				const validateSessionToken = dedent_default`					
					${ts("", "/** @param {string} token */")}
					export async function validateSessionToken(token${ts(": string")}) {
						const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
						const [result] = await db
							.select({
								// Adjust user table here to tweak returned data
								user: { id: table.user.id, username: table.user.username },
								session: table.session
							})
							.from(table.session)
							.innerJoin(table.user, eq(table.session.userId, table.user.id))
							.where(eq(table.session.id, sessionId));

						if (!result) {
							return { session: null, user: null };
						}
						const { session, user } = result;

						const sessionExpired = Date.now() >= session.expiresAt.getTime();
						if (sessionExpired) {
							await db.delete(table.session).where(eq(table.session.id, session.id));
							return { session: null, user: null };
						}

						const renewSession = Date.now() >= session.expiresAt.getTime() - DAY_IN_MS * 15;
						if (renewSession) {
							session.expiresAt = new Date(Date.now() + DAY_IN_MS * 30);
							await db
								.update(table.session)
								.set({ expiresAt: session.expiresAt })
								.where(eq(table.session.id, session.id));
						}

						return { session, user };
					}`;
				ms.append(`\n\n${validateSessionToken}`);
			}
			if (typescript && !ms.original.includes("export type SessionValidationResult")) ms.append(`\n\nexport type SessionValidationResult = Awaited<ReturnType<typeof validateSessionToken>>;`);
			if (!ms.original.includes("async function invalidateSession")) {
				const invalidateSession = dedent_default`					
					${ts("", "/** @param {string} sessionId */")}
					export async function invalidateSession(sessionId${ts(": string")}) {
						await db.delete(table.session).where(eq(table.session.id, sessionId));
					}`;
				ms.append(`\n\n${invalidateSession}`);
			}
			if (!ms.original.includes("export function setSessionTokenCookie")) {
				const setSessionTokenCookie = dedent_default`					
					${ts("", "/**")}
					${ts("", " * @param {import(\"@sveltejs/kit\").RequestEvent} event")}
					${ts("", " * @param {string} token")}
					${ts("", " * @param {Date} expiresAt")}
					${ts("", " */")}
					export function setSessionTokenCookie(event${ts(": RequestEvent")}, token${ts(": string")}, expiresAt${ts(": Date")}) {
						event.cookies.set(sessionCookieName, token, {
							expires: expiresAt,
							path: '/'
						});
					}`;
				ms.append(`\n\n${setSessionTokenCookie}`);
			}
			if (!ms.original.includes("export function deleteSessionTokenCookie")) {
				const deleteSessionTokenCookie = dedent_default`					
					${ts("", "/** @param {import(\"@sveltejs/kit\").RequestEvent} event */")}
					export function deleteSessionTokenCookie(event${ts(": RequestEvent")}) {
						event.cookies.delete(sessionCookieName, {
							path: '/'
						});
					}`;
				ms.append(`\n\n${deleteSessionTokenCookie}`);
			}
			return ms.toString();
		});
		if (typescript) sv.file("src/app.d.ts", (content) => {
			const { ast, generateCode } = parseScript(content);
			const locals = addGlobalAppInterface(ast, { name: "Locals" });
			if (!locals) throw new Error("Failed detecting `locals` interface in `src/app.d.ts`");
			const user = locals.body.body.find((prop) => hasTypeProperty(prop, { name: "user" }));
			const session = locals.body.body.find((prop) => hasTypeProperty(prop, { name: "session" }));
			if (!user) locals.body.body.push(createLuciaType("user"));
			if (!session) locals.body.body.push(createLuciaType("session"));
			return generateCode();
		});
		sv.file(`src/hooks.server.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamespace(ast, {
				from: "$lib/server/auth",
				as: "auth"
			});
			addHooksHandle(ast, {
				typescript,
				newHandleName: "handleAuth",
				handleContent: getAuthHandleContent()
			});
			return generateCode();
		});
		if (options$6.demo) {
			sv.file(`${kit?.routesDirectory}/demo/+page.svelte`, (content) => {
				return addToDemoPage(content, "lucia");
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/login/+page.server.${ext}`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/login/+page.server.${typescript ? "ts" : "js"}`;
					T.warn(`Existing ${import_picocolors$2.default.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const [ts] = createPrinter(typescript);
				return dedent_default`
					import { hash, verify } from '@node-rs/argon2';
					import { encodeBase32LowerCase } from '@oslojs/encoding';
					import { fail, redirect } from '@sveltejs/kit';
					import { eq } from 'drizzle-orm';
					import * as auth from '$lib/server/auth';
					import { db } from '$lib/server/db';
					import * as table from '$lib/server/db/schema';
					${ts("import type { Actions, PageServerLoad } from './$types';\n")}
					export const load${ts(": PageServerLoad")} = async (event) => {
						if (event.locals.user) {
							return redirect(302, '/demo/lucia');
						}
						return {};
					};

					export const actions${ts(": Actions")} = {
						login: async (event) => {
							const formData = await event.request.formData();
							const username = formData.get('username');
							const password = formData.get('password');

							if (!validateUsername(username)) {
								return fail(400, { message: 'Invalid username (min 3, max 31 characters, alphanumeric only)' });
							}
							if (!validatePassword(password)) {
								return fail(400, { message: 'Invalid password (min 6, max 255 characters)' });
							}

							const results = await db
								.select()
								.from(table.user)
								.where(eq(table.user.username, username));

							const existingUser = results.at(0);
							if (!existingUser) {
								return fail(400, { message: 'Incorrect username or password' });
							}

							const validPassword = await verify(existingUser.passwordHash, password, {
								memoryCost: 19456,
								timeCost: 2,
								outputLen: 32,
								parallelism: 1,
							});
							if (!validPassword) {
								return fail(400, { message: 'Incorrect username or password' });
							}

							const sessionToken = auth.generateSessionToken();
							const session = await auth.createSession(sessionToken, existingUser.id);
							auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);

							return redirect(302, '/demo/lucia');
						},
						register: async (event) => {
							const formData = await event.request.formData();
							const username = formData.get('username');
							const password = formData.get('password');

							if (!validateUsername(username)) {
								return fail(400, { message: 'Invalid username' });
							}
							if (!validatePassword(password)) {
								return fail(400, { message: 'Invalid password' });
							}

							const userId = generateUserId();
							const passwordHash = await hash(password, {
								// recommended minimum parameters
								memoryCost: 19456,
								timeCost: 2,
								outputLen: 32,
								parallelism: 1,
							});

							try {
								await db.insert(table.user).values({ id: userId, username, passwordHash });

								const sessionToken = auth.generateSessionToken();
								const session = await auth.createSession(sessionToken, userId);
								auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);
							} catch {
								return fail(500, { message: 'An error has occurred' });
							}
							return redirect(302, '/demo/lucia');
						},
					};

					function generateUserId() {
						// ID with 120 bits of entropy, or about the same as UUID v4.
						const bytes = crypto.getRandomValues(new Uint8Array(15));
						const id = encodeBase32LowerCase(bytes);
						return id;
					}

					function validateUsername(username${ts(": unknown")})${ts(": username is string")} {
						return (
							typeof username === 'string' &&
							username.length >= 3 &&
							username.length <= 31 &&
							/^[a-z0-9_-]+$/.test(username)
						);
					}

					function validatePassword(password${ts(": unknown")})${ts(": password is string")} {
						return (
							typeof password === 'string' &&
							password.length >= 6 &&
							password.length <= 255
						);
					}
				`;
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/login/+page.svelte`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/login/+page.svelte`;
					T.warn(`Existing ${import_picocolors$2.default.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const tailwind = dependencyVersion("@tailwindcss/vite") !== void 0;
				const twInputClasses = "class=\"mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500\"";
				const twBtnClasses = "class=\"bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition\"";
				const svelte5 = !!dependencyVersion("svelte")?.startsWith("5");
				const [ts, s5] = createPrinter(typescript, svelte5);
				return dedent_default`
					<script ${ts("lang='ts'")}>
						import { enhance } from '$app/forms';
						${ts("import type { ActionData } from './$types';\n")}
						${s5(`let { form }${ts(": { form: ActionData }")} = $props();`, `export let form${ts(": ActionData")};`)}
					<\/script>

					<h1>Login/Register</h1>
					<form method="post" action="?/login" use:enhance>
						<label>
							Username
							<input
								name="username"
								${tailwind ? twInputClasses : ""}
							/>
						</label>
						<label>
							Password
							<input
								type="password"
								name="password"
								${tailwind ? twInputClasses : ""}
							/>
						</label>
						<button ${tailwind ? twBtnClasses : ""}
							>Login</button>
						<button
							formaction="?/register"
							${tailwind ? twBtnClasses : ""}
							>Register</button>
					</form>
					<p style='color: red'>{form?.message ?? ''}</p>
				`;
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/+page.server.${ext}`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/+page.server.${typescript ? "ts" : "js"}`;
					T.warn(`Existing ${import_picocolors$2.default.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const [ts] = createPrinter(typescript);
				return dedent_default`
					import * as auth from '$lib/server/auth';
					import { fail, redirect } from '@sveltejs/kit';
					import { getRequestEvent } from '$app/server';
					${ts("import type { Actions, PageServerLoad } from './$types';\n")}
					export const load${ts(": PageServerLoad")} = async () => {
						const user = requireLogin()
						return { user };
					};

					export const actions${ts(": Actions")} = {
						logout: async (event) => {
							if (!event.locals.session) {
								return fail(401);
							}
							await auth.invalidateSession(event.locals.session.id);
							auth.deleteSessionTokenCookie(event);

							return redirect(302, '/demo/lucia/login');
						},
					};

					function requireLogin() {
					  const { locals } = getRequestEvent();

					  if (!locals.user) {
					    return redirect(302, "/demo/lucia/login");
					  }

					  return locals.user;
					}
				`;
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/+page.svelte`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/+page.svelte`;
					T.warn(`Existing ${import_picocolors$2.default.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const svelte5 = !!dependencyVersion("svelte")?.startsWith("5");
				const [ts, s5] = createPrinter(typescript, svelte5);
				return dedent_default`
					<script ${ts("lang='ts'")}>
						import { enhance } from '$app/forms';
						${ts("import type { PageServerData } from './$types';\n")}
						${s5(`let { data }${ts(": { data: PageServerData }")} = $props();`, `export let data${ts(": PageServerData")};`)}
					<\/script>

					<h1>Hi, {data.user.username}!</h1>
					<p>Your user ID is {data.user.id}.</p>
					<form method='post' action='?/logout' use:enhance>
						<button>Sign out</button>
					</form>
				`;
			});
		}
	},
	nextSteps: ({ highlighter, options: options$6, packageManager }) => {
		const { command, args } = resolveCommand(packageManager, "run", ["db:push"]);
		const steps = [`Run ${highlighter.command(`${command} ${args.join(" ")}`)} to update your database schema`];
		if (options$6.demo) steps.push(`Visit ${highlighter.route("/demo/lucia")} route to view the demo`);
		return steps;
	}
});
function createLuciaType(name) {
	return {
		type: "TSPropertySignature",
		key: {
			type: "Identifier",
			name
		},
		computed: false,
		typeAnnotation: {
			type: "TSTypeAnnotation",
			typeAnnotation: {
				type: "TSIndexedAccessType",
				objectType: {
					type: "TSImportType",
					argument: {
						type: "Literal",
						value: "$lib/server/auth"
					},
					qualifier: {
						type: "Identifier",
						name: "SessionValidationResult"
					}
				},
				indexType: {
					type: "TSLiteralType",
					literal: {
						type: "Literal",
						value: name
					}
				}
			}
		}
	};
}
function getAuthHandleContent() {
	return `
		async ({ event, resolve }) => {
			const sessionToken = event.cookies.get(auth.sessionCookieName);
			if (!sessionToken) {
				event.locals.user = null;
				event.locals.session = null;
				return resolve(event);
			}

			const { session, user } = await auth.validateSessionToken(sessionToken);
			if (session) {
				auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);
			} else {
				auth.deleteSessionTokenCookie(event);
			}

			event.locals.user = user;
			event.locals.session = session;

			return resolve(event);
		};`;
}
function getCallExpression(ast) {
	let callExpression;
	walk(ast, null, { CallExpression(node) {
		callExpression ??= node;
	} });
	return callExpression;
}

//#endregion
//#region ../addons/mdsvex/index.ts
var mdsvex_default = defineAddon({
	id: "mdsvex",
	shortDescription: "svelte + markdown",
	homepage: "https://mdsvex.pngwn.io",
	options: {},
	run: ({ sv }) => {
		sv.devDependency("mdsvex", "^0.12.6");
		sv.file("svelte.config.js", (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamed(ast, {
				from: "mdsvex",
				imports: ["mdsvex"]
			});
			const { value: exportDefault } = createDefault(ast, { fallback: create({}) });
			let preprocessorArray = property(exportDefault, {
				name: "preprocess",
				fallback: create$1()
			});
			if (!(preprocessorArray.type === "ArrayExpression")) {
				const previousElement = preprocessorArray;
				preprocessorArray = create$1();
				append(preprocessorArray, previousElement);
				overrideProperties(exportDefault, { preprocess: preprocessorArray });
			}
			const mdsvexCall = createCall({
				name: "mdsvex",
				args: []
			});
			append(preprocessorArray, mdsvexCall);
			const extensionsArray = property(exportDefault, {
				name: "extensions",
				fallback: create$1()
			});
			append(extensionsArray, ".svelte");
			append(extensionsArray, ".svx");
			return generateCode();
		});
	}
});

//#endregion
//#region ../core/tooling/html/index.ts
function createElement(tagName, attributes = {}) {
	const element = new Element(tagName, {}, void 0, Tag);
	element.attribs = attributes;
	return element;
}
function appendElement(childNodes, elementToAppend) {
	childNodes.push(elementToAppend);
}
function addFromRawHtml(childNodes, html) {
	const document = parseHtml$1(html);
	for (const childNode of document.childNodes) childNodes.push(childNode);
}
function addSlot(jsAst, options$6) {
	if (options$6.svelteVersion && (options$6.svelteVersion.startsWith("4") || options$6.svelteVersion.startsWith("3"))) {
		const slot = createElement("slot");
		appendElement(options$6.htmlAst.childNodes, slot);
		return;
	}
	appendFromString(jsAst, { code: "let { children } = $props();" });
	addFromRawHtml(options$6.htmlAst.childNodes, "{@render children()}");
}

//#endregion
//#region ../addons/paraglide/index.ts
const DEFAULT_INLANG_PROJECT = {
	$schema: "https://inlang.com/schema/project-settings",
	modules: ["https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@4/dist/index.js", "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@2/dist/index.js"],
	"plugin.inlang.messageFormat": { pathPattern: "./messages/{locale}.json" }
};
const options$3 = defineAddonOptions().add("languageTags", {
	question: `Which languages would you like to support? ${import_picocolors$2.default.gray("(e.g. en,de-ch)")}`,
	type: "string",
	default: "en, es",
	validate(input) {
		if (!input) return;
		const { invalidLanguageTags, validLanguageTags } = parseLanguageTagInput(input);
		if (invalidLanguageTags.length > 0) if (invalidLanguageTags.length === 1) return `The input "${invalidLanguageTags[0]}" is not a valid IETF BCP 47 language tag`;
		else return `The inputs ${new Intl.ListFormat("en", {
			style: "long",
			type: "conjunction"
		}).format(invalidLanguageTags.map((x$1) => `"${x$1}"`))} are not valid BCP47 language tags`;
		if (validLanguageTags.length === 0) return "Please enter at least one valid BCP47 language tag. Eg: en";
	}
}).add("demo", {
	type: "boolean",
	default: true,
	question: "Do you want to include a demo?"
}).build();
var paraglide_default = defineAddon({
	id: "paraglide",
	shortDescription: "i18n",
	homepage: "https://inlang.com/m/gerre34r/library-inlang-paraglideJs",
	options: options$3,
	setup: ({ kit, unsupported }) => {
		if (!kit) unsupported("Requires SvelteKit");
	},
	run: ({ sv, options: options$6, viteConfigFile, typescript, kit }) => {
		const ext = typescript ? "ts" : "js";
		if (!kit) throw new Error("SvelteKit is required");
		const paraglideOutDir = "src/lib/paraglide";
		sv.devDependency("@inlang/paraglide-js", "^2.3.2");
		sv.file("project.inlang/settings.json", (content) => {
			if (content) return content;
			const { data, generateCode } = parseJson(content);
			for (const key in DEFAULT_INLANG_PROJECT) data[key] = DEFAULT_INLANG_PROJECT[key];
			const { validLanguageTags: validLanguageTags$1 } = parseLanguageTagInput(options$6.languageTags);
			data.baseLocale = validLanguageTags$1[0];
			data.locales = validLanguageTags$1;
			return generateCode();
		});
		sv.file(viteConfigFile, (content) => {
			const { ast, generateCode } = parseScript(content);
			const vitePluginName = "paraglideVitePlugin";
			addNamed(ast, {
				imports: [vitePluginName],
				from: "@inlang/paraglide-js"
			});
			addPlugin(ast, { code: `${vitePluginName}({ 
					project: './project.inlang', 
					outdir: './${paraglideOutDir}' 
				})` });
			return generateCode();
		});
		sv.file(`src/hooks.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamed(ast, {
				from: "$lib/paraglide/runtime",
				imports: ["deLocalizeUrl"]
			});
			const expression = parseExpression("(request) => deLocalizeUrl(request.url).pathname");
			const rerouteIdentifier = declaration(ast, {
				kind: "const",
				name: "reroute",
				value: expression
			});
			if (createNamed(ast, {
				name: "reroute",
				fallback: rerouteIdentifier
			}).declaration !== rerouteIdentifier) T.warn("Adding the reroute hook automatically failed. Add it manually");
			return generateCode();
		});
		sv.file(`src/hooks.server.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			addNamed(ast, {
				from: "$lib/paraglide/server",
				imports: ["paraglideMiddleware"]
			});
			addHooksHandle(ast, {
				typescript,
				newHandleName: "handleParaglide",
				handleContent: `({ event, resolve }) => paraglideMiddleware(event.request, ({ request, locale }) => {
		event.request = request;
		return resolve(event, {
			transformPageChunk: ({ html }) => html.replace('%paraglide.lang%', locale)
		});
	});`
			});
			return generateCode();
		});
		sv.file("src/app.html", (content) => {
			const { ast, generateCode } = parseHtml(content);
			const htmlNode = ast.children.find((child) => child.type === Tag && child.name === "html");
			if (!htmlNode) {
				T.warn("Could not find <html> node in app.html. You'll need to add the language placeholder manually");
				return generateCode();
			}
			htmlNode.attribs = {
				...htmlNode.attribs,
				lang: "%paraglide.lang%"
			};
			return generateCode();
		});
		sv.file(".gitignore", (content) => {
			if (!content) return content;
			if (!content.includes(`\n${paraglideOutDir}`)) content = content.trimEnd() + `\n\n# Paraglide\n${paraglideOutDir}`;
			return content;
		});
		if (options$6.demo) {
			sv.file(`${kit.routesDirectory}/demo/+page.svelte`, (content) => {
				return addToDemoPage(content, "paraglide");
			});
			sv.file(`${kit.routesDirectory}/demo/paraglide/+page.svelte`, (content) => {
				const { script, template, generateCode } = parseSvelte(content, { typescript });
				addNamed(script.ast, {
					from: "$lib/paraglide/messages.js",
					imports: ["m"]
				});
				addNamed(script.ast, {
					from: "$app/navigation",
					imports: ["goto"]
				});
				addNamed(script.ast, {
					from: "$app/state",
					imports: ["page"]
				});
				addNamed(script.ast, {
					from: "$lib/paraglide/runtime",
					imports: ["setLocale"]
				});
				const scriptCode = new MagicString(script.generateCode());
				const templateCode = new MagicString(template.source);
				templateCode.append("\n\n<h1>{m.hello_world({ name: 'SvelteKit User' })}</h1>\n");
				const { validLanguageTags: validLanguageTags$1 } = parseLanguageTagInput(options$6.languageTags);
				const links = validLanguageTags$1.map((x$1) => `${templateCode.getIndentString()}<button onclick={() => setLocale('${x$1}')}>${x$1}</button>`).join("\n");
				templateCode.append(`<div>\n${links}\n</div>`);
				templateCode.append("<p>\nIf you use VSCode, install the <a href=\"https://marketplace.visualstudio.com/items?itemName=inlang.vs-code-extension\" target=\"_blank\">Sherlock i18n extension</a> for a better i18n experience.\n</p>");
				return generateCode({
					script: scriptCode.toString(),
					template: templateCode.toString()
				});
			});
		}
		const { validLanguageTags } = parseLanguageTagInput(options$6.languageTags);
		for (const languageTag of validLanguageTags) sv.file(`messages/${languageTag}.json`, (content) => {
			const { data, generateCode } = parseJson(content);
			data["$schema"] = "https://inlang.com/schema/inlang-message-format";
			data.hello_world = `Hello, {name} from ${languageTag}!`;
			return generateCode();
		});
	},
	nextSteps: ({ highlighter }) => {
		const steps = [`Edit your messages in ${highlighter.path("messages/en.json")}`];
		if (options$3.demo) steps.push(`Visit ${highlighter.route("/demo/paraglide")} route to view the demo`);
		return steps;
	}
});
const isValidLanguageTag = (languageTag) => RegExp("^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$").test(languageTag);
function parseLanguageTagInput(input) {
	const probablyLanguageTags = input.replace(/[,:\s]/g, " ").split(" ").filter(Boolean).map((tag) => tag.toLowerCase());
	const validLanguageTags = [];
	const invalidLanguageTags = [];
	for (const tag of probablyLanguageTags) if (isValidLanguageTag(tag)) validLanguageTags.push(tag);
	else invalidLanguageTags.push(tag);
	return {
		validLanguageTags,
		invalidLanguageTags
	};
}

//#endregion
//#region ../addons/playwright/index.ts
var playwright_default = defineAddon({
	id: "playwright",
	shortDescription: "browser testing",
	homepage: "https://playwright.dev",
	options: {},
	run: ({ sv, typescript }) => {
		const ext = typescript ? "ts" : "js";
		sv.devDependency("@playwright/test", "^1.55.1");
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson(content);
			data.scripts ??= {};
			const scripts = data.scripts;
			const TEST_CMD = "playwright test";
			const RUN_TEST = "npm run test:e2e";
			scripts["test:e2e"] ??= TEST_CMD;
			scripts["test"] ??= RUN_TEST;
			if (!scripts["test"].includes(RUN_TEST)) scripts["test"] += ` && ${RUN_TEST}`;
			return generateCode();
		});
		sv.file(".gitignore", (content) => {
			if (!content) return content;
			if (content.includes("test-results")) return content;
			return "test-results\n" + content.trim();
		});
		sv.file(`e2e/demo.test.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
				import { expect, test } from '@playwright/test';

				test('home page has expected h1', async ({ page }) => {
					await page.goto('/');
					await expect(page.locator('h1')).toBeVisible();
				});
				`;
		});
		sv.file(`playwright.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript(content);
			const defineConfig = parseExpression("defineConfig({})");
			const { value: defaultExport } = createDefault(ast, { fallback: defineConfig });
			const config = {
				webServer: {
					command: "npm run build && npm run preview",
					port: 4173
				},
				testDir: "e2e"
			};
			if (defaultExport.type === "CallExpression" && defaultExport.arguments[0]?.type === "ObjectExpression") {
				addNamed(ast, {
					imports: ["defineConfig"],
					from: "@playwright/test"
				});
				overrideProperties(defaultExport.arguments[0], config);
			} else if (defaultExport.type === "ObjectExpression") overrideProperties(defaultExport, config);
			else T.warn("Unexpected playwright config for playwright add-on. Could not update.");
			return generateCode();
		});
	}
});

//#endregion
//#region ../addons/prettier/index.ts
var prettier_default = defineAddon({
	id: "prettier",
	shortDescription: "formatter",
	homepage: "https://prettier.io",
	options: {},
	run: ({ sv, dependencyVersion }) => {
		sv.devDependency("prettier", "^3.6.2");
		sv.devDependency("prettier-plugin-svelte", "^3.4.0");
		sv.file(".prettierignore", (content) => {
			if (content) return content;
			return dedent_default`
				# Package Managers
				package-lock.json
				pnpm-lock.yaml
				yarn.lock
				bun.lock
				bun.lockb

				# Miscellaneous
				/static/
			`;
		});
		sv.file(".prettierrc", (content) => {
			let data, generateCode;
			try {
				({data, generateCode} = parseJson(content));
			} catch {
				T.warn(`A ${import_picocolors$2.default.yellow(".prettierrc")} config already exists and cannot be parsed as JSON. Skipping initialization.`);
				return content;
			}
			if (Object.keys(data).length === 0) {
				data.useTabs = true;
				data.singleQuote = true;
				data.trailingComma = "none";
				data.printWidth = 100;
			}
			data.plugins ??= [];
			data.overrides ??= [];
			if (!data.plugins.includes("prettier-plugin-svelte")) data.plugins.unshift("prettier-plugin-svelte");
			const overrides = data.overrides;
			if (!overrides.find((o) => o?.options?.parser === "svelte")) overrides.push({
				files: "*.svelte",
				options: { parser: "svelte" }
			});
			return generateCode();
		});
		const eslintVersion = dependencyVersion("eslint");
		const eslintInstalled = hasEslint(eslintVersion);
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson(content);
			data.scripts ??= {};
			const scripts = data.scripts;
			const CHECK_CMD = "prettier --check .";
			scripts["format"] ??= "prettier --write .";
			if (eslintInstalled) {
				scripts["lint"] ??= `${CHECK_CMD} && eslint .`;
				if (!scripts["lint"].includes(CHECK_CMD)) scripts["lint"] += ` && ${CHECK_CMD}`;
			} else scripts["lint"] ??= CHECK_CMD;
			return generateCode();
		});
		if (eslintVersion?.startsWith(SUPPORTED_ESLINT_VERSION) === false) T.warn(`An older major version of ${import_picocolors$2.default.yellow("eslint")} was detected. Skipping ${import_picocolors$2.default.yellow("eslint-config-prettier")} installation.`);
		if (eslintInstalled) {
			sv.devDependency("eslint-config-prettier", "^10.1.8");
			sv.file("eslint.config.js", addEslintConfigPrettier);
		}
	}
});
const SUPPORTED_ESLINT_VERSION = "9";
function hasEslint(version) {
	return !!version && version.startsWith(SUPPORTED_ESLINT_VERSION);
}

//#endregion
//#region ../addons/storybook/index.ts
var storybook_default = defineAddon({
	id: "storybook",
	shortDescription: "frontend workshop",
	homepage: "https://storybook.js.org",
	options: {},
	setup: ({ runsAfter }) => {
		runsAfter("vitest");
		runsAfter("eslint");
	},
	run: async ({ sv }) => {
		const args = [
			"create-storybook@latest",
			"--skip-install",
			"--no-dev"
		];
		if (process.env.NODE_ENV?.toLowerCase() === "test") args.push("--yes");
		await sv.execute(args, "inherit");
		sv.devDependency(`@types/node`, getNodeTypesVersion());
	}
});

//#endregion
//#region ../addons/sveltekit-adapter/index.ts
const adapters = [
	{
		id: "auto",
		package: "@sveltejs/adapter-auto",
		version: "^6.1.0"
	},
	{
		id: "node",
		package: "@sveltejs/adapter-node",
		version: "^5.3.2"
	},
	{
		id: "static",
		package: "@sveltejs/adapter-static",
		version: "^3.0.9"
	},
	{
		id: "vercel",
		package: "@sveltejs/adapter-vercel",
		version: "^5.10.2"
	},
	{
		id: "cloudflare",
		package: "@sveltejs/adapter-cloudflare",
		version: "^7.2.3"
	},
	{
		id: "netlify",
		package: "@sveltejs/adapter-netlify",
		version: "^5.2.3"
	}
];
const options$2 = defineAddonOptions().add("adapter", {
	type: "select",
	question: "Which SvelteKit adapter would you like to use?",
	default: "auto",
	options: adapters.map((p) => ({
		value: p.id,
		label: p.id,
		hint: p.package
	}))
}).build();
var sveltekit_adapter_default = defineAddon({
	id: "sveltekit-adapter",
	alias: "adapter",
	shortDescription: "deployment",
	homepage: "https://svelte.dev/docs/kit/adapters",
	options: options$2,
	setup: ({ kit, unsupported }) => {
		if (!kit) unsupported("Requires SvelteKit");
	},
	run: ({ sv, options: options$6 }) => {
		const adapter = adapters.find((a) => a.id === options$6.adapter);
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson(content);
			const devDeps = data["devDependencies"];
			for (const pkg of Object.keys(devDeps)) if (pkg.startsWith("@sveltejs/adapter-")) delete devDeps[pkg];
			return generateCode();
		});
		sv.devDependency(adapter.package, adapter.version);
		sv.file("svelte.config.js", (content) => {
			const { ast, generateCode } = parseScript(content);
			const adapterImportDecl = ast.body.filter((n) => n.type === "ImportDeclaration").find((importDecl) => typeof importDecl.source.value === "string" && importDecl.source.value.startsWith("@sveltejs/adapter-") && importDecl.importKind === "value");
			let adapterName = "adapter";
			if (adapterImportDecl) {
				adapterImportDecl.source.value = adapter.package;
				adapterImportDecl.source.raw = void 0;
				adapterName = adapterImportDecl.specifiers?.find((s) => s.type === "ImportDefaultSpecifier")?.local?.name;
			} else addDefault(ast, {
				from: adapter.package,
				as: adapterName
			});
			const { value: config } = createDefault(ast, { fallback: create({}) });
			overrideProperties(config, { kit: { adapter: createCall({
				name: adapterName,
				args: [],
				useIdentifiers: true
			}) } });
			if (adapter.package !== "@sveltejs/adapter-auto") {
				const fallback = create({});
				const cfgKitValue = property(config, {
					name: "kit",
					fallback
				});
				const cfgAdapter = propertyNode(cfgKitValue, {
					name: "adapter",
					fallback
				});
				cfgAdapter.leadingComments = [];
			}
			return generateCode();
		});
	}
});

//#endregion
//#region ../addons/tailwindcss/index.ts
const plugins = [{
	id: "typography",
	package: "@tailwindcss/typography",
	version: "^0.5.18"
}, {
	id: "forms",
	package: "@tailwindcss/forms",
	version: "^0.5.10"
}];
const options$1 = defineAddonOptions().add("plugins", {
	type: "multiselect",
	question: "Which plugins would you like to add?",
	options: plugins.map((p) => ({
		value: p.id,
		label: p.id,
		hint: p.package
	})),
	default: [],
	required: false
}).build();
var tailwindcss_default = defineAddon({
	id: "tailwindcss",
	alias: "tailwind",
	shortDescription: "css framework",
	homepage: "https://tailwindcss.com",
	options: options$1,
	run: ({ sv, options: options$6, viteConfigFile, typescript, kit, dependencyVersion }) => {
		const prettierInstalled = Boolean(dependencyVersion("prettier"));
		sv.devDependency("tailwindcss", "^4.1.13");
		sv.devDependency("@tailwindcss/vite", "^4.1.13");
		sv.pnpmBuildDependency("@tailwindcss/oxide");
		if (prettierInstalled) sv.devDependency("prettier-plugin-tailwindcss", "^0.6.14");
		for (const plugin of plugins) {
			if (!options$6.plugins.includes(plugin.id)) continue;
			sv.devDependency(plugin.package, plugin.version);
		}
		sv.file(viteConfigFile, (content) => {
			const { ast, generateCode } = parseScript(content);
			const vitePluginName = "tailwindcss";
			addDefault(ast, {
				as: vitePluginName,
				from: "@tailwindcss/vite"
			});
			addPlugin(ast, {
				code: `${vitePluginName}()`,
				mode: "prepend"
			});
			return generateCode();
		});
		sv.file("src/app.css", (content) => {
			let atRules = parseCss(content).ast.nodes.filter((node) => node.type === "atrule");
			const findAtRule = (name, params) => atRules.find((rule) => rule.name === name && rule.params.replace(/['"]/g, "") === params);
			let code = content;
			if (!findAtRule("import", "tailwindcss")) {
				code = "@import 'tailwindcss';\n" + code;
				atRules = parseCss(code).ast.nodes.filter((node) => node.type === "atrule");
			}
			const pluginPos = atRules.findLast((rule) => ["plugin", "import"].includes(rule.name)).source.end.offset;
			for (const plugin of plugins) {
				if (!options$6.plugins.includes(plugin.id)) continue;
				if (!findAtRule("plugin", plugin.package)) {
					const pluginImport = `\n@plugin '${plugin.package}';`;
					code = code.substring(0, pluginPos) + pluginImport + code.substring(pluginPos);
				}
			}
			return code;
		});
		if (!kit) sv.file("src/App.svelte", (content) => {
			const { script, generateCode } = parseSvelte(content, { typescript });
			addEmpty(script.ast, { from: "./app.css" });
			return generateCode({ script: script.generateCode() });
		});
		else sv.file(`${kit?.routesDirectory}/+layout.svelte`, (content) => {
			const { script, template, generateCode } = parseSvelte(content, { typescript });
			addEmpty(script.ast, { from: "../app.css" });
			if (content.length === 0) {
				const svelteVersion = dependencyVersion("svelte");
				if (!svelteVersion) throw new Error("Failed to determine svelte version");
				addSlot(script.ast, {
					htmlAst: template.ast,
					svelteVersion
				});
			}
			return generateCode({
				script: script.generateCode(),
				template: content.length === 0 ? template.generateCode() : void 0
			});
		});
		if (dependencyVersion("prettier")) sv.file(".prettierrc", (content) => {
			const { data, generateCode } = parseJson(content);
			const PLUGIN_NAME = "prettier-plugin-tailwindcss";
			data.plugins ??= [];
			const plugins$1 = data.plugins;
			if (!plugins$1.includes(PLUGIN_NAME)) plugins$1.push(PLUGIN_NAME);
			data.tailwindStylesheet ??= "./src/app.css";
			return generateCode();
		});
	}
});

//#endregion
//#region ../addons/vitest-addon/index.ts
const options = defineAddonOptions().add("usages", {
	question: "What do you want to use vitest for?",
	type: "multiselect",
	default: ["unit", "component"],
	options: [{
		value: "unit",
		label: "unit testing"
	}, {
		value: "component",
		label: "component testing"
	}],
	required: true
}).build();
var vitest_addon_default = defineAddon({
	id: "vitest",
	shortDescription: "unit testing",
	homepage: "https://vitest.dev",
	options,
	run: ({ sv, viteConfigFile, typescript, kit, options: options$6 }) => {
		const ext = typescript ? "ts" : "js";
		const unitTesting = options$6.usages.includes("unit");
		const componentTesting = options$6.usages.includes("component");
		sv.devDependency("vitest", "^3.2.4");
		if (componentTesting) {
			sv.devDependency("@vitest/browser", "^3.2.4");
			sv.devDependency("vitest-browser-svelte", "^1.1.0");
			sv.devDependency("playwright", "^1.55.1");
		}
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson(content);
			data.scripts ??= {};
			const scripts = data.scripts;
			const TEST_CMD = "vitest";
			const RUN_TEST = "npm run test:unit -- --run";
			scripts["test:unit"] ??= TEST_CMD;
			scripts["test"] ??= RUN_TEST;
			if (!scripts["test"].includes(RUN_TEST)) scripts["test"] += ` && ${RUN_TEST}`;
			return generateCode();
		});
		if (unitTesting) sv.file(`src/demo.spec.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
					import { describe, it, expect } from 'vitest';
	
					describe('sum test', () => {
						it('adds 1 + 2 to equal 3', () => {
							expect(1 + 2).toBe(3);
						});
					});
				`;
		});
		if (componentTesting) {
			const fileName = kit ? `${kit.routesDirectory}/page.svelte.spec.${ext}` : `src/App.svelte.test.${ext}`;
			sv.file(fileName, (content) => {
				if (content) return content;
				return dedent_default`
						import { page } from '@vitest/browser/context';
						import { describe, expect, it } from 'vitest';
						import { render } from 'vitest-browser-svelte';
						${kit ? "import Page from './+page.svelte';" : "import App from './App.svelte';"}

						describe('${kit ? "/+page.svelte" : "App.svelte"}', () => {
							it('should render h1', async () => {
								render(${kit ? "Page" : "App"});
								
								const heading = page.getByRole('heading', { level: 1 });
								await expect.element(heading).toBeInTheDocument();
							});
						});
					`;
			});
			sv.file(`vitest-setup-client.${ext}`, (content) => {
				if (content) return content;
				return dedent_default`
					/// <reference types="@vitest/browser/matchers" />
					/// <reference types="@vitest/browser/providers/playwright" />
				`;
			});
		}
		sv.file(viteConfigFile, (content) => {
			const { ast, generateCode } = parseScript(content);
			const clientObjectExpression = create({
				extends: `./${viteConfigFile}`,
				test: {
					name: "client",
					environment: "browser",
					browser: {
						enabled: true,
						provider: "playwright",
						instances: [{ browser: "chromium" }]
					},
					include: ["src/**/*.svelte.{test,spec}.{js,ts}"],
					exclude: ["src/lib/server/**"],
					setupFiles: [`./vitest-setup-client.${ext}`]
				}
			});
			const serverObjectExpression = create({
				extends: `./${viteConfigFile}`,
				test: {
					name: "server",
					environment: "node",
					include: ["src/**/*.{test,spec}.{js,ts}"],
					exclude: ["src/**/*.svelte.{test,spec}.{js,ts}"]
				}
			});
			const viteConfig = getConfig(ast);
			const testObject = property(viteConfig, {
				name: "test",
				fallback: create({ expect: { requireAssertions: true } })
			});
			const workspaceArray = property(testObject, {
				name: "projects",
				fallback: create$1()
			});
			if (componentTesting) append(workspaceArray, clientObjectExpression);
			if (unitTesting) append(workspaceArray, serverObjectExpression);
			const importName = "defineConfig";
			const { statement, alias } = find(ast, {
				name: importName,
				from: "vite"
			});
			if (statement) {
				addNamed(ast, {
					imports: { defineConfig: alias },
					from: "vitest/config"
				});
				remove(ast, {
					name: importName,
					from: "vite",
					statement
				});
			}
			return generateCode();
		});
	}
});

//#endregion
//#region ../addons/_config/official.ts
const officialAddons = {
	prettier: prettier_default,
	eslint: eslint_default,
	vitest: vitest_addon_default,
	playwright: playwright_default,
	tailwindcss: tailwindcss_default,
	sveltekitAdapter: sveltekit_adapter_default,
	devtoolsJson: devtools_json_default,
	drizzle: drizzle_default,
	lucia: lucia_default,
	mdsvex: mdsvex_default,
	paraglide: paraglide_default,
	storybook: storybook_default
};
function getAddonDetails(id) {
	const details = Object.values(officialAddons).find((a) => a.id === id);
	if (!details) throw new Error(`Invalid add-on: ${id}`);
	return details;
}

//#endregion
//#region ../addons/_config/community.ts
/** EVALUATED AT BUILD TIME */
const communityAddonIds = ["unocss", "unplugin-icons"];
async function getCommunityAddon(name) {
	const { default: details } = await import(`../../../community-addons/${name}.ts`);
	return details;
}

//#endregion
//#region commands/add/utils.ts
var import_picocolors$1 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function getPackageJson(cwd) {
	const packageText = readFile(cwd, commonFilePaths.packageJson);
	if (!packageText) {
		const pkgPath = path.join(cwd, commonFilePaths.packageJson);
		throw new Error(`Invalid workspace: missing '${pkgPath}'`);
	}
	const { data, generateCode } = parseJson(packageText);
	return {
		source: packageText,
		data,
		generateCode
	};
}
async function formatFiles(options$6) {
	const args = [
		"prettier",
		"--write",
		"--ignore-unknown",
		...options$6.paths
	];
	const cmd = resolveCommand(options$6.packageManager, "execute-local", args);
	await be(cmd.command, cmd.args, {
		nodeOptions: {
			cwd: options$6.cwd,
			stdio: "pipe"
		},
		throwOnError: true
	});
}
function readFile(cwd, filePath) {
	const fullFilePath = path.resolve(cwd, filePath);
	if (!fileExists(cwd, filePath)) return "";
	return fs.readFileSync(fullFilePath, "utf8");
}
function installPackages(dependencies, workspace) {
	const { data, generateCode } = getPackageJson(workspace.cwd);
	for (const dependency of dependencies) if (dependency.dev) {
		data.devDependencies ??= {};
		data.devDependencies[dependency.pkg] = dependency.version;
	} else {
		data.dependencies ??= {};
		data.dependencies[dependency.pkg] = dependency.version;
	}
	if (data.dependencies) data.dependencies = alphabetizeProperties(data.dependencies);
	if (data.devDependencies) data.devDependencies = alphabetizeProperties(data.devDependencies);
	writeFile(workspace, commonFilePaths.packageJson, generateCode());
	return commonFilePaths.packageJson;
}
function alphabetizeProperties(obj) {
	const orderedObj = {};
	const sortedEntries = Object.entries(obj).sort(([a], [b]) => a.localeCompare(b));
	for (const [key, value] of sortedEntries) orderedObj[key] = value;
	return orderedObj;
}
function writeFile(workspace, filePath, content) {
	const fullFilePath = path.resolve(workspace.cwd, filePath);
	const fullDirectoryPath = path.dirname(fullFilePath);
	if (content && !content.endsWith("\n")) content += "\n";
	if (!fs.existsSync(fullDirectoryPath)) fs.mkdirSync(fullDirectoryPath, { recursive: true });
	fs.writeFileSync(fullFilePath, content, "utf8");
}
function fileExists(cwd, filePath) {
	const fullFilePath = path.resolve(cwd, filePath);
	return fs.existsSync(fullFilePath);
}
const commonFilePaths = {
	packageJson: "package.json",
	svelteConfig: "svelte.config.js",
	jsconfig: "jsconfig.json",
	tsconfig: "tsconfig.json",
	viteConfig: "vite.config.js",
	viteConfigTS: "vite.config.ts"
};
function getHighlighter() {
	return {
		command: (str) => import_picocolors$1.default.bold(import_picocolors$1.default.cyanBright(str)),
		env: (str) => import_picocolors$1.default.yellow(str),
		path: (str) => import_picocolors$1.default.green(str),
		route: (str) => import_picocolors$1.default.bold(str),
		website: (str) => import_picocolors$1.default.whiteBright(str)
	};
}

//#endregion
//#region commands/add/workspace.ts
async function createWorkspace({ cwd, options: options$6 = {}, packageManager }) {
	const resolvedCwd = path.resolve(cwd);
	const usesTypescript = !any([commonFilePaths.jsconfig, commonFilePaths.tsconfig], { cwd })?.endsWith(commonFilePaths.jsconfig);
	const viteConfigPath = path.join(resolvedCwd, commonFilePaths.viteConfigTS);
	const viteConfigFile = fs.existsSync(viteConfigPath) ? commonFilePaths.viteConfigTS : commonFilePaths.viteConfig;
	let dependencies = {};
	let directory = resolvedCwd;
	const root = findRoot(resolvedCwd);
	while (directory && directory !== root) {
		if (fs.existsSync(path.join(directory, commonFilePaths.packageJson))) {
			const { data: packageJson } = getPackageJson(directory);
			dependencies = {
				...packageJson.devDependencies,
				...packageJson.dependencies,
				...dependencies
			};
		}
		directory = path.dirname(directory);
	}
	for (const [key, value] of Object.entries(dependencies)) dependencies[key] = value.replaceAll(/[^\d|.]/g, "");
	return {
		cwd: resolvedCwd,
		options: options$6,
		packageManager: packageManager ?? (await detect({ cwd }))?.name ?? getUserAgent() ?? "npm",
		typescript: usesTypescript,
		viteConfigFile,
		kit: dependencies["@sveltejs/kit"] ? parseKitOptions(resolvedCwd) : void 0,
		dependencyVersion: (pkg) => dependencies[pkg]
	};
}
function findRoot(cwd) {
	const { root } = path.parse(cwd);
	let directory = cwd;
	while (directory && directory !== root) {
		if (fs.existsSync(path.join(directory, commonFilePaths.packageJson))) {
			if (fs.existsSync(path.join(directory, "pnpm-workspace.yaml"))) return directory;
			const { data } = getPackageJson(directory);
			if (data.workspaces) return directory;
		}
		directory = path.dirname(directory);
	}
	return root;
}
function parseKitOptions(cwd) {
	const configSource = readFile(cwd, commonFilePaths.svelteConfig);
	const { ast } = parseScript(configSource);
	const defaultExport = ast.body.find((s) => s.type === "ExportDefaultDeclaration");
	if (!defaultExport) throw Error("Missing default export in `svelte.config.js`");
	let objectExpression;
	if (defaultExport.declaration.type === "Identifier") {
		const identifier = defaultExport.declaration;
		for (const declaration$1 of ast.body) {
			if (declaration$1.type !== "VariableDeclaration") continue;
			const declarator = declaration$1.declarations.find((d) => d.type === "VariableDeclarator" && d.id.type === "Identifier" && d.id.name === identifier.name);
			if (declarator?.init?.type !== "ObjectExpression") continue;
			objectExpression = declarator.init;
		}
		if (!objectExpression) throw Error("Unable to find svelte config object expression from `svelte.config.js`");
	} else if (defaultExport.declaration.type === "ObjectExpression") objectExpression = defaultExport.declaration;
	if (!objectExpression) throw new Error("Unexpected svelte config shape from `svelte.config.js`");
	const kit = property(objectExpression, {
		name: "kit",
		fallback: create({})
	});
	const files = property(kit, {
		name: "files",
		fallback: create({})
	});
	const routes = property(files, {
		name: "routes",
		fallback: createLiteral("")
	});
	const lib = property(files, {
		name: "lib",
		fallback: createLiteral("")
	});
	const routesDirectory = routes.value || "src/routes";
	const libDirectory = lib.value || "src/lib";
	return {
		routesDirectory,
		libDirectory
	};
}

//#endregion
//#region utils/env.ts
const TESTING = process.env.NODE_ENV?.toLowerCase() === "test";

//#endregion
//#region lib/install.ts
var import_picocolors = /* @__PURE__ */ __toESM(require_picocolors(), 1);
async function installAddon({ addons, cwd, options: options$6, packageManager = "npm" }) {
	const workspace = await createWorkspace({
		cwd,
		packageManager
	});
	const addonSetupResults = setupAddons(Object.values(addons), workspace);
	return await applyAddons({
		addons,
		workspace,
		options: options$6,
		addonSetupResults
	});
}
async function applyAddons({ addons, workspace, addonSetupResults, options: options$6 }) {
	const filesToFormat = /* @__PURE__ */ new Set();
	const allPnpmBuildDependencies = [];
	const mapped = Object.entries(addons).map(([, addon]) => addon);
	const ordered = orderAddons(mapped, addonSetupResults);
	for (const addon of ordered) {
		workspace = await createWorkspace({
			...workspace,
			options: options$6[addon.id]
		});
		const { files, pnpmBuildDependencies } = await runAddon({
			workspace,
			addon,
			multiple: ordered.length > 1
		});
		files.forEach((f) => filesToFormat.add(f));
		pnpmBuildDependencies.forEach((s) => allPnpmBuildDependencies.push(s));
	}
	return {
		filesToFormat: Array.from(filesToFormat),
		pnpmBuildDependencies: allPnpmBuildDependencies
	};
}
function setupAddons(addons, workspace) {
	const addonSetupResults = {};
	for (const addon of addons) {
		const setupResult = {
			unsupported: [],
			dependsOn: [],
			runsAfter: []
		};
		addon.setup?.({
			...workspace,
			dependsOn: (name) => {
				setupResult.dependsOn.push(name);
				setupResult.runsAfter.push(name);
			},
			unsupported: (reason) => setupResult.unsupported.push(reason),
			runsAfter: (name) => setupResult.runsAfter.push(name)
		});
		addonSetupResults[addon.id] = setupResult;
	}
	return addonSetupResults;
}
async function runAddon({ addon, multiple, workspace }) {
	const files = /* @__PURE__ */ new Set();
	for (const [id, question] of Object.entries(addon.options)) if (question.condition?.(workspace.options) !== false) workspace.options[id] ??= question.default;
	const dependencies = [];
	const pnpmBuildDependencies = [];
	const sv = {
		file: (path$1, content) => {
			try {
				let fileContent = fileExists(workspace.cwd, path$1) ? readFile(workspace.cwd, path$1) : "";
				fileContent = content(fileContent);
				if (!fileContent) return fileContent;
				writeFile(workspace, path$1, fileContent);
				files.add(path$1);
			} catch (e) {
				if (e instanceof Error) throw new Error(`Unable to process '${path$1}'. Reason: ${e.message}`);
				throw e;
			}
		},
		execute: async (commandArgs, stdio) => {
			const { command, args } = resolveCommand(workspace.packageManager, "execute", commandArgs);
			const addonPrefix = multiple ? `${addon.id}: ` : "";
			const executedCommand = `${command} ${args.join(" ")}`;
			if (!TESTING) T.step(`${addonPrefix}Running external command ${import_picocolors.default.gray(`(${executedCommand})`)}`);
			if (workspace.packageManager === "npm") args.unshift("--yes");
			try {
				await be(command, args, {
					nodeOptions: {
						cwd: workspace.cwd,
						stdio: TESTING ? "pipe" : stdio
					},
					throwOnError: true
				});
			} catch (error) {
				const typedError = error;
				throw new Error(`Failed to execute scripts '${executedCommand}': ${typedError.message}`, { cause: typedError.output });
			}
		},
		dependency: (pkg, version) => {
			dependencies.push({
				pkg,
				version,
				dev: false
			});
		},
		devDependency: (pkg, version) => {
			dependencies.push({
				pkg,
				version,
				dev: true
			});
		},
		pnpmBuildDependency: (pkg) => {
			pnpmBuildDependencies.push(pkg);
		}
	};
	await addon.run({
		...workspace,
		sv
	});
	const pkgPath = installPackages(dependencies, workspace);
	files.add(pkgPath);
	return {
		files: Array.from(files),
		pnpmBuildDependencies
	};
}
function orderAddons(addons, setupResults) {
	return addons.sort((a, b) => {
		return setupResults[a.id]?.runsAfter?.length - setupResults[b.id]?.runsAfter?.length;
	});
}

//#endregion
export { addDefault, applyAddons, communityAddonIds, create, createDefault, createWorkspace, formatFiles, getAddonDetails, getCommunityAddon, getHighlighter, installAddon, officialAddons, overrideProperties, setupAddons };