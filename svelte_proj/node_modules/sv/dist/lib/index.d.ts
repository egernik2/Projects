//#region ../create/index.d.ts
type TemplateType = (typeof templateTypes)[number];
type LanguageType = (typeof languageTypes)[number];
declare const templateTypes: readonly ["minimal", "demo", "library"];
declare const languageTypes: readonly ["typescript", "checkjs", "none"];
type Options = {
  name: string;
  template: TemplateType;
  types: LanguageType;
};
declare function create(cwd: string, options: Options): void;
//#endregion
//#region ../core/addon/options.d.ts
type BooleanQuestion = {
  type: "boolean";
  default: boolean;
};
type StringQuestion = {
  type: "string";
  default: string;
  validate?: (value: string | undefined) => string | Error | undefined;
  placeholder?: string;
};
type NumberQuestion = {
  type: "number";
  default: number;
  validate?: (value: string | undefined) => string | Error | undefined;
  placeholder?: string;
};
type SelectQuestion<Value> = {
  type: "select";
  default: NoInfer<Value>;
  options: Array<{
    value: Value;
    label?: string;
    hint?: string;
  }>;
};
type MultiSelectQuestion<Value> = {
  type: "multiselect";
  default: NoInfer<Value[]>;
  options: Array<{
    value: Value;
    label?: string;
    hint?: string;
  }>;
  required: boolean;
};
type BaseQuestion<Args extends OptionDefinition> = {
  question: string;
  group?: string;
  /**
  * When this condition explicitly returns `false`, the question's value will
  * always be `undefined` and will not fallback to the specified `default` value.
  */
  condition?: (options: OptionValues<Args>) => boolean;
};
type Question<Args extends OptionDefinition = OptionDefinition> = BaseQuestion<Args> & (BooleanQuestion | StringQuestion | NumberQuestion | SelectQuestion<any> | MultiSelectQuestion<any>);
type OptionDefinition = Record<string, Question<any>>;
type OptionValues<Args extends OptionDefinition> = { [K in keyof Args]: Args[K] extends StringQuestion ? string : Args[K] extends BooleanQuestion ? boolean : Args[K] extends NumberQuestion ? number : Args[K] extends SelectQuestion<infer Value> ? Value : Args[K] extends MultiSelectQuestion<infer Value> ? Value[] : "ERROR: The value for this type is invalid. Ensure that the `default` value exists in `options`." };
//#endregion
//#region ../core/addon/workspace.d.ts
type Workspace<Args extends OptionDefinition> = {
  options: OptionValues<Args>;
  cwd: string;
  /**
  * Returns the dependency version declared in the package.json.
  * This may differ from the installed version.
  * Includes both dependencies and devDependencies.
  * Also checks parent package.json files if called in a monorepo.
  * @param pkg the package to check for
  * @returns the dependency version with any leading characters such as ^ or ~ removed
  */
  dependencyVersion: (pkg: string) => string | undefined;
  typescript: boolean;
  viteConfigFile: string;
  kit: {
    libDirectory: string;
    routesDirectory: string;
  } | undefined;
  packageManager: PackageManager;
};
type PackageManager = "npm" | "yarn" | "pnpm" | "bun" | "deno";
//#endregion
//#region ../core/addon/config.d.ts
type SvApi = {
  pnpmBuildDependency: (pkg: string) => void;
  dependency: (pkg: string, version: string) => void;
  devDependency: (pkg: string, version: string) => void;
  execute: (args: string[], stdio: "inherit" | "pipe") => Promise<void>;
  file: (path: string, edit: (content: string) => string) => void;
};
type Addon<Args extends OptionDefinition> = {
  id: string;
  alias?: string;
  shortDescription?: string;
  homepage?: string;
  options: Args;
  setup?: (workspace: Workspace<Args> & {
    dependsOn: (name: string) => void;
    unsupported: (reason: string) => void;
    runsAfter: (addonName: string) => void;
  }) => MaybePromise<void>;
  run: (workspace: Workspace<Args> & {
    sv: SvApi;
  }) => MaybePromise<void>;
  nextSteps?: (data: {
    highlighter: Highlighter;
  } & Workspace<Args>) => string[];
};
type Highlighter = {
  path: (str: string) => string;
  command: (str: string) => string;
  website: (str: string) => string;
  route: (str: string) => string;
  env: (str: string) => string;
};
type AddonSetupResult = {
  dependsOn: string[];
  unsupported: string[];
  runsAfter: string[];
};
type MaybePromise<T> = Promise<T> | T;
//#endregion
//#region lib/install.d.ts
type InstallOptions<Addons extends AddonMap> = {
  cwd: string;
  addons: Addons;
  options: OptionMap<Addons>;
  packageManager?: PackageManager;
};
type AddonMap = Record<string, Addon>;
type OptionMap<Addons extends AddonMap> = { [K in keyof Addons]: Partial<OptionValues<Addons[K]["options"]>> };
declare function installAddon<Addons extends AddonMap>({
  addons,
  cwd,
  options,
  packageManager
}: InstallOptions<Addons>): Promise<ReturnType<typeof applyAddons>>;
type ApplyAddonOptions = {
  addons: AddonMap;
  options: OptionMap<AddonMap>;
  workspace: Workspace<any>;
  addonSetupResults: Record<string, AddonSetupResult>;
};
declare function applyAddons({
  addons,
  workspace,
  addonSetupResults,
  options
}: ApplyAddonOptions): Promise<{
  filesToFormat: string[];
  pnpmBuildDependencies: string[];
}>;
//#endregion
//#region ../addons/_config/official.d.ts
type OfficialAddons = {
  prettier: Addon<any>;
  eslint: Addon<any>;
  vitest: Addon<any>;
  playwright: Addon<any>;
  tailwindcss: Addon<any>;
  sveltekitAdapter: Addon<any>;
  devtoolsJson: Addon<any>;
  drizzle: Addon<any>;
  lucia: Addon<any>;
  mdsvex: Addon<any>;
  paraglide: Addon<any>;
  storybook: Addon<any>;
};
declare const officialAddons: OfficialAddons;
//#endregion
export { type AddonMap, type InstallOptions, type LanguageType, type OptionMap, type TemplateType, create, installAddon, officialAddons };